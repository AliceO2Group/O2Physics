# Rivet on MC productions

[[_TOC_]]

## Content

The code is split into source and header files.  The header files
contains common utilities and data structures.

The header files are

- [`Wrapper.h`](../Tasks/Wrapper.h): This defines the class
  `o2::rivet::Wrapper`, which gets a HepMC3 event structure (e.g.,
  generated by `o2::eventgen::AODToHepMC`) and passes it on to Rivet
  for analysis.

  The class defines a number of `o2::framework::Configurable` to set

  - which analyses to run
  - load paths for analyses binary code and data
  - data to pre-load (e.g., for centrality calibrations)
  - source files of Rivet analyses to build into binary Rivet plugins
    (analyses) at runtime.

  It also provides a number of other options to configure the Rivet
  run.

  The class generates a
  [`o2::rivet::RivetAOs`](../DataModel/RivetAOs.h) object which simply
  contains the YODA output of the analyses run as a text string, as
  well as the load paths set (needed for merging).  This object can be
  read in (from `AnalysisResults.root`) for further processing.

  **NOTE**
  - According Anton Alkin, jobs are never called when output is
    merged.  That is, the old

        AliAnalysisTask::Terminate

    step is no longer available.  Instead, output is merged via a
    straight up `TFileMerger` call.   This is a regression.

- [RivetAOs.h](../DataModel/RivetAOs.h): This defines the class
  `o2::rivet::RivetAOs` which stores the result of running Rivet
  analyses on the input data.  It stores the YODA analysis objects as
  a string which can then be retrieved for further processing.
  It also stores the load paths used during processing as this is
  needed for the merging step.

  **TBD**: Perhaps compiled sources should also be stored.
  This class defines how to merge objects of this kind.  Note that
  merging objects implies running a `Rivet::Analysis::finalize` step
  on the analysis objects.

  **NOTE**

  - According Anton Alkin, jobs are never called when output is
    merged.  That is, the old

        AliAnalysisTask::Terminate

    step is no longer available.  Instead, output is merged via a
    straight up `TFileMerger` call.   This is a regression.

The task is

- [`rivet.cxx`](../Tasks/rivet.cxx) : Reads in AOD MC tables
  (f.ex. via `o2-aod-mc-producer-workflow`, `o2-sim-kine-publisher`,
  or `o2-sim-mctracks-to-aod`) and converts to HepMC (via
  `o2::eventgen::AODToHepMC`) and then runs Rivet analyses on that
  data (using [`o2::rivet::Wrapper`](../Tasks/Wrapper.h)).  This is
  the main workflow of the project compiled into the application
  `o2-analysis-mm-rivet`.

Other files in this project

- [`Tools`](../Tools) Here is a script [`hepmc.py`](../Tools/hepmc.py) that
  can draw an event.
- [`presentation`](presentation) Some presentations
- [`analyses`](analyses) Some example Rivet analyses for testing
  purposes.
- [`examples`](examples) Examples of use.

## Make a simulation

To make a simulation, with transport, we can do for example

    o2-sim -j 1 -n 10 -g pythia8pp -o pythia8pp \
        --configKeyValues "GeneratorPythia8.includePartonEvent=true"

This will produce `pythia8pp_Kine.root`.  Note that the O2 Pythia8 EG
by default strips out non- final and decayed particles (including
beam-particles), and does not properly set the event tree.  This is
why we need to force the O2 Pythia8 EG to store the full
"parton-level" tree.

We can also make a HepMC file of EG output

    ./egs/pythia -n 10 -o genpythia.hepmc

which we can then feed into the simulation (this time without
transport)

    o2-sim -j 1 -g hepmc -o genpythia --noGeant \
        --configKeyValues "GeneratorFileOrCmd.fileNames=genpythia.hepmc"

This will generate `genpythia_Kine.root`

## Read the kinematics

When we have the kinematics file, we can process it futher, for
example to create a HepMC file we can compare to the input

    o2-aod-mc-producer-workflow    \
        --mckine-fname genpythia | \
      o2-aod-mc-to-hepmc --hepmc-dump genpythia.hepmc

or

    o2-sim-kine-publisher --aggregate-timeframe 1   \
        --kineFileName genpythia_Kine.root        | \
      o2-sim-mctracks-to-aod                      | \
      o2-aod-mc-to-hepmc --hepmc-dump genpythia.hepmc

We can compare `genpythia.hepmc` and `genpythia_Kine.hepmc`, for
example using [hepmc.py](../Tools/hepmc.py) to see if all is passed
on as we thing.

## Run a Rivet analysis

    o2-aod-mc-producer-workflow                       \
        --mckine-fname genpythia                    | \
      o2-analysis-mm-rivet                            \
          --rivet-dump genpythia_Kine.yoda            \
          --rivet-analysis ALICE_YYYY_I1234567        \
          --rivet-pwd                                 \
          --rivet-sources ALICE_YYYY_I1234567.C       \
          --rivet-load-paths `pwd`/analyses           \
          --rivet-finalize                            \
          --hepmc-recenter

where `./analysis` is assumed to hold the analysis code
`ALICE_YYYY_I1234567.C`, and associated files.
The output is written in `genpythia_Kine.yoda` (option `--rivet-dump`)
and as an `o2::rivet::RivetAOs` object in `AnalysisResults.root`

The option `--rivet-finalize` runs the `Rivet::Analysis::finalize`
step of all registered analyses. If we are only processing a single
input file, or do not split the processing over several jobs, then
this is useful for creating the final output.

If the analysis is done in parts, then the `Rivet::Analysis::finalize`
is done when the output `AnalysisResults.root` are merged.

The option `--hepmc-recenter` shifts the entire event back to a
interaction point of (0,0,0,0) as is most often assumed by Rivet
analyses.

## Dependencies

This package _requires_ HepMC3 and Rivet.  Furthermore, Rivet needs to
be build against HepMC3 (not HepMC2).
The list of dependecies are

- Rivet
  - HepMC3
  - YODA
    - Python
  - FastJetContrib
    - FastJet
      - cgal
      - GMP
- O2
  - arrow
  - FairRoot
    - FairMQ
      - zeromq
      - Boost
      - FairLogger
        - fmt
    - Generators
      - pythia
      - pythia8
    - Simulation
      - Geant3
        - VMC
          - ROOT
            - zeromq
            - arrow
            - XRootd
            - ProtoBuf
            - Vc
      - Geant4_VMC
        - VMC
        - Geant4
        - VGM
  - libuv
  - ms_gsl
  - MCStepLogger
    - VMC
  - libjalien
  - cgal
  - FFTW3 - single-precision
  - KFParticle
    - ROOT
  - ITSResponse
  - Common-O2
  - Configuration
    - ppconsule(?)
  - Monitoring
  - fastjet
  - vecgeom
    - ROOT
