// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//  Lambdakzero builder task
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//
//  This task loops over a set of V0 indices and
//  creates the corresponding analysis tables that contain
//  the typical information required for analysis.
//
//  PERFORMANCE WARNING: this task includes several track
//  propagation calls that are intrinsically heavy. Please
//  also be cautious when adjusting selections: these can
//  increase / decrease CPU consumption quite significantly.
//
//  IDEAL USAGE: if you are interested in taking V0s and
//  cascades and propagating TrackParCovs based on these,
//  please do not re-propagate the daughters. Instead,
//  the tables generated by this builder task can be used
//  to instantiate a TrackPar object (default operation)
//  or even a TrackParCov object (for which you will
//  need to enable the option of producing the V0Cov and
//  CascCov tables too).
//
//    Comments, questions, complaints, suggestions?
//    Please write to:
//    david.dobrigkeit.chinellato@cern.ch
//

#include <cmath>
#include <array>
#include <cstdlib>
#include <map>
#include <iterator>
#include <utility>

#include "Framework/runDataProcessing.h"
#include "Framework/RunningWorkflowInfo.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Framework/ASoAHelpers.h"
#include "DCAFitter/DCAFitterN.h"
#include "ReconstructionDataFormats/Track.h"
#include "Common/Core/RecoDecay.h"
#include "Common/Core/trackUtilities.h"
#include "PWGLF/DataModel/LFStrangenessTables.h"
#include "PWGLF/DataModel/LFParticleIdentification.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"
#include "DetectorsBase/Propagator.h"
#include "DetectorsBase/GeometryManager.h"
#include "DataFormatsParameters/GRPObject.h"
#include "DataFormatsParameters/GRPMagField.h"
#include "CCDB/BasicCCDBManager.h"
#include "DataFormatsCalibration/MeanVertexObject.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;
using std::array;

// simple checkers
#define bitset(var, nbit) ((var) |= (1 << (nbit)))
#define bitcheck(var, nbit) ((var) & (1 << (nbit)))

// use parameters + cov mat non-propagated, aux info + (extension propagated)
using FullTracksExt = soa::Join<aod::Tracks, aod::TracksExtra, aod::TracksCov>;
using FullTracksExtIU = soa::Join<aod::TracksIU, aod::TracksExtra, aod::TracksCovIU>;
using TracksWithExtra = soa::Join<aod::Tracks, aod::TracksExtra>;

// For dE/dx association in pre-selection
using TracksExtraWithPID = soa::Join<aod::TracksExtra, aod::pidTPCFullEl, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullHe>;

// For MC and dE/dx association
using TracksExtraWithPIDandLabels = soa::Join<aod::TracksExtra, aod::pidTPCFullEl, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullHe, aod::McTrackLabels>;

// Pre-selected V0s
using TaggedV0s = soa::Join<aod::V0s, aod::V0Tags>;

// For MC association in pre-selection
using LabeledTracksExtra = soa::Join<aod::TracksExtra, aod::McTrackLabels>;

struct lambdakzeroBuilder {
  Produces<aod::V0Indices> v0indices;
  Produces<aod::StoredV0Cores> v0cores;
  Produces<aod::V0TrackXs> v0trackXs;
  Produces<aod::V0Covs> v0covs; // covariances

  Produces<aod::V0fCIndices> v0fcindices;
  Produces<aod::StoredV0fCCores> v0fccores;
  Produces<aod::V0fCTrackXs> v0fctrackXs;
  Produces<aod::V0fCCovs> v0fccovs;

  Service<o2::ccdb::BasicCCDBManager> ccdb;

  // Configurables related to table creation
  Configurable<int> createV0CovMats{"createV0CovMats", -1, {"Produces V0 cov matrices. -1: auto, 0: don't, 1: yes. Default: auto (-1)"}};

  Configurable<bool> storePhotonCandidates{"storePhotonCandidates", false, "store photon candidates (yes/no)"};

  // use auto-detect configuration
  Configurable<bool> d_UseAutodetectMode{"d_UseAutodetectMode", false, "Autodetect requested topo sels"};

  // downscaling for testing
  Configurable<float> downscaleFactor{"downscaleFactor", 2, "Downcale factor (0: build nothing, 1: build all)"};
  unsigned int randomSeed = 0;

  Configurable<float> dcanegtopv{"dcanegtopv", .1, "DCA Neg To PV"};
  Configurable<float> dcapostopv{"dcapostopv", .1, "DCA Pos To PV"};
  Configurable<double> v0cospa{"v0cospa", 0.995, "V0 CosPA"}; // double -> N.B. dcos(x)/dx = 0 at x=0)
  Configurable<float> dcav0dau{"dcav0dau", 1.0, "DCA V0 Daughters"};
  Configurable<float> v0radius{"v0radius", 0.9, "v0radius"};

  Configurable<int> tpcrefit{"tpcrefit", 0, "demand TPC refit"};

  // Operation and minimisation criteria
  Configurable<double> d_bz_input{"d_bz", -999, "bz field, -999 is automatic"};
  Configurable<bool> d_UseAbsDCA{"d_UseAbsDCA", true, "Use Abs DCAs"};
  Configurable<bool> d_UseWeightedPCA{"d_UseWeightedPCA", false, "Vertices use cov matrices"};
  Configurable<float> d_maxDZIni{"d_maxDZIni", 1e9, "Dont consider a seed (circles intersection) if Z distance exceeds this"};
  Configurable<float> d_maxDXYIni{"d_maxDXYIni", 4, "Dont consider a seed (circles intersection) if XY distance exceeds this"};
  Configurable<int> useMatCorrType{"useMatCorrType", 2, "0: none, 1: TGeo, 2: LUT"};
  Configurable<int> rejDiffCollTracks{"rejDiffCollTracks", 0, "rejDiffCollTracks"};
  Configurable<bool> d_doTrackQA{"d_doTrackQA", false, "do track QA"};
  Configurable<bool> d_QA_checkMC{"d_QA_checkMC", true, "check MC truth in QA"};
  Configurable<bool> d_QA_checkdEdx{"d_QA_checkdEdx", false, "check dEdx in QA"};

  // CCDB options
  Configurable<std::string> ccdburl{"ccdb-url", "http://alice-ccdb.cern.ch", "url of the ccdb repository"};
  Configurable<std::string> grpPath{"grpPath", "GLO/GRP/GRP", "Path of the grp file"};
  Configurable<std::string> grpmagPath{"grpmagPath", "GLO/Config/GRPMagField", "CCDB path of the GRPMagField object"};
  Configurable<std::string> lutPath{"lutPath", "GLO/Param/MatLUT", "Path of the Lut parametrization"};
  Configurable<std::string> geoPath{"geoPath", "GLO/Config/GeometryAligned", "Path of the geometry file"};
  Configurable<std::string> mVtxPath{"mVtxPath", "GLO/Calib/MeanVertex", "Path of the mean vertex file"};
  Configurable<bool> skipGRPOquery{"skipGRPOquery", true, "skip grpo query"};

  // generate and fill extra QA histograms is requested
  Configurable<bool> d_doQA{"d_doQA", false, "Do basic QA"};
  Configurable<int> dQANBinsRadius{"dQANBinsRadius", 500, "Number of radius bins in QA histo"};
  Configurable<int> dQANBinsPtCoarse{"dQANBinsPtCoarse", 10, "Number of pT bins in QA histo"};
  Configurable<int> dQANBinsMass{"dQANBinsMass", 400, "Number of mass bins for QA histograms"};
  Configurable<float> dQAMaxPt{"dQAMaxPt", 5, "max pT in QA histo"};
  Configurable<float> dQAGammaMassWindow{"dQAGammaMassWindow", 0.05, "gamma mass window for ITS cluster map QA"};
  Configurable<float> dQAK0ShortMassWindow{"dQAK0ShortMassWindow", 0.005, "K0 mass window for ITS cluster map QA"};
  Configurable<float> dQALambdaMassWindow{"dQALambdaMassWindow", 0.005, "Lambda/AntiLambda mass window for ITS cluster map QA"};

  ConfigurableAxis axisPtQA{"axisPtQA", {VARIABLE_WIDTH, 0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f, 0.8f, 0.9f, 1.0f, 1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f, 1.8f, 1.9f, 2.0f, 2.2f, 2.4f, 2.6f, 2.8f, 3.0f, 3.2f, 3.4f, 3.6f, 3.8f, 4.0f, 4.4f, 4.8f, 5.2f, 5.6f, 6.0f, 6.5f, 7.0f, 7.5f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 17.0f, 19.0f, 21.0f, 23.0f, 25.0f, 30.0f, 35.0f, 40.0f, 50.0f}, "pt axis for QA histograms"};

  // for topo var QA
  ConfigurableAxis axisTopoVarPointingAngle{"axisTopoVarPointingAngle", {50, 0.0, 1.0}, "pointing angle"};
  ConfigurableAxis axisTopoVarRAP{"axisTopoVarRAP", {50, 0.0, 1.0}, "radius x pointing angle axis"};
  ConfigurableAxis axisTopoVarV0Radius{"axisTopoVarV0Radius", {500, 0.0, 100.0}, "V0 decay radius (cm)"};
  ConfigurableAxis axisTopoVarDCAV0Dau{"axisTopoVarDCAV0Dau", {200, 0.0, 2.0}, "DCA between V0 daughters (cm)"};
  ConfigurableAxis axisTopoVarDCAToPV{"axisTopoVarDCAToPV", {200, -1, 1.0}, "single track DCA to PV (cm)"};
  ConfigurableAxis axisTopoVarDCAV0ToPV{"axisTopoVarDCAV0ToPV", {200, 0, 5.0}, "V0 DCA to PV (cm)"};

  ConfigurableAxis axisX{"axisX", {200, 0, 200}, "X_{IU}"};
  ConfigurableAxis axisRadius{"axisRadius", {500, 0, 50}, "Radius (cm)"};
  ConfigurableAxis axisDeltaDistanceRadii{"axisDeltaDistanceRadii", {500, -50, 50}, "(cm)"};
  ConfigurableAxis axisDCAXY{"axisDCAXY", {500, -50, 50}, "(cm)"};
  ConfigurableAxis axisDCACHI2{"axisDCACHI2", {500, 0, 50}, "#chi^{2}"};
  ConfigurableAxis axisPositionGuess{"axisPositionGuess", {240, 0, 120}, "(cm)"};

  int mRunNumber;
  float d_bz;
  float maxSnp;  // max sine phi for propagation
  float maxStep; // max step size (cm) for propagation
  o2::base::MatLayerCylSet* lut = nullptr;
  o2::dataformats::MeanVertexObject* mVtx = nullptr;

  // Define o2 fitter, 2-prong, active memory (no need to redefine per event)
  o2::vertexing::DCAFitterN<2> fitter;

  Filter taggedFilter = aod::v0tag::isInteresting == true;

  // For manual sliceBy
  Preslice<aod::V0s> perCollision = o2::aod::v0::collisionId;

  enum v0step { kV0All = 0,
                kV0TPCrefit,
                kV0DCAxy,
                kV0DCADau,
                kV0CosPA,
                kV0Radius,
                kCountStandardV0,
                kCountV0forCascade,
                kNV0Steps };

  // Helper struct to pass V0 information
  struct {
    float posTrackX;
    float negTrackX;
    std::array<float, 3> pos;
    std::array<float, 3> posP;
    std::array<float, 3> negP;
    float dcaV0dau;
    float posDCAxy;
    float negDCAxy;
    float cosPA;
    float dcav0topv;
    float V0radius;
    float lambdaMass;
    float antilambdaMass;
  } v0candidate;

  // Helper struct to do bookkeeping of building parameters
  struct {
    std::array<int32_t, kNV0Steps> v0stats;
    std::array<int32_t, 10> posITSclu;
    std::array<int32_t, 10> negITSclu;
    int32_t exceptions;
    int32_t eventCounter;
  } statisticsRegistry;

  HistogramRegistry registry{
    "registry",
    {{"hEventCounter", "hEventCounter", {HistType::kTH1D, {{1, 0.0f, 1.0f}}}},
     {"hCaughtExceptions", "hCaughtExceptions", {HistType::kTH1D, {{1, 0.0f, 1.0f}}}},
     {"hPositiveITSClusters", "hPositiveITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}},
     {"hNegativeITSClusters", "hNegativeITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}}}};

  float CalculateDCAStraightToPV(float X, float Y, float Z, float Px, float Py, float Pz, float pvX, float pvY, float pvZ)
  {
    return std::sqrt((std::pow((pvY - Y) * Pz - (pvZ - Z) * Py, 2) + std::pow((pvX - X) * Pz - (pvZ - Z) * Px, 2) + std::pow((pvX - X) * Py - (pvY - Y) * Px, 2)) / (Px * Px + Py * Py + Pz * Pz));
  }

  void resetHistos()
  {
    statisticsRegistry.exceptions = 0;
    statisticsRegistry.eventCounter = 0;
    for (Int_t ii = 0; ii < kNV0Steps; ii++)
      statisticsRegistry.v0stats[ii] = 0;
    for (Int_t ii = 0; ii < 10; ii++) {
      statisticsRegistry.posITSclu[ii] = 0;
      statisticsRegistry.negITSclu[ii] = 0;
    }
  }

  void fillHistos()
  {
    registry.fill(HIST("hEventCounter"), 0.0, statisticsRegistry.eventCounter);
    registry.fill(HIST("hCaughtExceptions"), 0.0, statisticsRegistry.exceptions);
    for (Int_t ii = 0; ii < kNV0Steps; ii++)
      registry.fill(HIST("hV0Criteria"), ii, statisticsRegistry.v0stats[ii]);
    if (d_doTrackQA) {
      for (Int_t ii = 0; ii < 10; ii++) {
        registry.fill(HIST("hPositiveITSClusters"), ii, statisticsRegistry.posITSclu[ii]);
        registry.fill(HIST("hNegativeITSClusters"), ii, statisticsRegistry.negITSclu[ii]);
      }
    }
  }

  o2::track::TrackParCov lPositiveTrack;
  o2::track::TrackParCov lNegativeTrack;

  void init(InitContext& context)
  {
    resetHistos();

    auto h = registry.add<TH1>("hV0Criteria", "hV0Criteria", kTH1D, {{10, -0.5f, 9.5f}});
    h->GetXaxis()->SetBinLabel(1, "All sel");
    h->GetXaxis()->SetBinLabel(2, "TPC requirement");
    h->GetXaxis()->SetBinLabel(3, "DCAxy Dau to PV");
    h->GetXaxis()->SetBinLabel(4, "DCA V0 Dau");
    h->GetXaxis()->SetBinLabel(5, "CosPA");
    h->GetXaxis()->SetBinLabel(6, "Radius");
    h->GetXaxis()->SetBinLabel(7, "Count: Standard V0");
    h->GetXaxis()->SetBinLabel(8, "Count: V0 exc. for casc");

    randomSeed = static_cast<unsigned int>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());

    // Optionally, add extra QA histograms to processing chain
    if (d_doQA) {
      // Basic histograms containing invariant masses of all built candidates
      const AxisSpec axisVsPtCoarse{static_cast<int32_t>(dQANBinsPtCoarse), 0, dQAMaxPt, "#it{p}_{T} (GeV/c)"};
      const AxisSpec axisGammaMass{static_cast<int32_t>(dQANBinsMass), 0.000f, 0.400f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisK0ShortMass{static_cast<int32_t>(dQANBinsMass), 0.400f, 0.600f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisLambdaMass{static_cast<int32_t>(5 * dQANBinsMass), 1.01f, 2.01f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisHypertritonMass{static_cast<int32_t>(dQANBinsMass), 2.900f, 3.300f, "Inv. Mass (GeV/c^{2})"};

      registry.add("h2dGammaMass", "h2dGammaMass", kTH2F, {axisVsPtCoarse, axisGammaMass});
      registry.add("h2dK0ShortMass", "h2dK0ShortMass", kTH2F, {axisVsPtCoarse, axisK0ShortMass});
      registry.add("h2dLambdaMass", "h2dLambdaMass", kTH2F, {axisVsPtCoarse, axisLambdaMass});
      registry.add("h2dAntiLambdaMass", "h2dAntiLambdaMass", kTH2F, {axisVsPtCoarse, axisLambdaMass});
      registry.add("h2dHypertritonMass", "h2dHypertritonMass", kTH2F, {axisVsPtCoarse, axisHypertritonMass});
      registry.add("h2dAntiHypertritonMass", "h2dAntiHypertritonMass", kTH2F, {axisVsPtCoarse, axisHypertritonMass});

      // bit packed ITS cluster map
      const AxisSpec axisITSCluMap{static_cast<int32_t>(128), -0.5f, +127.5f, "Packed ITS map"};

      // Histogram to bookkeep cluster maps
      registry.add("h2dITSCluMap_Gamma", "h2dITSCluMap_Gamma", kTH3D, {axisITSCluMap, axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_K0Short", "h2dITSCluMap_K0Short", kTH3D, {axisITSCluMap, axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_Lambda", "h2dITSCluMap_Lambda", kTH3D, {axisITSCluMap, axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_AntiLambda", "h2dITSCluMap_AntiLambda", kTH3D, {axisITSCluMap, axisITSCluMap, axisRadius});

      // Histogram to bookkeep cluster maps
      registry.add("h2dXIU_Gamma", "h2dXIU_Gamma", kTH3D, {axisX, axisX, axisRadius});
      registry.add("h2dXIU_K0Short", "h2dXIU_K0Short", kTH3D, {axisX, axisX, axisRadius});
      registry.add("h2dXIU_Lambda", "h2dXIU_Lambda", kTH3D, {axisX, axisX, axisRadius});
      registry.add("h2dXIU_AntiLambda", "h2dXIU_AntiLambda", kTH3D, {axisX, axisX, axisRadius});

      // QA plots of topological variables using axisPtQA
      registry.add("h2dTopoVarPointingAngle", "h2dTopoVarPointingAngle", kTH2D, {axisPtQA, axisTopoVarPointingAngle});
      registry.add("h2dTopoVarRAP", "h2dTopoVarRAP", kTH2D, {axisPtQA, axisTopoVarRAP});
      registry.add("h2dTopoVarV0Radius", "h2dTopoVarV0Radius", kTH2D, {axisPtQA, axisTopoVarV0Radius});
      registry.add("h2dTopoVarDCAV0Dau", "h2dTopoVarDCAV0Dau", kTH2D, {axisPtQA, axisTopoVarDCAV0Dau});
      registry.add("h2dTopoVarPosDCAToPV", "h2dTopoVarPosDCAToPV", kTH2D, {axisPtQA, axisTopoVarDCAToPV});
      registry.add("h2dTopoVarNegDCAToPV", "h2dTopoVarNegDCAToPV", kTH2D, {axisPtQA, axisTopoVarDCAToPV});
      registry.add("h2dTopoVarDCAV0ToPV", "h2dTopoVarDCAV0ToPV", kTH2D, {axisPtQA, axisTopoVarDCAV0ToPV});

      // QA for PCM
      registry.add("h2d_pcm_DCAXY_True", "h2d_pcm_DCAXY_True", kTH2D, {axisPtQA, axisDCAXY});
      registry.add("h2d_pcm_DCAXY_Bg", "h2d_pcm_DCAXY_Bg", kTH2D, {axisPtQA, axisDCAXY});
      registry.add("h2d_pcm_DCACHI2_True", "h2d_pcm_DCACHI2_True", kTH2D, {axisPtQA, axisDCACHI2});
      registry.add("h2d_pcm_DCACHI2_Bg", "h2d_pcm_DCACHI2_Bg", kTH2D, {axisPtQA, axisDCACHI2});
      registry.add("h2d_pcm_DeltaDistanceRadii_True", "h2d_pcm_DeltaDistanceRadii_True", kTH2D, {axisPtQA, axisDeltaDistanceRadii});
      registry.add("h2d_pcm_DeltaDistanceRadii_Bg", "h2d_pcm_DeltaDistanceRadii_Bg", kTH2D, {axisPtQA, axisDeltaDistanceRadii});
      registry.add("h2d_pcm_PositionGuess_True", "h2d_pcm_PositionGuess_True", kTH2D, {axisPtQA, axisPositionGuess});
      registry.add("h2d_pcm_PositionGuess_Bg", "h2d_pcm_PositionGuess_Bg", kTH2D, {axisPtQA, axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius1_True", "h2d_pcm_RadiallyOutgoingAtThisRadius1_True", kTH2D, {axisPtQA, axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius2_True", "h2d_pcm_RadiallyOutgoingAtThisRadius2_True", kTH2D, {axisPtQA, axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius1_Bg", "h2d_pcm_RadiallyOutgoingAtThisRadius1_Bg", kTH2D, {axisPtQA, axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius2_Bg", "h2d_pcm_RadiallyOutgoingAtThisRadius2_Bg", kTH2D, {axisPtQA, axisPositionGuess});
    }

    mRunNumber = 0;
    d_bz = 0;
    maxSnp = 0.85f;  // could be changed later
    maxStep = 2.00f; // could be changed later

    ccdb->setURL(ccdburl);
    ccdb->setCaching(true);
    ccdb->setLocalObjectValidityChecking();
    ccdb->setFatalWhenNull(false);

    if (useMatCorrType == 1) {
      LOGF(info, "TGeo correction requested, loading geometry");
      if (!o2::base::GeometryManager::isGeometryLoaded()) {
        ccdb->get<TGeoManager>(geoPath);
      }
    }
    if (useMatCorrType == 2) {
      LOGF(info, "LUT correction requested, loading LUT");
      lut = o2::base::MatLayerCylSet::rectifyPtrFromFile(ccdb->get<o2::base::MatLayerCylSet>(lutPath));
    }

    if (doprocessRun2 == false && doprocessRun3 == false) {
      LOGF(fatal, "Neither processRun2 nor processRun3 enabled. Please choose one.");
    }
    if (doprocessRun2 == true && doprocessRun3 == true) {
      LOGF(fatal, "Cannot enable processRun2 and processRun3 at the same time. Please choose one.");
    }

    if (d_UseAutodetectMode) {
      double loosest_v0cospa = 100;
      float loosest_dcav0dau = -100;
      float loosest_dcapostopv = 100;
      float loosest_dcanegtopv = 100;
      float loosest_radius = 100;

      double detected_v0cospa = -100;
      float detected_dcav0dau = -100;
      float detected_dcapostopv = 100;
      float detected_dcanegtopv = 100;
      float detected_radius = 100;

      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      LOGF(info, " Single-strange builder self-configuration");
      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      auto& workflows = context.services().get<RunningWorkflowInfo const>();
      for (DeviceSpec const& device : workflows.devices) {
        // Step 1: check if this device subscribed to the V0data table
        for (auto const& input : device.inputs) {
          if (device.name.compare("lambdakzero-initializer") == 0)
            continue; // don't listen to the initializer, it's just to extend stuff
          const std::string v0DataName = "V0Datas";
          const std::string v0DataExtName = "V0DatasExtension";
          if ((input.matcher.binding == v0DataName || input.matcher.binding == v0DataExtName) && device.name.compare("multistrange-builder") != 0) {
            LOGF(info, "Device named %s has subscribed to V0datas table! Will now scan for desired settings...", device.name);
            for (auto const& option : device.options) {
              // 5 V0 topological selections
              if (option.name.compare("v0setting_cospa") == 0) {
                detected_v0cospa = option.defaultValue.get<double>();
                LOGF(info, "%s requested V0 cospa = %f", device.name, detected_v0cospa);
                if (detected_v0cospa < loosest_v0cospa)
                  loosest_v0cospa = detected_v0cospa;
              }
              if (option.name.compare("v0setting_dcav0dau") == 0) {
                detected_dcav0dau = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA V0 daughters = %f", device.name, detected_dcav0dau);
                if (detected_dcav0dau > loosest_dcav0dau)
                  loosest_dcav0dau = detected_dcav0dau;
              }
              if (option.name.compare("v0setting_dcapostopv") == 0) {
                detected_dcapostopv = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA positive daughter to PV = %f", device.name, detected_dcapostopv);
                if (detected_dcapostopv < loosest_dcapostopv)
                  loosest_dcapostopv = detected_dcapostopv;
              }
              if (option.name.compare("v0setting_dcanegtopv") == 0) {
                detected_dcanegtopv = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA negative daughter to PV = %f", device.name, detected_dcanegtopv);
                if (detected_dcanegtopv < loosest_dcanegtopv)
                  loosest_dcanegtopv = detected_dcanegtopv;
              }
              if (option.name.compare("v0setting_radius") == 0) {
                detected_radius = option.defaultValue.get<float>();
                LOGF(info, "%s requested minimum V0 radius = %f", device.name, detected_radius);
                if (detected_radius < loosest_radius)
                  loosest_radius = detected_radius;
              }
            }
          }
          const std::string V0CovsName = "V0Covs";
          if (input.matcher.binding == V0CovsName) {
            LOGF(info, "Device named %s has subscribed to V0Covs table! Enabling.", device.name);
            createV0CovMats.value = 1;
          }
        }
      }
      LOGF(info, "Self-configuration finished! Decided on selections:");
      LOGF(info, " -+*> V0 cospa ..............: %.6f", loosest_v0cospa);
      LOGF(info, " -+*> DCA V0 daughters ......: %.6f", loosest_dcav0dau);
      LOGF(info, " -+*> DCA positive daughter .: %.6f", loosest_dcapostopv);
      LOGF(info, " -+*> DCA negative daughter .: %.6f", loosest_dcanegtopv);
      LOGF(info, " -+*> Minimum V0 radius .....: %.6f", loosest_radius);

      dcanegtopv.value = loosest_dcanegtopv;
      dcapostopv.value = loosest_dcapostopv;
      v0cospa.value = loosest_v0cospa;
      dcav0dau.value = loosest_dcav0dau;
      v0radius.value = loosest_radius;
    }

    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
    LOGF(info, " -+*> process call configuration:");
    if (doprocessRun2 == true) {
      LOGF(info, " ---+*> Run 2 processing enabled. Will subscribe to Tracks table.");
    }
    if (doprocessRun3 == true) {
      LOGF(info, " ---+*> Run 3 processing enabled. Will subscribe to TracksIU table.");
    }
    if (createV0CovMats > 0) {
      LOGF(info, " ---+*> Will produce V0 cov mat table");
    }
    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*

    // initialize O2 2-prong fitter (only once)
    fitter.setPropagateToPCA(true);
    fitter.setMaxR(200.);
    fitter.setMinParamChange(1e-3);
    fitter.setMinRelChi2Change(0.9);
    fitter.setMaxDZIni(d_maxDZIni);
    fitter.setMaxDXYIni(d_maxDXYIni);
    fitter.setMaxChi2(1e9);
    fitter.setUseAbsDCA(d_UseAbsDCA);
    fitter.setWeightedFinalPCA(d_UseWeightedPCA);

    // Material correction in the DCA fitter
    o2::base::Propagator::MatCorrType matCorr = o2::base::Propagator::MatCorrType::USEMatCorrNONE;
    if (useMatCorrType == 1)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrTGeo;
    if (useMatCorrType == 2)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrLUT;
    fitter.setMatCorrType(matCorr);
  }

  void initCCDB(aod::BCsWithTimestamps::iterator const& bc)
  {
    if (mRunNumber == bc.runNumber()) {
      return;
    }

    // In case override, don't proceed, please - no CCDB access required
    if (d_bz_input > -990) {
      d_bz = d_bz_input;
      fitter.setBz(d_bz);
      o2::parameters::GRPMagField grpmag;
      if (fabs(d_bz) > 1e-5) {
        grpmag.setL3Current(30000.f / (d_bz / 5.0f));
      }
      o2::base::Propagator::initFieldFromGRP(&grpmag);
      mVtx = ccdb->getForTimeStamp<o2::dataformats::MeanVertexObject>(mVtxPath, bc.timestamp());
      mRunNumber = bc.runNumber();
      return;
    }

    auto run3grp_timestamp = bc.timestamp();
    o2::parameters::GRPObject* grpo = 0x0;
    o2::parameters::GRPMagField* grpmag = 0x0;
    if (!skipGRPOquery)
      grpo = ccdb->getForTimeStamp<o2::parameters::GRPObject>(grpPath, run3grp_timestamp);
    if (grpo) {
      o2::base::Propagator::initFieldFromGRP(grpo);
      // Fetch magnetic field from ccdb for current collision
      d_bz = grpo->getNominalL3Field();
      LOG(info) << "Retrieved GRP for timestamp " << run3grp_timestamp << " with magnetic field of " << d_bz << " kZG";
    } else {
      grpmag = ccdb->getForTimeStamp<o2::parameters::GRPMagField>(grpmagPath, run3grp_timestamp);
      if (!grpmag) {
        LOG(fatal) << "Got nullptr from CCDB for path " << grpmagPath << " of object GRPMagField and " << grpPath << " of object GRPObject for timestamp " << run3grp_timestamp;
      }
      o2::base::Propagator::initFieldFromGRP(grpmag);
      // Fetch magnetic field from ccdb for current collision
      d_bz = std::lround(5.f * grpmag->getL3Current() / 30000.f);
      LOG(info) << "Retrieved GRP for timestamp " << run3grp_timestamp << " with magnetic field of " << d_bz << " kZG";
    }
    mVtx = ccdb->getForTimeStamp<o2::dataformats::MeanVertexObject>(mVtxPath, bc.timestamp());
    mRunNumber = bc.runNumber();
    // Set magnetic field value once known
    fitter.setBz(d_bz);

    if (useMatCorrType == 2) {
      // setMatLUT only after magfield has been initalized
      // (setMatLUT has implicit and problematic init field call if not)
      o2::base::Propagator::Instance()->setMatLUT(lut);
    }
  }

  template <class TTrackTo, typename TV0Object>
  bool buildV0Candidate(TV0Object const& V0)
  {
    // Get tracks
    auto const& posTrack = V0.template posTrack_as<TTrackTo>();
    auto const& negTrack = V0.template negTrack_as<TTrackTo>();

    // for storing whatever is the relevant quantity for the PV
    o2::dataformats::VertexBase primaryVertex;
    if (V0.has_collision()) {
      auto const& collision = V0.collision();
      primaryVertex.setPos({collision.posX(), collision.posY(), collision.posZ()});
      primaryVertex.setCov(collision.covXX(), collision.covXY(), collision.covYY(), collision.covXZ(), collision.covYZ(), collision.covZZ());
    } else {
      primaryVertex.setPos({mVtx->getX(), mVtx->getY(), mVtx->getZ()});
    }

    // value 0.5: any considered V0
    statisticsRegistry.v0stats[kV0All]++;
    if (tpcrefit) {
      if (!(posTrack.trackType() & o2::aod::track::TPCrefit)) {
        return false;
      }
      if (!(negTrack.trackType() & o2::aod::track::TPCrefit)) {
        return false;
      }
    }

    // Passes TPC refit
    statisticsRegistry.v0stats[kV0TPCrefit]++;

    // Calculate DCA with respect to the collision associated to the V0, not individual tracks
    gpu::gpustd::array<float, 2> dcaInfo;

    auto posTrackPar = getTrackPar(posTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ()}, posTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    auto posTrackdcaXY = dcaInfo[0];

    auto negTrackPar = getTrackPar(negTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ()}, negTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    auto negTrackdcaXY = dcaInfo[0];

    if (fabs(posTrackdcaXY) < dcapostopv || fabs(negTrackdcaXY) < dcanegtopv) {
      return false;
    }

    // Initialize properly, please
    v0candidate.posDCAxy = posTrackdcaXY;
    v0candidate.negDCAxy = negTrackdcaXY;

    // passes DCAxy
    statisticsRegistry.v0stats[kV0DCAxy]++;

    // Change strangenessBuilder tracks
    lPositiveTrack = getTrackParCov(posTrack);
    lNegativeTrack = getTrackParCov(negTrack);

    //---/---/---/
    // Move close to minima
    int nCand = 0;
    try {
      nCand = fitter.process(lPositiveTrack, lNegativeTrack);
    } catch (...) {
      statisticsRegistry.exceptions++;
      LOG(error) << "Exception caught in DCA fitter process call!";
      return false;
    }
    if (nCand == 0) {
      return false;
    }

    v0candidate.posTrackX = fitter.getTrack(0).getX();
    v0candidate.negTrackX = fitter.getTrack(1).getX();

    lPositiveTrack = fitter.getTrack(0);
    lNegativeTrack = fitter.getTrack(1);
    lPositiveTrack.getPxPyPzGlo(v0candidate.posP);
    lNegativeTrack.getPxPyPzGlo(v0candidate.negP);

    // get decay vertex coordinates
    const auto& vtx = fitter.getPCACandidate();
    for (int i = 0; i < 3; i++) {
      v0candidate.pos[i] = vtx[i];
    }

    v0candidate.dcaV0dau = TMath::Sqrt(fitter.getChi2AtPCACandidate());

    // Apply selections so a skimmed table is created only
    if (v0candidate.dcaV0dau > dcav0dau) {
      return false;
    }

    // Passes DCA between daughters check
    statisticsRegistry.v0stats[kV0DCADau]++;

    v0candidate.cosPA = RecoDecay::cpa(array{primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ()}, array{v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2]}, array{v0candidate.posP[0] + v0candidate.negP[0], v0candidate.posP[1] + v0candidate.negP[1], v0candidate.posP[2] + v0candidate.negP[2]});
    if (v0candidate.cosPA < v0cospa) {
      return false;
    }

    v0candidate.dcav0topv = CalculateDCAStraightToPV(
      v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2],
      v0candidate.posP[0] + v0candidate.negP[0],
      v0candidate.posP[1] + v0candidate.negP[1],
      v0candidate.posP[2] + v0candidate.negP[2],
      primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ());

    // Passes CosPA check
    statisticsRegistry.v0stats[kV0CosPA]++;

    v0candidate.V0radius = RecoDecay::sqrtSumOfSquares(v0candidate.pos[0], v0candidate.pos[1]);
    if (v0candidate.V0radius < v0radius) {
      return false;
    }

    // Passes radius check
    statisticsRegistry.v0stats[kV0Radius]++;
    // Return OK: passed all v0 candidate selecton criteria

    if (d_doTrackQA) {
      if (posTrack.itsNCls() < 10)
        statisticsRegistry.posITSclu[posTrack.itsNCls()]++;
      if (negTrack.itsNCls() < 10)
        statisticsRegistry.negITSclu[negTrack.itsNCls()]++;
    }

    if (d_doQA) {
      bool mcUnchecked = !d_QA_checkMC;
      bool dEdxUnchecked = !d_QA_checkdEdx;

      // Calculate masses
      auto lGammaMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassElectron, o2::constants::physics::MassElectron});
      auto lK0ShortMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassPionCharged});
      auto lLambdaMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassProton, o2::constants::physics::MassPionCharged});
      auto lAntiLambdaMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassProton});
      auto lHypertritonMass = RecoDecay::m(array{array{2.0f * v0candidate.posP[0], 2.0f * v0candidate.posP[1], 2.0f * v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassHelium3, o2::constants::physics::MassPionCharged});
      auto lAntiHypertritonMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{2.0f * v0candidate.negP[0], 2.0f * v0candidate.negP[1], 2.0f * v0candidate.negP[2]}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassHelium3});

      auto px = v0candidate.posP[0] + v0candidate.negP[0];
      auto py = v0candidate.posP[1] + v0candidate.negP[1];
      auto pz = v0candidate.posP[2] + v0candidate.negP[2];
      auto lPt = RecoDecay::sqrtSumOfSquares(v0candidate.posP[0] + v0candidate.negP[0], v0candidate.posP[1] + v0candidate.negP[1]);
      auto lPtHy = RecoDecay::sqrtSumOfSquares(2.0f * v0candidate.posP[0] + v0candidate.negP[0], 2.0f * v0candidate.posP[1] + v0candidate.negP[1]);
      auto lPtAnHy = RecoDecay::sqrtSumOfSquares(v0candidate.posP[0] + 2.0f * v0candidate.negP[0], v0candidate.posP[1] + 2.0f * v0candidate.negP[1]);

      // Fill basic mass histograms
      if (TMath::Abs(RecoDecay::eta(std::array{px, py, pz})) < 0.5) {
        if ((V0.isdEdxGamma() || dEdxUnchecked) && (V0.isTrueGamma() || mcUnchecked))
          registry.fill(HIST("h2dGammaMass"), lPt, lGammaMass);
        if ((V0.isdEdxK0Short() || dEdxUnchecked) && (V0.isTrueK0Short() || mcUnchecked))
          registry.fill(HIST("h2dK0ShortMass"), lPt, lK0ShortMass);
        if ((V0.isdEdxLambda() || dEdxUnchecked) && (V0.isTrueLambda() || mcUnchecked))
          registry.fill(HIST("h2dLambdaMass"), lPt, lLambdaMass);
        if ((V0.isdEdxAntiLambda() || dEdxUnchecked) && (V0.isTrueAntiLambda() || mcUnchecked))
          registry.fill(HIST("h2dAntiLambdaMass"), lPt, lAntiLambdaMass);
        if ((V0.isdEdxHypertriton() || dEdxUnchecked) && (V0.isTrueHypertriton() || mcUnchecked))
          registry.fill(HIST("h2dHypertritonMass"), lPtHy, lHypertritonMass);
        if ((V0.isdEdxAntiHypertriton() || dEdxUnchecked) && (V0.isTrueAntiHypertriton() || mcUnchecked))
          registry.fill(HIST("h2dAntiHypertritonMass"), lPtAnHy, lAntiHypertritonMass);
      }

      // Fill ITS cluster maps with specific mass cuts
      if (TMath::Abs(lGammaMass - 0.0) < dQAGammaMassWindow && ((V0.isdEdxGamma() || dEdxUnchecked) && (V0.isTrueGamma() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_Gamma"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_Gamma"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }
      if (TMath::Abs(lK0ShortMass - 0.497) < dQAK0ShortMassWindow && ((V0.isdEdxK0Short() || dEdxUnchecked) && (V0.isTrueK0Short() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_K0Short"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_K0Short"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }
      if (TMath::Abs(lLambdaMass - 1.116) < dQALambdaMassWindow && ((V0.isdEdxLambda() || dEdxUnchecked) && (V0.isTrueLambda() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_Lambda"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_Lambda"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }
      if (TMath::Abs(lAntiLambdaMass - 1.116) < dQALambdaMassWindow && ((V0.isdEdxAntiLambda() || dEdxUnchecked) && (V0.isTrueAntiLambda() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_AntiLambda"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_AntiLambda"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }

      // QA extra: DCA to PV
      float dcaV0toPV = std::sqrt((std::pow((primaryVertex.getY() - v0candidate.pos[1]) * pz - (primaryVertex.getZ() - v0candidate.pos[2]) * py, 2) + std::pow((primaryVertex.getX() - v0candidate.pos[0]) * pz - (primaryVertex.getZ() - v0candidate.pos[2]) * px, 2) + std::pow((primaryVertex.getX() - v0candidate.pos[0]) * py - (primaryVertex.getY() - v0candidate.pos[1]) * px, 2)) / (px * px + py * py + pz * pz));

      registry.fill(HIST("h2dTopoVarPointingAngle"), lPt, TMath::ACos(v0candidate.cosPA));
      registry.fill(HIST("h2dTopoVarRAP"), lPt, TMath::ACos(v0candidate.cosPA) * v0candidate.V0radius);
      registry.fill(HIST("h2dTopoVarV0Radius"), lPt, v0candidate.V0radius);
      registry.fill(HIST("h2dTopoVarDCAV0Dau"), lPt, v0candidate.dcaV0dau);
      registry.fill(HIST("h2dTopoVarPosDCAToPV"), lPt, v0candidate.posDCAxy);
      registry.fill(HIST("h2dTopoVarNegDCAToPV"), lPt, v0candidate.negDCAxy);
      registry.fill(HIST("h2dTopoVarDCAV0ToPV"), lPt, dcaV0toPV);

      // -------------------------------------------------------------------------------------
      // PCM finding tests
      //
      // a) delta1 = D - R1 - R2
      //             D: distance between two track helix centers in xy
      //             R1, R2: track radii

      o2::math_utils::CircleXYf_t trcCircle1, trcCircle2;
      float sna, csa;
      posTrackPar.getCircleParams(d_bz, trcCircle1, sna, csa);
      negTrackPar.getCircleParams(d_bz, trcCircle2, sna, csa);

      // distance between circle centers (one circle is at origin -> easy)
      float centerDistance = std::hypot(trcCircle1.xC - trcCircle2.xC, trcCircle1.yC - trcCircle2.yC);

      // b) delta2 = abs(R2/(R1+R2)*rvec1 + R1/(R1+R2)*rvec2)
      float r1_r = trcCircle1.rC / (trcCircle1.rC + trcCircle2.rC);
      float r2_r = trcCircle2.rC / (trcCircle1.rC + trcCircle2.rC);
      float delta2 = std::hypot(r2_r * trcCircle1.xC + r1_r * trcCircle2.xC, r2_r * trcCircle1.yC + r1_r * trcCircle2.yC);

      // c) delta3 = sqrt(D^2-R^2); D: distance origin-center, R: radius
      float delta3_track1 = TMath::Sqrt(TMath::Power(trcCircle1.xC, 2) + TMath::Power(trcCircle1.yC, 2) - TMath::Power(trcCircle1.rC, 2));
      float delta3_track2 = TMath::Sqrt(TMath::Power(trcCircle2.xC, 2) + TMath::Power(trcCircle2.yC, 2) - TMath::Power(trcCircle2.rC, 2));

      // let's just use tagged, cause we can
      if (!posTrack.hasITS() && !posTrack.hasTRD() && !posTrack.hasTOF() && !negTrack.hasITS() && !negTrack.hasTRD() && !negTrack.hasTOF()) {
        if (V0.isTrueGamma()) {
          registry.fill(HIST("h2d_pcm_DCAXY_True"), lPt, std::hypot(dcaInfo[0], dcaInfo[1]));
          registry.fill(HIST("h2d_pcm_DCACHI2_True"), lPt, fitter.getChi2AtPCACandidate());
          registry.fill(HIST("h2d_pcm_DeltaDistanceRadii_True"), lPt, centerDistance - trcCircle1.rC - trcCircle2.rC);
          registry.fill(HIST("h2d_pcm_PositionGuess_True"), lPt, delta2);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius1_True"), lPt, delta3_track1);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius2_True"), lPt, delta3_track2);
        } else {
          registry.fill(HIST("h2d_pcm_DCAXY_Bg"), lPt, std::hypot(dcaInfo[0], dcaInfo[1]));
          registry.fill(HIST("h2d_pcm_DCACHI2_Bg"), lPt, fitter.getChi2AtPCACandidate());
          registry.fill(HIST("h2d_pcm_DeltaDistanceRadii_Bg"), lPt, centerDistance - trcCircle1.rC - trcCircle2.rC);
          registry.fill(HIST("h2d_pcm_PositionGuess_Bg"), lPt, delta2);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius1_Bg"), lPt, delta3_track1);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius2_Bg"), lPt, delta3_track2);
        }
      }
      // -------------------------------------------------------------------------------------
    } // end QA
    return true;
  }

  template <class TTrackTo, typename TV0Table>
  void buildStrangenessTables(TV0Table const& V0s)
  {
    // Loops over all V0s in the time frame
    for (auto& V0 : V0s) {
      // downscale some V0s if requested to do so
      if (downscaleFactor < 1.f && (static_cast<float>(rand_r(&randomSeed)) / static_cast<float>(RAND_MAX)) > downscaleFactor) {
        return;
      }

      // populates v0candidate struct declared inside strangenessbuilder
      bool validCandidate = buildV0Candidate<TTrackTo>(V0);

      if (!validCandidate) {
        continue; // doesn't pass selections
      }

      // V0 logic reminder
      // 0: v0 saved for the only due to the cascade, 1: standalone v0, 3: standard v0 with photon-only test

      if (V0.v0Type() > 0) {
        if (V0.v0Type() > 1 && !storePhotonCandidates)
          continue;
        // populates the various tables for analysis
        statisticsRegistry.v0stats[kCountStandardV0]++;
        v0indices(V0.posTrackId(), V0.negTrackId(),
                  V0.collisionId(), V0.globalIndex());
        v0trackXs(v0candidate.posTrackX, v0candidate.negTrackX);
        v0cores(v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2],
                v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2],
                v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2],
                v0candidate.dcaV0dau,
                v0candidate.posDCAxy,
                v0candidate.negDCAxy,
                v0candidate.cosPA,
                v0candidate.dcav0topv,
                V0.v0Type());
      } else {
        // place V0s built exclusively for the sake of cascades
        // in a fully independent table (though identical) to make
        // sure there's no accidental usage of those candidates
        // N.B.: these are obtained with *other selections* in
        //       the svertexer!
        statisticsRegistry.v0stats[kCountV0forCascade]++;
        v0fcindices(V0.posTrackId(), V0.negTrackId(),
                    V0.collisionId(), V0.globalIndex());
        v0fctrackXs(v0candidate.posTrackX, v0candidate.negTrackX);
        v0fccores(v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2],
                  v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2],
                  v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2],
                  v0candidate.dcaV0dau,
                  v0candidate.posDCAxy,
                  v0candidate.negDCAxy,
                  v0candidate.cosPA,
                  v0candidate.dcav0topv,
                  V0.v0Type());
      }

      // populate V0 covariance matrices if required by any other task
      if (createV0CovMats) {
        // Calculate position covariance matrix
        auto covVtxV = fitter.calcPCACovMatrix(0);
        // std::array<float, 6> positionCovariance;
        float positionCovariance[6];
        positionCovariance[0] = covVtxV(0, 0);
        positionCovariance[1] = covVtxV(1, 0);
        positionCovariance[2] = covVtxV(1, 1);
        positionCovariance[3] = covVtxV(2, 0);
        positionCovariance[4] = covVtxV(2, 1);
        positionCovariance[5] = covVtxV(2, 2);
        // store momentum covariance matrix
        std::array<float, 21> covTpositive = {0.};
        std::array<float, 21> covTnegative = {0.};
        // std::array<float, 6> momentumCovariance;
        float momentumCovariance[6];
        lPositiveTrack.getCovXYZPxPyPzGlo(covTpositive);
        lNegativeTrack.getCovXYZPxPyPzGlo(covTnegative);
        constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
        for (int i = 0; i < 6; i++) {
          momentumCovariance[i] = covTpositive[MomInd[i]] + covTnegative[MomInd[i]];
        }
        if (V0.v0Type() > 0) {
          if (V0.v0Type() > 1 && !storePhotonCandidates)
            continue;
          v0covs(positionCovariance, momentumCovariance);
        } else {
          v0fccovs(positionCovariance, momentumCovariance);
        }
      }
    }
    // En masse histo filling at end of process call
    fillHistos();
    resetHistos();
  }

  void processRun2(aod::Collisions const& collisions, soa::Filtered<TaggedV0s> const& V0s, FullTracksExt const&, aod::BCsWithTimestamps const&)
  {
    statisticsRegistry.eventCounter += collisions.size();
    // Fire up CCDB
    auto collision = collisions.begin();
    auto bc = collision.bc_as<aod::BCsWithTimestamps>();
    initCCDB(bc);
    buildStrangenessTables<FullTracksExt>(V0s);
  }
  PROCESS_SWITCH(lambdakzeroBuilder, processRun2, "Produce Run 2 V0 tables", false);

  void processRun3(aod::Collisions const& collisions, soa::Filtered<TaggedV0s> const& V0s, FullTracksExtIU const&, aod::BCsWithTimestamps const& bcs)
  {
    statisticsRegistry.eventCounter += collisions.size();
    // Fire up CCDB
    auto bc = collisions.size() ? collisions.begin().bc_as<aod::BCsWithTimestamps>() : bcs.begin();
    if (!bcs.size()) {
      LOGF(warn, "No BC found, skipping this DF.");
      return;
    }
    initCCDB(bc);
    buildStrangenessTables<FullTracksExtIU>(V0s);
  }
  PROCESS_SWITCH(lambdakzeroBuilder, processRun3, "Produce Run 3 V0 tables", true);
};

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct lambdakzeroPreselector {
  Produces<aod::V0Tags> v0tags; // MC tags

  // for bookkeeping
  HistogramRegistry histos{"Histos", {}, OutputObjHandlingPolicy::AnalysisObject};

  Configurable<bool> dIfMCgenerateK0Short{"dIfMCgenerateK0Short", true, "if MC, generate MC true K0Short (yes/no)"};
  Configurable<bool> dIfMCgenerateLambda{"dIfMCgenerateLambda", true, "if MC, generate MC true Lambda (yes/no)"};
  Configurable<bool> dIfMCgenerateAntiLambda{"dIfMCgenerateAntiLambda", true, "if MC, generate MC true AntiLambda (yes/no)"};
  Configurable<bool> dIfMCgenerateGamma{"dIfMCgenerateGamma", false, "if MC, generate MC true gamma (yes/no)"};
  Configurable<bool> dIfMCgenerateHypertriton{"dIfMCgenerateHypertriton", false, "if MC, generate MC true hypertritons (yes/no)"};
  Configurable<bool> dIfMCgenerateAntiHypertriton{"dIfMCgenerateAntiHypertriton", false, "if MC, generate MC true antihypertritons (yes/no)"};
  Configurable<int> dIfMCselectV0MotherPDG{"dIfMCselectV0MotherPDG", 0, "if MC, selects based on mother particle (zero for no selection)"};
  Configurable<bool> dIfMCselectPhysicalPrimary{"dIfMCselectPhysicalPrimary", true, "if MC, select MC physical primary (yes/no)"};

  Configurable<bool> ddEdxPreSelectK0Short{"ddEdxPreSelectK0Short", true, "pre-select dE/dx compatibility with K0Short (yes/no)"};
  Configurable<bool> ddEdxPreSelectLambda{"ddEdxPreSelectLambda", true, "pre-select dE/dx compatibility with Lambda (yes/no)"};
  Configurable<bool> ddEdxPreSelectAntiLambda{"ddEdxPreSelectAntiLambda", true, "pre-select dE/dx compatibility with AntiLambda (yes/no)"};
  Configurable<bool> ddEdxPreSelectGamma{"ddEdxPreSelectGamma", false, "pre-select dE/dx compatibility with gamma (yes/no)"};
  Configurable<bool> ddEdxPreSelectHypertriton{"ddEdxPreSelectHypertriton", false, "pre-select dE/dx compatibility with hypertritons (yes/no)"};
  Configurable<bool> ddEdxPreSelectAntiHypertriton{"ddEdxPreSelectAntiHypertriton", false, "pre-select dE/dx compatibility with antihypertritons (yes/no)"};

  // dEdx pre-selection compatibility
  Configurable<float> ddEdxPreSelectionWindow{"ddEdxPreSelectionWindow", 7, "Nsigma window for dE/dx preselection"};

  // tpc quality pre-selection
  Configurable<int> dTPCNCrossedRows{"dTPCNCrossedRows", 50, "Minimum TPC crossed rows"};

  // context-aware selections
  Configurable<bool> dPreselectOnlyBaryons{"dPreselectOnlyBaryons", false, "apply TPC dE/dx and quality only to baryon daughters"};

  // for bit-packed maps
  std::vector<uint16_t> selectionMask;
  enum v0bit { bitInteresting = 0,
               bitTrackQuality,
               bitTrueGamma,
               bitTrueK0Short,
               bitTrueLambda,
               bitTrueAntiLambda,
               bitTrueHypertriton,
               bitTrueAntiHypertriton,
               bitdEdxGamma,
               bitdEdxK0Short,
               bitdEdxLambda,
               bitdEdxAntiLambda,
               bitdEdxHypertriton,
               bitdEdxAntiHypertriton,
               bitUsedInCascade,
               bitUsedInTrackedCascade };

  void init(InitContext const&)
  {
    auto h = histos.add<TH1>("hPreselectorStatistics", "hPreselectorStatistics", kTH1D, {{6, -0.5f, 5.5f}});
    h->GetXaxis()->SetBinLabel(1, "All");
    h->GetXaxis()->SetBinLabel(2, "Tracks OK");
    h->GetXaxis()->SetBinLabel(3, "MC label OK");
    h->GetXaxis()->SetBinLabel(4, "dEdx OK");
    h->GetXaxis()->SetBinLabel(5, "Used in Casc");
    h->GetXaxis()->SetBinLabel(6, "Used in Tra-Casc");
  }

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check track quality
  template <class TTrackTo, typename TV0Object>
  void checkTrackQuality(TV0Object const& lV0Candidate, uint16_t& maskElement, bool passdEdx = false)
  {
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // No baryons in decay
    if (((bitcheck(maskElement, bitdEdxGamma) || bitcheck(maskElement, bitdEdxK0Short)) || passdEdx) && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows))
      bitset(maskElement, bitTrackQuality);
    // With baryons in decay
    if ((bitcheck(maskElement, bitdEdxLambda) || passdEdx) && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxAntiLambda) || passdEdx) && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxHypertriton) || passdEdx) && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxAntiHypertriton) || passdEdx) && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      bitset(maskElement, bitTrackQuality);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check PDG association
  template <class TTrackTo, typename TV0Object>
  void checkPDG(TV0Object const& lV0Candidate, uint16_t& maskElement)
  {
    int lPDG = -1;
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // Association check
    // There might be smarter ways of doing this in the future
    if (lNegTrack.has_mcParticle() && lPosTrack.has_mcParticle()) {
      auto lMCNegTrack = lNegTrack.template mcParticle_as<aod::McParticles>();
      auto lMCPosTrack = lPosTrack.template mcParticle_as<aod::McParticles>();
      if (lMCNegTrack.has_mothers() && lMCPosTrack.has_mothers()) {
        for (auto& lNegMother : lMCNegTrack.template mothers_as<aod::McParticles>()) {
          for (auto& lPosMother : lMCPosTrack.template mothers_as<aod::McParticles>()) {
            if (lNegMother.globalIndex() == lPosMother.globalIndex() && (!dIfMCselectPhysicalPrimary || lNegMother.isPhysicalPrimary())) {
              lPDG = lNegMother.pdgCode();

              // additionally check PDG of the mother particle if requested
              if (dIfMCselectV0MotherPDG != 0) {
                lPDG = 0; // this is not the species you're looking for
                if (lNegMother.has_mothers()) {
                  for (auto& lNegGrandMother : lNegMother.template mothers_as<aod::McParticles>()) {
                    if (lNegGrandMother.pdgCode() == dIfMCselectV0MotherPDG)
                      lPDG = lNegMother.pdgCode();
                  }
                }
              }
              // end extra PDG of mother check
            }
          }
        }
      }
    } // end association check
    if (lPDG == 310)
      bitset(maskElement, bitTrueK0Short);
    if (lPDG == 3122)
      bitset(maskElement, bitTrueLambda);
    if (lPDG == -3122)
      bitset(maskElement, bitTrueAntiLambda);
    if (lPDG == 22)
      bitset(maskElement, bitTrueGamma);
    if (lPDG == 1010010030)
      bitset(maskElement, bitTrueHypertriton);
    if (lPDG == -1010010030)
      bitset(maskElement, bitTrueAntiHypertriton);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  template <class TTrackTo, typename TV0Object>
  void checkdEdx(TV0Object const& lV0Candidate, uint16_t& maskElement)
  {
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // dEdx check with LF PID
    if (TMath::Abs(lNegTrack.tpcNSigmaEl()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaEl()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxGamma);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxK0Short);
    if ((TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons) &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxLambda);
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        (TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons))
      bitset(maskElement, bitdEdxAntiLambda);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        (TMath::Abs(lPosTrack.tpcNSigmaHe()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons))
      bitset(maskElement, bitdEdxHypertriton);
    if ((TMath::Abs(lNegTrack.tpcNSigmaHe()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons) &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxAntiHypertriton);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Initialization of mask vectors if uninitialized
  void initializeMasks(int size)
  {
    if (selectionMask.size() < 1) {
      // reserve // FIXME check speed / optimise
      selectionMask.resize(size, 0);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Clear mask vectors
  void resetMasks()
  {
    selectionMask.clear();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// checks and publishes tags if last
  void checkAndFinalize()
  {
    // parse + publish tag table now
    for (int ii = 0; ii < selectionMask.size(); ii++) {
      histos.fill(HIST("hPreselectorStatistics"), 0.0f); // all V0s
      bool validV0 = bitcheck(selectionMask[ii], bitTrackQuality);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 1.0f); // pass track quality
      }
      if (doprocessBuildMCAssociated || doprocessBuildValiddEdxMCAssociated)
        validV0 = validV0 && ((bitcheck(selectionMask[ii], bitTrueK0Short) && dIfMCgenerateK0Short) ||
                              (bitcheck(selectionMask[ii], bitTrueLambda) && dIfMCgenerateLambda) ||
                              (bitcheck(selectionMask[ii], bitTrueAntiLambda) && dIfMCgenerateAntiLambda) ||
                              (bitcheck(selectionMask[ii], bitTrueGamma) && dIfMCgenerateGamma) ||
                              (bitcheck(selectionMask[ii], bitTrueHypertriton) && dIfMCgenerateHypertriton) ||
                              (bitcheck(selectionMask[ii], bitTrueAntiHypertriton) && dIfMCgenerateAntiHypertriton));
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 2.0f); // pass MC
      }
      if (doprocessBuildValiddEdx || doprocessBuildValiddEdxMCAssociated)
        validV0 = validV0 && ((bitcheck(selectionMask[ii], bitdEdxK0Short) && ddEdxPreSelectK0Short) ||
                              (bitcheck(selectionMask[ii], bitdEdxLambda) && ddEdxPreSelectLambda) ||
                              (bitcheck(selectionMask[ii], bitdEdxAntiLambda) && ddEdxPreSelectAntiLambda) ||
                              (bitcheck(selectionMask[ii], bitdEdxGamma) && ddEdxPreSelectGamma) ||
                              (bitcheck(selectionMask[ii], bitdEdxHypertriton) && ddEdxPreSelectHypertriton) ||
                              (bitcheck(selectionMask[ii], bitdEdxAntiHypertriton) && ddEdxPreSelectAntiHypertriton));
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 3.0f); // pass dEdx
      }
      if (doprocessSkipV0sNotUsedInCascades)
        validV0 = validV0 && bitcheck(selectionMask[ii], bitUsedInCascade);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 4.0f); // pass used in casc
      }
      if (doprocessSkipV0sNotUsedInTrackedCascades)
        validV0 = validV0 && bitcheck(selectionMask[ii], bitUsedInTrackedCascade);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 5.0f); // pass used in tracasc
      }
      v0tags(validV0,
             bitcheck(selectionMask[ii], bitTrueGamma), bitcheck(selectionMask[ii], bitTrueK0Short), bitcheck(selectionMask[ii], bitTrueLambda),
             bitcheck(selectionMask[ii], bitTrueAntiLambda), bitcheck(selectionMask[ii], bitTrueHypertriton), bitcheck(selectionMask[ii], bitTrueAntiHypertriton),
             bitcheck(selectionMask[ii], bitdEdxGamma), bitcheck(selectionMask[ii], bitdEdxK0Short), bitcheck(selectionMask[ii], bitdEdxLambda),
             bitcheck(selectionMask[ii], bitdEdxAntiLambda), bitcheck(selectionMask[ii], bitdEdxHypertriton), bitcheck(selectionMask[ii], bitdEdxAntiHypertriton),
             bitcheck(selectionMask[ii], bitUsedInCascade), bitcheck(selectionMask[ii], bitUsedInTrackedCascade));
    }
    resetMasks();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all V0s are built. It will simply tag everything as true.
  void processBuildAll(aod::V0s const& v0table, aod::TracksExtra const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkTrackQuality<aod::TracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildMCAssociated(aod::Collisions const& collisions, aod::V0s const& v0table, LabeledTracksExtra const&, aod::McParticles const& particlesMC)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkPDG<LabeledTracksExtra>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<LabeledTracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdx(aod::Collisions const& collisions, aod::V0s const& v0table, TracksExtraWithPID const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkdEdx<TracksExtraWithPID>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<TracksExtraWithPID>(v0, selectionMask[v0.globalIndex()]);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdxMCAssociated(aod::Collisions const& collisions, aod::V0s const& v0table, TracksExtraWithPIDandLabels const&, aod::McParticles const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkPDG<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
      checkdEdx<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of V0s in cascades
  /// They are then marked appropriately; the user could then operate
  /// the lambdakzerobuilder to construct only those V0s.
  void processSkipV0sNotUsedInCascades(aod::Cascades const& casctable)
  {
    for (auto const& casc : casctable) {
      bitset(selectionMask[casc.v0Id()], bitUsedInCascade); // tag V0s needed by cascades
    }
    checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of V0s in strangeness tracked cascades
  /// They are then marked appropriately; the user could then operate
  /// the lambdakzerobuilder to construct only those V0s.
  void processSkipV0sNotUsedInTrackedCascades(aod::TrackedCascades const& tracasctable, aod::Cascades const& casctable)
  {
    for (auto const& tracasc : tracasctable) {
      auto casc = tracasc.cascade();
      bitset(selectionMask[casc.v0Id()], bitUsedInTrackedCascade); // tag V0s needed by tracked cascades
    }
    checkAndFinalize();
  }
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
  /// basic building options (one of them must be chosen)
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildAll, "Switch to build all V0s", true);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildMCAssociated, "Switch to build MC-associated V0s", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildValiddEdx, "Switch to build V0s with dE/dx preselection", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildValiddEdxMCAssociated, "Switch to build MC-associated V0s with dE/dx preselection", false);
  /// skippers options (choose one in addition to a processBuild if you like)
  PROCESS_SWITCH(lambdakzeroPreselector, processSkipV0sNotUsedInCascades, "skip all V0s not used in cascades", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processSkipV0sNotUsedInTrackedCascades, "skip all V0s not used in tracked cascades", false);
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
};

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct lambdakzeroV0DataLinkBuilder {
  Produces<aod::V0DataLink> v0dataLink;

  void init(InitContext const&) {}

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  // build V0 -> V0Data link table
  void process(aod::V0s const& v0table, aod::V0Datas const& v0datatable, aod::V0fCDatas const& v0fcdatatable)
  {
    std::vector<int> lIndices, lfCIndices;
    lIndices.reserve(v0table.size());
    lfCIndices.reserve(v0table.size());
    for (int ii = 0; ii < v0table.size(); ii++) {
      lIndices[ii] = -1;
      lfCIndices[ii] = -1;
    }
    for (auto& v0data : v0datatable) {
      lIndices[v0data.v0Id()] = v0data.globalIndex();
    }
    for (auto& v0fcdata : v0fcdatatable) {
      lfCIndices[v0fcdata.v0Id()] = v0fcdata.globalIndex();
    }
    for (int ii = 0; ii < v0table.size(); ii++) {
      v0dataLink(lIndices[ii], lfCIndices[ii]);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
};

// Extends the v0data table with expression columns
struct lambdakzeroInitializer {
  Spawns<aod::V0Cores> v0cores;
  Spawns<aod::V0fCCores> v0fccores;
  void init(InitContext const&) {}
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<lambdakzeroBuilder>(cfgc),
    adaptAnalysisTask<lambdakzeroPreselector>(cfgc),
    adaptAnalysisTask<lambdakzeroV0DataLinkBuilder>(cfgc),
    adaptAnalysisTask<lambdakzeroInitializer>(cfgc)};
}
