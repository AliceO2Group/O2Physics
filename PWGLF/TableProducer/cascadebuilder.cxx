// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//  Cascade builder task
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//
//  This task loops over a set of cascade indices and
//  creates the corresponding analysis tables that contain
//  the typical information required for analysis.
//
//  PERFORMANCE WARNING: this task includes several track
//  propagation calls that are intrinsically heavy. Please
//  also be cautious when adjusting selections: these can
//  increase / decrease CPU consumption quite significantly.
//
//  IDEAL USAGE: if you are interested in taking V0s and
//  cascades and propagating TrackParCovs based on these,
//  please do not re-propagate the daughters. Instead,
//  the tables generated by this builder task can be used
//  to instantiate a TrackPar object (default operation)
//  or even a TrackParCov object (for which you will
//  need to enable the option of producing the V0Cov and
//  CascCov tables too).
//
//    Comments, questions, complaints, suggestions?
//    Please write to:
//    david.dobrigkeit.chinellato@cern.ch
//

#include <cmath>
#include <array>
#include <cstdlib>
#include <map>
#include <iterator>
#include <utility>

#include "Framework/runDataProcessing.h"
#include "Framework/RunningWorkflowInfo.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Framework/ASoAHelpers.h"
#include "DCAFitter/DCAFitterN.h"
#include "ReconstructionDataFormats/Track.h"
#include "Common/Core/RecoDecay.h"
#include "Common/Core/trackUtilities.h"
#include "PWGLF/DataModel/LFStrangenessTables.h"
#include "PWGLF/DataModel/LFParticleIdentification.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"
#include "DetectorsBase/Propagator.h"
#include "DetectorsBase/GeometryManager.h"
#include "DataFormatsParameters/GRPObject.h"
#include "DataFormatsParameters/GRPMagField.h"
#include "CCDB/BasicCCDBManager.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;
using std::array;

// use parameters + cov mat non-propagated, aux info + (extension propagated)
using FullTracksExt = soa::Join<aod::Tracks, aod::TracksExtra, aod::TracksCov>;
using FullTracksExtIU = soa::Join<aod::TracksIU, aod::TracksExtra, aod::TracksCovIU>;
using TracksWithExtra = soa::Join<aod::Tracks, aod::TracksExtra>; // generally always need DCA, will have Tracks too

// For dE/dx association in pre-selection
using TracksExtraWithPID = soa::Join<aod::TracksExtra, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullKa>;

// For MC and dE/dx association
using TracksExtraWithPIDandLabels = soa::Join<aod::TracksExtra, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullKa, aod::McTrackLabels>;

// Pre-selected V0s
using V0full = soa::Join<aod::V0Datas, aod::V0Covs>;
using TaggedCascades = soa::Join<aod::Cascades, aod::CascTags>;

// For MC association in pre-selection
using LabeledTracksExtra = soa::Join<aod::TracksExtra, aod::McTrackLabels>;

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
// Builder task: rebuilds multi-strange candidates
struct cascadeBuilder {
  Produces<aod::StoredCascDatas> cascdata;
  Produces<aod::CascCovs> casccovs; // if requested by someone
  Service<o2::ccdb::BasicCCDBManager> ccdb;

  Configurable<bool> d_UseAutodetectMode{"d_UseAutodetectMode", false, "Autodetect requested topo sels"};

  // Configurables related to table creation
  Configurable<int> createCascCovMats{"createCascCovMats", -1, {"Produces V0 cov matrices. -1: auto, 0: don't, 1: yes. Default: auto (-1)"}};

  // Topological selection criteria
  Configurable<int> tpcrefit{"tpcrefit", 0, "demand TPC refit"};
  Configurable<float> dcabachtopv{"dcabachtopv", .05, "DCA Bach To PV"};
  Configurable<float> cascradius{"cascradius", 0.9, "cascradius"};
  Configurable<float> casccospa{"casccospa", 0.95, "casccospa"};
  Configurable<float> dcacascdau{"dcacascdau", 1.0, "DCA cascade Daughters"};
  Configurable<float> lambdaMassWindow{"lambdaMassWindow", .01, "Distance from Lambda mass"};

  // Operation and minimisation criteria
  Configurable<double> d_bz_input{"d_bz", -999, "bz field, -999 is automatic"};
  Configurable<bool> d_UseAbsDCA{"d_UseAbsDCA", true, "Use Abs DCAs"};
  Configurable<bool> d_UseWeightedPCA{"d_UseWeightedPCA", false, "Vertices use cov matrices"};
  Configurable<int> useMatCorrType{"useMatCorrType", 2, "0: none, 1: TGeo, 2: LUT"};
  Configurable<int> useMatCorrTypeCasc{"useMatCorrTypeCasc", 2, "0: none, 1: TGeo, 2: LUT"};
  Configurable<int> rejDiffCollTracks{"rejDiffCollTracks", 0, "rejDiffCollTracks"};
  Configurable<bool> d_doTrackQA{"d_doTrackQA", false, "do track QA"};

  // CCDB options
  Configurable<std::string> ccdburl{"ccdb-url", "http://alice-ccdb.cern.ch", "url of the ccdb repository"};
  Configurable<std::string> grpPath{"grpPath", "GLO/GRP/GRP", "Path of the grp file"};
  Configurable<std::string> grpmagPath{"grpmagPath", "GLO/Config/GRPMagField", "CCDB path of the GRPMagField object"};
  Configurable<std::string> lutPath{"lutPath", "GLO/Param/MatLUT", "Path of the Lut parametrization"};
  Configurable<std::string> geoPath{"geoPath", "GLO/Config/GeometryAligned", "Path of the geometry file"};

  // generate and fill extra QA histograms if requested
  Configurable<bool> d_doQA{"d_doQA", false, "Do basic QA"};
  Configurable<int> dQANBinsRadius{"dQANBinsRadius", 500, "Number of radius bins in QA histo"};
  Configurable<int> dQANBinsPtCoarse{"dQANBinsPtCoarse", 10, "Number of pT bins in QA histo"};
  Configurable<int> dQANBinsMass{"dQANBinsMass", 400, "Number of mass bins for QA histograms"};
  Configurable<float> dQAMaxPt{"dQAMaxPt", 5, "max pT in QA histo"};
  Configurable<float> dQAXiMassWindow{"dQAXiMassWindow", 0.005, "Xi mass window for ITS cluster map QA"};
  Configurable<float> dQAOmegaMassWindow{"dQAOmegaMassWindow", 0.005, "Omega mass window for ITS cluster map QA"};

  int mRunNumber;
  float d_bz;
  float maxSnp;  // max sine phi for propagation
  float maxStep; // max step size (cm) for propagation
  o2::base::MatLayerCylSet* lut = nullptr;
  o2::base::Propagator::MatCorrType matCorr;
  o2::base::Propagator::MatCorrType matCorrCascade;

  Filter taggedFilter = aod::casctag::isInteresting == true;

  // For manual sliceBy
  Preslice<aod::Cascades> perCollision = o2::aod::cascade::collisionId;

  // Define o2 fitter, 2-prong, active memory (no need to redefine per event)
  o2::vertexing::DCAFitterN<2> fitter;
  enum cascstep { kCascAll = 0,
                  kCascLambdaMass,
                  kBachTPCrefit,
                  kBachDCAxy,
                  kCascDCADau,
                  kCascCosPA,
                  kCascRadius,
                  kNCascSteps };

  // Helper struct to pass cascade information
  struct {
    int v0Id;
    int bachelorId;
    int charge;
    std::array<float, 3> pos;
    std::array<float, 3> bachP;
    float dcacascdau;
    float bachDCAxy;
    float cosPA;
    float cascradius;
    float cascDCAxy; // cascade DCA xy (with bending)
    std::array<float, 3> v0pos;
    std::array<float, 3> v0mompos;
    std::array<float, 3> v0momneg;
    float v0dcadau;
    float v0dcapostopv;
    float v0dcanegtopv;
  } cascadecandidate;

  o2::track::TrackParCov lBachelorTrack;
  o2::track::TrackParCov lV0Track;
  o2::track::TrackPar lCascadeTrack;

  // Helper struct to do bookkeeping of building parameters
  struct {
    std::array<long, kNCascSteps> cascstats;
    std::array<long, 10> posITSclu;
    std::array<long, 10> negITSclu;
    std::array<long, 10> bachITSclu;
    long exceptions;
    long eventCounter;
  } statisticsRegistry;

  HistogramRegistry registry{
    "registry",
    {{"hEventCounter", "hEventCounter", {HistType::kTH1F, {{1, 0.0f, 1.0f}}}},
     {"hCaughtExceptions", "hCaughtExceptions", {HistType::kTH1F, {{1, 0.0f, 1.0f}}}},
     {"hPositiveITSClusters", "hPositiveITSClusters", {HistType::kTH1F, {{10, -0.5f, 9.5f}}}},
     {"hNegativeITSClusters", "hNegativeITSClusters", {HistType::kTH1F, {{10, -0.5f, 9.5f}}}},
     {"hBachelorITSClusters", "hBachelorITSClusters", {HistType::kTH1F, {{10, -0.5f, 9.5f}}}},
     {"hCascadeCriteria", "hCascadeCriteria", {HistType::kTH1F, {{10, -0.5f, 9.5f}}}}}};

  void resetHistos()
  {
    statisticsRegistry.exceptions = 0;
    statisticsRegistry.eventCounter = 0;
    for (Int_t ii = 0; ii < kNCascSteps; ii++)
      statisticsRegistry.cascstats[ii] = 0;
    for (Int_t ii = 0; ii < 10; ii++) {
      statisticsRegistry.posITSclu[ii] = 0;
      statisticsRegistry.negITSclu[ii] = 0;
      statisticsRegistry.bachITSclu[ii] = 0;
    }
  }

  void fillHistos()
  {
    registry.fill(HIST("hEventCounter"), 0.0, statisticsRegistry.eventCounter);
    registry.fill(HIST("hCaughtExceptions"), 0.0, statisticsRegistry.exceptions);
    for (Int_t ii = 0; ii < kNCascSteps; ii++)
      registry.fill(HIST("hCascadeCriteria"), ii, statisticsRegistry.cascstats[ii]);
    if (d_doTrackQA) {
      for (Int_t ii = 0; ii < 10; ii++) {
        registry.fill(HIST("hPositiveITSClusters"), ii, statisticsRegistry.posITSclu[ii]);
        registry.fill(HIST("hNegativeITSClusters"), ii, statisticsRegistry.negITSclu[ii]);
        registry.fill(HIST("hBachelorITSClusters"), ii, statisticsRegistry.bachITSclu[ii]);
      }
    }
  }

  void init(InitContext& context)
  {
    resetHistos();

    // Optionally, add extra QA histograms to processing chain
    if (d_doQA) {
      // Basic histograms containing invariant masses of all built candidates
      const AxisSpec axisVsPtCoarse{(int)dQANBinsPtCoarse, 0, dQAMaxPt, "#it{p}_{T} (GeV/c)"};
      const AxisSpec axisXiMass{(int)dQANBinsMass, 1.222f, 1.422f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisOmegaMass{(int)dQANBinsMass, 1.572f, 1.772f, "Inv. Mass (GeV/c^{2})"};

      registry.add("h2dXiMinusMass", "h2dXiMinusMass", kTH2F, {axisVsPtCoarse, axisXiMass});
      registry.add("h2dXiPlusMass", "h2dXiPlusMass", kTH2F, {axisVsPtCoarse, axisXiMass});
      registry.add("h2dOmegaMinusMass", "h2dOmegaMinusMass", kTH2F, {axisVsPtCoarse, axisOmegaMass});
      registry.add("h2dOmegaPlusMass", "h2dOmegaPlusMass", kTH2F, {axisVsPtCoarse, axisOmegaMass});

      // bit packed ITS cluster map
      const AxisSpec axisITSCluMap{(int)128, -0.5f, +127.5f, "Packed ITS map"};
      const AxisSpec axisRadius{(int)dQANBinsRadius, 0.0f, +50.0f, "Radius (cm)"};

      // Histogram to bookkeep cluster maps
      registry.add("h2dITSCluMap_XiMinusPositive", "h2dITSCluMap_XiMinusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiMinusNegative", "h2dITSCluMap_XiMinusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiMinusBachelor", "h2dITSCluMap_XiMinusBachelor", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiPlusPositive", "h2dITSCluMap_XiPlusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiPlusNegative", "h2dITSCluMap_XiPlusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiPlusBachelor", "h2dITSCluMap_XiPlusBachelor", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaMinusPositive", "h2dITSCluMap_OmegaMinusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaMinusNegative", "h2dITSCluMap_OmegaMinusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaMinusBachelor", "h2dITSCluMap_OmegaMinusBachelor", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaPlusPositive", "h2dITSCluMap_OmegaPlusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaPlusNegative", "h2dITSCluMap_OmegaPlusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaPlusBachelor", "h2dITSCluMap_OmegaPlusBachelor", kTH2D, {axisITSCluMap, axisRadius});
    }

    mRunNumber = 0;
    d_bz = 0;
    maxSnp = 0.85f;  // could be changed later
    maxStep = 2.00f; // could be changed later

    ccdb->setURL(ccdburl);
    ccdb->setCaching(true);
    ccdb->setLocalObjectValidityChecking();
    ccdb->setFatalWhenNull(false);

    if (useMatCorrType == 1) {
      LOGF(info, "TGeo correction requested, loading geometry");
      if (!o2::base::GeometryManager::isGeometryLoaded()) {
        ccdb->get<TGeoManager>(geoPath);
      }
    }
    if (useMatCorrType == 2) {
      LOGF(info, "LUT correction requested, loading LUT");
      lut = o2::base::MatLayerCylSet::rectifyPtrFromFile(ccdb->get<o2::base::MatLayerCylSet>(lutPath));
    }

    if (doprocessRun2 == false && doprocessRun3 == false) {
      LOGF(fatal, "Neither processRun2 nor processRun3 enabled. Please choose one.");
    }
    if (doprocessRun2 == true && doprocessRun3 == true) {
      LOGF(fatal, "Cannot enable processRun2 and processRun3 at the same time. Please choose one.");
    }

    if (d_UseAutodetectMode) {
      // Checking for subscriptions to:
      double loosest_casccospa = 100;
      float loosest_dcacascdau = -100;
      float loosest_dcabachtopv = 100;
      float loosest_dcav0topv = 100;
      float loosest_radius = 100;
      float loosest_v0masswindow = -100;

      double detected_casccospa = 100;
      float detected_dcacascdau = -100;
      float detected_dcabachtopv = 100;
      float detected_dcav0topv = 100;
      float detected_radius = 100;
      float detected_v0masswindow = -100;

      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      LOGF(info, " Multi-strange builder self-configuration");
      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      auto& workflows = context.services().get<RunningWorkflowInfo const>();
      for (DeviceSpec const& device : workflows.devices) {
        // Step 1: check if this device subscribed to the V0data table
        for (auto const& input : device.inputs) {
          if (device.name.compare("cascade-initializer") == 0)
            continue; // don't listen to the initializer, it's just to extend stuff
          const std::string CascDataName = "CascData";
          const std::string CascDataExtName = "CascDataExt";
          if (input.matcher.binding == CascDataName || input.matcher.binding == CascDataExtName) {
            LOGF(info, "Device named %s has subscribed to CascData table! Will now scan for desired settings...", device.name);
            for (auto const& option : device.options) {

              // 5 V0 topological selections + 1 mass
              if (option.name.compare("cascadesetting_cospa") == 0) {
                detected_casccospa = option.defaultValue.get<double>();
                LOGF(info, "%s requested cascade cospa = %f", device.name, detected_casccospa);
                if (detected_casccospa < loosest_casccospa)
                  loosest_casccospa = detected_casccospa;
              }
              if (option.name.compare("cascadesetting_dcacascdau") == 0) {
                detected_dcacascdau = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA cascade daughters = %f", device.name, detected_dcacascdau);
                if (detected_dcacascdau > loosest_dcacascdau)
                  loosest_dcacascdau = detected_dcacascdau;
              }
              if (option.name.compare("cascadesetting_dcabachtopv") == 0) {
                detected_dcabachtopv = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA bachelor daughter = %f", device.name, detected_dcabachtopv);
                if (detected_dcabachtopv < loosest_dcabachtopv)
                  loosest_dcabachtopv = detected_dcabachtopv;
              }
              if (option.name.compare("cascadesetting_cascradius") == 0) {
                detected_radius = option.defaultValue.get<float>();
                LOGF(info, "%s requested  to PV = %f", device.name, detected_radius);
                if (detected_radius < loosest_radius)
                  loosest_radius = detected_radius;
              }
              if (option.name.compare("cascadesetting_mindcav0topv") == 0) {
                detected_dcav0topv = option.defaultValue.get<float>();
                LOGF(info, "%s requested minimum V0 DCA to PV = %f", device.name, detected_dcav0topv);
                if (detected_dcav0topv < loosest_dcav0topv)
                  loosest_dcav0topv = detected_dcav0topv;
              }
              if (option.name.compare("cascadesetting_v0masswindow") == 0) {
                detected_v0masswindow = option.defaultValue.get<float>();
                LOGF(info, "%s requested minimum V0 mass window (GeV/c^2) = %f", device.name, detected_v0masswindow);
                if (detected_v0masswindow > loosest_v0masswindow)
                  loosest_v0masswindow = detected_v0masswindow;
              }
            }
          }
          const std::string CascCovsName = "CascCovs";
          if (input.matcher.binding == CascCovsName) {
            LOGF(info, "Device named %s has subscribed to CascCovs table! Enabling.", device.name);
            createCascCovMats.value = 1;
          }
        }
      }

      LOGF(info, "Self-configuration finished! Decided on selections:");
      LOGF(info, " -+*> Cascade cospa ............: %.6f", loosest_casccospa);
      LOGF(info, " -+*> DCA cascade daughters ....: %.6f", loosest_dcacascdau);
      LOGF(info, " -+*> DCA bachelor daughter ....: %.6f", loosest_dcabachtopv);
      LOGF(info, " -+*> Min DCA V0 to PV .........: %.6f", loosest_dcav0topv);
      LOGF(info, " -+*> Min cascade decay radius .: %.6f", loosest_radius);
      LOGF(info, " -+*> V0 mass window ...........: %.6f", loosest_v0masswindow);

      casccospa.value = loosest_casccospa;
      dcacascdau.value = loosest_dcacascdau;
      dcabachtopv.value = loosest_dcabachtopv;
      // dcav0dau.value = loosest_dcav0topv;
      cascradius.value = loosest_radius;
      lambdaMassWindow.value = loosest_v0masswindow;
    }

    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
    LOGF(info, "Strangeness builder configuration:");
    if (doprocessRun2 == true) {
      LOGF(info, "Run 2 processing enabled. Will subscribe to Tracks table.");
    };
    if (doprocessRun3 == true) {
      LOGF(info, "Run 3 processing enabled. Will subscribe to TracksIU table.");
    };
    if (createCascCovMats > 0) {
      LOGF(info, "-> Will produce cascade cov mat table");
    };
    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*

    // initialize O2 2-prong fitter (only once)
    fitter.setPropagateToPCA(true);
    fitter.setMaxR(200.);
    fitter.setMinParamChange(1e-3);
    fitter.setMinRelChi2Change(0.9);
    fitter.setMaxDZIni(1e9);
    fitter.setMaxChi2(1e9);
    fitter.setUseAbsDCA(d_UseAbsDCA);
    fitter.setWeightedFinalPCA(d_UseWeightedPCA);

    // Material correction in the DCA fitter
    matCorr = o2::base::Propagator::MatCorrType::USEMatCorrNONE;
    if (useMatCorrType == 1)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrTGeo;
    if (useMatCorrType == 2)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrLUT;
    fitter.setMatCorrType(matCorr);

    matCorrCascade = o2::base::Propagator::MatCorrType::USEMatCorrNONE;
    if (useMatCorrTypeCasc == 1)
      matCorrCascade = o2::base::Propagator::MatCorrType::USEMatCorrTGeo;
    if (useMatCorrTypeCasc == 2)
      matCorrCascade = o2::base::Propagator::MatCorrType::USEMatCorrLUT;
  }

  void initCCDB(aod::BCsWithTimestamps::iterator const& bc)
  {
    if (mRunNumber == bc.runNumber()) {
      return;
    }

    // In case override, don't proceed, please - no CCDB access required
    if (d_bz_input > -990) {
      d_bz = d_bz_input;
      fitter.setBz(d_bz);
      o2::parameters::GRPMagField grpmag;
      if (fabs(d_bz) > 1e-5) {
        grpmag.setL3Current(30000.f / (d_bz / 5.0f));
      }
      o2::base::Propagator::initFieldFromGRP(&grpmag);
      mRunNumber = bc.runNumber();
      return;
    }

    auto run3grp_timestamp = bc.timestamp();
    o2::parameters::GRPObject* grpo = ccdb->getForTimeStamp<o2::parameters::GRPObject>(grpPath, run3grp_timestamp);
    o2::parameters::GRPMagField* grpmag = 0x0;
    if (grpo) {
      o2::base::Propagator::initFieldFromGRP(grpo);
      // Fetch magnetic field from ccdb for current collision
      d_bz = grpo->getNominalL3Field();
      LOG(info) << "Retrieved GRP for timestamp " << run3grp_timestamp << " with magnetic field of " << d_bz << " kZG";
    } else {
      grpmag = ccdb->getForTimeStamp<o2::parameters::GRPMagField>(grpmagPath, run3grp_timestamp);
      if (!grpmag) {
        LOG(fatal) << "Got nullptr from CCDB for path " << grpmagPath << " of object GRPMagField and " << grpPath << " of object GRPObject for timestamp " << run3grp_timestamp;
      }
      o2::base::Propagator::initFieldFromGRP(grpmag);
      // Fetch magnetic field from ccdb for current collision
      d_bz = std::lround(5.f * grpmag->getL3Current() / 30000.f);
      LOG(info) << "Retrieved GRP for timestamp " << run3grp_timestamp << " with magnetic field of " << d_bz << " kZG";
    }
    mRunNumber = bc.runNumber();
    // Set magnetic field value once known
    fitter.setBz(d_bz);

    if (useMatCorrType == 2) {
      // setMatLUT only after magfield has been initalized
      // (setMatLUT has implicit and problematic init field call if not)
      o2::base::Propagator::Instance()->setMatLUT(lut);
    }
  }

  template <class TTrackTo, typename TCascObject>
  bool buildCascadeCandidate(TCascObject const& cascade)
  {
    // Track casting
    auto bachTrack = cascade.template bachelor_as<TTrackTo>();
    auto v0index = cascade.template v0_as<o2::aod::V0sLinked>();
    if (!(v0index.has_v0Data())) {
      return false;
    }
    auto v0 = v0index.template v0Data_as<V0full>();
    auto posTrack = v0.template posTrack_as<TTrackTo>();
    auto negTrack = v0.template negTrack_as<TTrackTo>();
    auto const& collision = cascade.collision();

    // value 0.5: any considered cascade
    statisticsRegistry.cascstats[kCascAll]++;

    // Overall cascade charge
    cascadecandidate.charge = bachTrack.signed1Pt() > 0 ? +1 : -1;

    // check also against charge
    if (cascadecandidate.charge < 0 && TMath::Abs(v0.mLambda() - 1.116) > lambdaMassWindow)
      return false;
    if (cascadecandidate.charge > 0 && TMath::Abs(v0.mAntiLambda() - 1.116) > lambdaMassWindow)
      return false;
    statisticsRegistry.cascstats[kCascLambdaMass]++;

    if (tpcrefit) {
      if (!(bachTrack.trackType() & o2::aod::track::TPCrefit)) {
        return false;
      }
    }
    statisticsRegistry.cascstats[kBachTPCrefit]++;

    // bachelor DCA track to PV
    // Calculate DCA with respect to the collision associated to the V0, not individual tracks
    gpu::gpustd::array<float, 2> dcaInfo;

    auto bachTrackPar = getTrackPar(bachTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, bachTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    cascadecandidate.bachDCAxy = dcaInfo[0];

    if (TMath::Abs(cascadecandidate.bachDCAxy) < dcabachtopv)
      return false;
    statisticsRegistry.cascstats[kBachDCAxy]++;

    // Do actual minimization
    lBachelorTrack = getTrackParCov(bachTrack);

    // Set up covariance matrices (should in fact be optional)
    std::array<float, 21> covV = {0.};
    constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
    for (int i = 0; i < 6; i++) {
      covV[MomInd[i]] = v0.momentumCovMat()[i];
      covV[i] = v0.positionCovMat()[i];
    }
    lV0Track = o2::track::TrackParCov(
      {v0.x(), v0.y(), v0.z()},
      {v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()},
      covV, 0, true);
    lV0Track.setAbsCharge(0);
    lV0Track.setPID(o2::track::PID::Lambda);

    //---/---/---/
    // Move close to minima
    int nCand = 0;
    try {
      nCand = fitter.process(lV0Track, lBachelorTrack);
    } catch (...) {
      registry.fill(HIST("hCaughtExceptions"), 0.5f);
      LOG(error) << "Exception caught in DCA fitter process call!";
      return false;
    }
    if (nCand == 0)
      return false;

    lV0Track = fitter.getTrack(0);
    lBachelorTrack = fitter.getTrack(1);

    // DCA between cascade daughters
    cascadecandidate.dcacascdau = TMath::Sqrt(fitter.getChi2AtPCACandidate());
    if (cascadecandidate.dcacascdau > dcacascdau)
      return false;
    statisticsRegistry.cascstats[kCascDCADau]++;

    fitter.getTrack(1).getPxPyPzGlo(cascadecandidate.bachP);
    // get decay vertex coordinates
    const auto& vtx = fitter.getPCACandidate();
    for (int i = 0; i < 3; i++) {
      cascadecandidate.pos[i] = vtx[i];
    }

    cascadecandidate.cosPA = RecoDecay::cpa(
      array{collision.posX(), collision.posY(), collision.posZ()},
      array{cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2]},
      array{v0.pxpos() + v0.pxneg() + cascadecandidate.bachP[0], v0.pypos() + v0.pyneg() + cascadecandidate.bachP[1], v0.pzpos() + v0.pzneg() + cascadecandidate.bachP[2]});
    if (cascadecandidate.cosPA < casccospa) {
      return false;
    }
    statisticsRegistry.cascstats[kCascCosPA]++;

    // Cascade radius
    cascadecandidate.cascradius = RecoDecay::sqrtSumOfSquares(cascadecandidate.pos[0], cascadecandidate.pos[1]);
    if (cascadecandidate.cascradius < cascradius)
      return false;
    statisticsRegistry.cascstats[kCascRadius]++;

    // Calculate DCAxy of the cascade (with bending)
    lCascadeTrack = fitter.createParentTrackPar();
    lCascadeTrack.setAbsCharge(cascadecandidate.charge); // to be sure
    lCascadeTrack.setPID(o2::track::PID::XiMinus);       // FIXME: not OK for omegas
    dcaInfo[0] = 999;
    dcaInfo[1] = 999;

    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, lCascadeTrack, 2.f, matCorrCascade, &dcaInfo);
    cascadecandidate.cascDCAxy = dcaInfo[0];

    // Populate information
    cascadecandidate.v0Id = v0index.globalIndex();
    cascadecandidate.bachelorId = bachTrack.globalIndex();
    cascadecandidate.v0pos[0] = v0.x();
    cascadecandidate.v0pos[1] = v0.y();
    cascadecandidate.v0pos[2] = v0.z();
    cascadecandidate.v0mompos[0] = v0.pxpos();
    cascadecandidate.v0mompos[1] = v0.pypos();
    cascadecandidate.v0mompos[2] = v0.pzpos();
    cascadecandidate.v0momneg[0] = v0.pxneg();
    cascadecandidate.v0momneg[1] = v0.pyneg();
    cascadecandidate.v0momneg[2] = v0.pzneg();
    cascadecandidate.v0dcadau = v0.dcaV0daughters();
    cascadecandidate.v0dcapostopv = v0.dcapostopv();
    cascadecandidate.v0dcanegtopv = v0.dcanegtopv();

    if (d_doTrackQA) {
      if (posTrack.itsNCls() < 10)
        statisticsRegistry.posITSclu[posTrack.itsNCls()]++;
      if (negTrack.itsNCls() < 10)
        statisticsRegistry.negITSclu[negTrack.itsNCls()]++;
      if (bachTrack.itsNCls() < 10)
        statisticsRegistry.bachITSclu[bachTrack.itsNCls()]++;
    }

    if (d_doQA) {
      // Calculate masses
      auto lXiMass = RecoDecay::m(array{array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}, array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}}, array{o2::constants::physics::MassLambda, o2::constants::physics::MassPionCharged});
      auto lOmegaMass = RecoDecay::m(array{array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}, array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}}, array{o2::constants::physics::MassLambda, o2::constants::physics::MassKaonCharged});

      auto lPt = RecoDecay::sqrtSumOfSquares(v0.pxpos() + v0.pxneg() + cascadecandidate.bachP[0], v0.pypos() + v0.pyneg() + cascadecandidate.bachP[0]);

      // Fill basic mass histograms
      // Note: all presel bools are true if unchecked
      if (cascade.isXiMinusCandidate() && cascade.isTrueXiMinus())
        registry.fill(HIST("h2dXiMinusMass"), lPt, lXiMass);
      if (cascade.isXiPlusCandidate() && cascade.isTrueXiPlus())
        registry.fill(HIST("h2dXiPlusMass"), lPt, lXiMass);
      if (cascade.isOmegaMinusCandidate() && cascade.isTrueOmegaMinus())
        registry.fill(HIST("h2dOmegaMinusMass"), lPt, lOmegaMass);
      if (cascade.isOmegaPlusCandidate() && cascade.isTrueOmegaPlus())
        registry.fill(HIST("h2dOmegaPlusMass"), lPt, lOmegaMass);

      // Fill ITS cluster maps with specific mass cuts
      if (TMath::Abs(lXiMass - 1.322) < dQAXiMassWindow && cascade.isXiMinusCandidate() && cascade.isTrueXiMinus()) {
        registry.fill(HIST("h2dITSCluMap_XiMinusPositive"), (float)posTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiMinusNegative"), (float)negTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiMinusBachelor"), (float)bachTrack.itsClusterMap(), cascadecandidate.cascradius);
      }
      if (TMath::Abs(lXiMass - 1.322) < dQAXiMassWindow && cascade.isXiPlusCandidate() && cascade.isTrueXiPlus()) {
        registry.fill(HIST("h2dITSCluMap_XiPlusPositive"), (float)posTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiPlusNegative"), (float)negTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiPlusBachelor"), (float)bachTrack.itsClusterMap(), cascadecandidate.cascradius);
      }
      if (TMath::Abs(lXiMass - 1.672) < dQAOmegaMassWindow && cascade.isOmegaMinusCandidate() && cascade.isTrueOmegaMinus()) {
        registry.fill(HIST("h2dITSCluMap_OmegaMinusPositive"), (float)posTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaMinusNegative"), (float)negTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaMinusBachelor"), (float)bachTrack.itsClusterMap(), cascadecandidate.cascradius);
      }
      if (TMath::Abs(lXiMass - 1.672) < dQAOmegaMassWindow && cascade.isOmegaPlusCandidate() && cascade.isTrueOmegaPlus()) {
        registry.fill(HIST("h2dITSCluMap_OmegaPlusPositive"), (float)posTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaPlusNegative"), (float)negTrack.itsClusterMap(), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaPlusBachelor"), (float)bachTrack.itsClusterMap(), cascadecandidate.cascradius);
      }
    }

    return true;
  }

  template <class TTrackTo, typename TCascTable>
  void buildStrangenessTables(TCascTable const& cascades)
  {
    statisticsRegistry.eventCounter++;

    for (auto& cascade : cascades) {
      bool validCascadeCandidate = buildCascadeCandidate<TTrackTo>(cascade);
      if (!validCascadeCandidate)
        continue; // doesn't pass cascade selections

      cascdata(cascadecandidate.v0Id,
               cascade.globalIndex(),
               cascadecandidate.bachelorId,
               cascade.collisionId(),
               cascadecandidate.charge,
               cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2],
               cascadecandidate.v0pos[0], cascadecandidate.v0pos[1], cascadecandidate.v0pos[2],
               cascadecandidate.v0mompos[0], cascadecandidate.v0mompos[1], cascadecandidate.v0mompos[2],
               cascadecandidate.v0momneg[0], cascadecandidate.v0momneg[1], cascadecandidate.v0momneg[2],
               cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2],
               cascadecandidate.v0dcadau, cascadecandidate.dcacascdau,
               cascadecandidate.v0dcapostopv, cascadecandidate.v0dcanegtopv,
               cascadecandidate.bachDCAxy, cascadecandidate.cascDCAxy);

      // populate cascade covariance matrices if required by any other task
      if (createCascCovMats) {
        // Calculate position covariance matrix
        auto covVtxV = fitter.calcPCACovMatrix(0);
        // std::array<float, 6> positionCovariance;
        float positionCovariance[6];
        positionCovariance[0] = covVtxV(0, 0);
        positionCovariance[1] = covVtxV(1, 0);
        positionCovariance[2] = covVtxV(1, 1);
        positionCovariance[3] = covVtxV(2, 0);
        positionCovariance[4] = covVtxV(2, 1);
        positionCovariance[5] = covVtxV(2, 2);
        // store momentum covariance matrix
        std::array<float, 21> covTv0 = {0.};
        std::array<float, 21> covTbachelor = {0.};
        // std::array<float, 6> momentumCovariance;
        float momentumCovariance[6];
        lV0Track.getCovXYZPxPyPzGlo(covTv0);
        lBachelorTrack.getCovXYZPxPyPzGlo(covTbachelor);
        constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
        for (int i = 0; i < 6; i++) {
          momentumCovariance[i] = covTv0[MomInd[i]] + covTbachelor[MomInd[i]];
        }
        casccovs(positionCovariance, momentumCovariance);
      }
    }
    // En masse filling at end of process call
    fillHistos();
    resetHistos();
  }

  void processRun2(aod::Collisions const& collisions, aod::V0sLinked const&, V0full const&, soa::Filtered<TaggedCascades> const& cascades, FullTracksExt const&, aod::BCsWithTimestamps const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollision, collIdx);
      buildStrangenessTables<FullTracksExt>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processRun2, "Produce Run 2 cascade tables", true);

  void processRun3(aod::Collisions const& collisions, aod::V0sLinked const&, V0full const&, soa::Filtered<TaggedCascades> const& cascades, FullTracksExtIU const&, aod::BCsWithTimestamps const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollision, collIdx);
      buildStrangenessTables<FullTracksExtIU>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processRun3, "Produce Run 3 cascade tables", false);
};

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct cascadePreselector {
  Produces<aod::CascTags> casctags; // MC tags

  Configurable<bool> dIfMCgenerateXiMinus{"dIfMCgenerateXiMinus", true, "if MC, generate MC true XiMinus (yes/no)"};
  Configurable<bool> dIfMCgenerateXiPlus{"dIfMCgenerateXiPlus", true, "if MC, generate MC true XiPlus (yes/no)"};
  Configurable<bool> dIfMCgenerateOmegaMinus{"dIfMCgenerateOmegaMinus", true, "if MC, generate MC true OmegaMinus (yes/no)"};
  Configurable<bool> dIfMCgenerateOmegaPlus{"dIfMCgenerateOmegaPlus", true, "if MC, generate MC true OmegaPlus (yes/no)"};

  Configurable<bool> ddEdxPreSelectXiMinus{"ddEdxPreSelectXiMinus", true, "pre-select dE/dx compatibility with XiMinus (yes/no)"};
  Configurable<bool> ddEdxPreSelectXiPlus{"ddEdxPreSelectXiPlus", true, "pre-select dE/dx compatibility with XiPlus (yes/no)"};
  Configurable<bool> ddEdxPreSelectOmegaMinus{"ddEdxPreSelectOmegaMinus", true, "pre-select dE/dx compatibility with OmegaMinus (yes/no)"};
  Configurable<bool> ddEdxPreSelectOmegaPlus{"ddEdxPreSelectOmegaPlus", true, "pre-select dE/dx compatibility with OmegaPlus (yes/no)"};

  // dEdx pre-selection compatibility
  Configurable<float> ddEdxPreSelectionWindow{"ddEdxPreSelectionWindow", 7, "Nsigma window for dE/dx preselection"};

  // tpc quality pre-selection
  Configurable<int> dTPCNCrossedRows{"dTPCNCrossedRows", 50, "Minimum TPC crossed rows"};

  // context-aware selections
  Configurable<bool> dPreselectOnlyBaryons{"dPreselectOnlyBaryons", false, "apply TPC dE/dx and quality only to baryon daughters"};

  void init(InitContext const&) {}

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check track quality
  template <class TTrackTo, typename TCascadeObject>
  void checkTrackQuality(TCascadeObject const& lCascadeCandidate, bool& lIsInteresting, bool lIsXiMinus, bool lIsXiPlus, bool lIsOmegaMinus, bool lIsOmegaPlus)
  {
    lIsInteresting = false;
    auto v0 = lCascadeCandidate.template v0_as<o2::aod::V0sLinked>();
    if (!(v0.has_v0Data())) {
      lIsInteresting = false;
      return;
    }
    auto v0data = v0.v0Data(); // de-reference index to correct v0data in case it exists

    // Acquire all three daughter tracks, please
    auto lBachTrack = lCascadeCandidate.template bachelor_as<TTrackTo>();
    auto lNegTrack = v0data.template negTrack_as<TTrackTo>();
    auto lPosTrack = v0data.template posTrack_as<TTrackTo>();

    if ((lIsXiMinus || lIsOmegaMinus) && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons) && (lBachTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      lIsInteresting = true;
    if ((lIsXiPlus || lIsOmegaPlus) && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons) && (lBachTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      lIsInteresting = true;
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check PDG association
  template <class TTrackTo, typename TCascadeObject>
  void checkPDG(TCascadeObject const& lCascadeCandidate, bool& lIsInteresting, bool& lIsXiMinus, bool& lIsXiPlus, bool& lIsOmegaMinus, bool& lIsOmegaPlus)
  {
    auto v0 = lCascadeCandidate.template v0_as<o2::aod::V0sLinked>();
    if (!(v0.has_v0Data())) {
      lIsInteresting = false;
      lIsXiMinus = false;
      lIsXiPlus = false;
      lIsOmegaMinus = false;
      lIsOmegaPlus = false;
      return;
    }
    auto v0data = v0.v0Data(); // de-reference index to correct v0data in case it exists
    int lPDG = -1;

    // Acquire all three daughter tracks, please
    auto lBachTrack = lCascadeCandidate.template bachelor_as<TTrackTo>();
    auto lNegTrack = v0data.template negTrack_as<TTrackTo>();
    auto lPosTrack = v0data.template posTrack_as<TTrackTo>();

    // Association check
    // There might be smarter ways of doing this in the future
    if (lNegTrack.has_mcParticle() && lPosTrack.has_mcParticle() && lBachTrack.has_mcParticle()) {
      auto lMCBachTrack = lBachTrack.template mcParticle_as<aod::McParticles>();
      auto lMCNegTrack = lNegTrack.template mcParticle_as<aod::McParticles>();
      auto lMCPosTrack = lPosTrack.template mcParticle_as<aod::McParticles>();

      // Step 1: check if the mother is the same, go up a level
      if (lMCNegTrack.has_mothers() && lMCPosTrack.has_mothers()) {
        for (auto& lNegMother : lMCNegTrack.template mothers_as<aod::McParticles>()) {
          for (auto& lPosMother : lMCPosTrack.template mothers_as<aod::McParticles>()) {
            if (lNegMother == lPosMother) {
              // if we got to this level, it means the mother particle exists and is the same
              // now we have to go one level up and compare to the bachelor mother too
              for (auto& lV0Mother : lNegMother.template mothers_as<aod::McParticles>()) {
                for (auto& lBachMother : lMCBachTrack.template mothers_as<aod::McParticles>()) {
                  if (lV0Mother == lBachMother) {
                    lPDG = lV0Mother.pdgCode();
                  }
                }
              } // end conditional V0-bach pair
            }   // end neg = pos mother conditional
          }
        } // end loop neg/pos mothers
      }   // end conditional of mothers existing
    }     // end association check
    // Construct tag table (note: this will be joinable with CascDatas)
    if (lPDG == 3312 && dIfMCgenerateXiMinus) {
      lIsXiMinus = true;
      lIsInteresting = true;
    }
    if (lPDG == -3312 && dIfMCgenerateXiPlus) {
      lIsXiPlus = true;
      lIsInteresting = true;
    }
    if (lPDG == 3334 && dIfMCgenerateOmegaMinus) {
      lIsOmegaMinus = true;
      lIsInteresting = true;
    }
    if (lPDG == -3334 && dIfMCgenerateOmegaPlus) {
      lIsOmegaPlus = true;
      lIsInteresting = true;
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check early dE/dx selection
  template <class TTrackTo, typename TCascadeObject>
  void checkdEdx(TCascadeObject const& lCascadeCandidate, bool& lIsInteresting, bool& lIsXiMinus, bool& lIsXiPlus, bool& lIsOmegaMinus, bool& lIsOmegaPlus)
  {
    auto v0 = lCascadeCandidate.template v0_as<o2::aod::V0sLinked>();
    if (!(v0.has_v0Data())) {
      lIsInteresting = false;
      lIsXiMinus = false;
      lIsXiPlus = false;
      lIsOmegaMinus = false;
      lIsOmegaPlus = false;
      return;
    }
    auto v0data = v0.v0Data(); // de-reference index to correct v0data in case it exists

    // Acquire all three daughter tracks, please
    auto lBachTrack = lCascadeCandidate.template bachelor_as<TTrackTo>();
    auto lNegTrack = v0data.template negTrack_as<TTrackTo>();
    auto lPosTrack = v0data.template posTrack_as<TTrackTo>();

    // dEdx check with LF PID
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        ddEdxPreSelectXiMinus) {
      lIsXiMinus = 1;
      lIsInteresting = 1;
    }
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        ddEdxPreSelectXiPlus) {
      lIsXiPlus = 1;
      lIsInteresting = 1;
    }
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaKa()) < ddEdxPreSelectionWindow &&
        ddEdxPreSelectOmegaMinus) {
      lIsOmegaMinus = 1;
      lIsInteresting = 1;
    }
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaKa()) < ddEdxPreSelectionWindow &&
        ddEdxPreSelectOmegaPlus) {
      lIsOmegaPlus = 1;
      lIsInteresting = 1;
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all cascades are built. It will simply tag everything as true.
  void processBuildAll(aod::Cascades const& cascades, aod::V0sLinked const&, aod::V0Datas const&, aod::TracksExtra const&)
  {
    for (auto& casc : cascades) {
      bool lIsQualityInteresting = false;
      checkTrackQuality<aod::TracksExtra>(casc, lIsQualityInteresting, true, true, true, true);
      casctags(lIsQualityInteresting,
               true, true, true, true,
               true, true, true, true);
    }
  }
  PROCESS_SWITCH(cascadePreselector, processBuildAll, "Switch to build all cascades", true);
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildMCAssociated(aod::Collision const& collision, aod::Cascades const& cascades, aod::V0sLinked const&, aod::V0Datas const& v0table, LabeledTracksExtra const&, aod::McParticles const&)
  {
    for (auto& casc : cascades) {
      bool lIsInteresting = false;
      bool lIsQualityInteresting = false;
      bool lIsTrueXiMinus = false;
      bool lIsTrueXiPlus = false;
      bool lIsTrueOmegaMinus = false;
      bool lIsTrueOmegaPlus = false;

      checkPDG<LabeledTracksExtra>(casc, lIsInteresting, lIsTrueXiMinus, lIsTrueXiPlus, lIsTrueOmegaMinus, lIsTrueOmegaPlus);
      checkTrackQuality<LabeledTracksExtra>(casc, lIsQualityInteresting, true, true, true, true);
      casctags(lIsInteresting * lIsQualityInteresting,
               lIsTrueXiMinus, lIsTrueXiPlus, lIsTrueOmegaMinus, lIsTrueOmegaPlus,
               true, true, true, true);
    } // end cascades loop
  }
  PROCESS_SWITCH(cascadePreselector, processBuildMCAssociated, "Switch to build MC-associated cascades", false);
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdx(aod::Collision const& collision, aod::Cascades const& cascades, aod::V0sLinked const&, aod::V0Datas const&, TracksExtraWithPID const&)
  {
    for (auto& casc : cascades) {
      bool lIsInteresting = false;
      bool lIsQualityInteresting = false;
      bool lIsdEdxXiMinus = false;
      bool lIsdEdxXiPlus = false;
      bool lIsdEdxOmegaMinus = false;
      bool lIsdEdxOmegaPlus = false;

      checkdEdx<TracksExtraWithPID>(casc, lIsInteresting, lIsdEdxXiMinus, lIsdEdxXiPlus, lIsdEdxOmegaMinus, lIsdEdxOmegaPlus);
      checkTrackQuality<TracksExtraWithPID>(casc, lIsQualityInteresting, lIsdEdxXiMinus, lIsdEdxXiPlus, lIsdEdxOmegaMinus, lIsdEdxOmegaPlus);
      casctags(lIsInteresting * lIsQualityInteresting,
               true, true, true, true,
               lIsdEdxXiMinus, lIsdEdxXiPlus, lIsdEdxOmegaMinus, lIsdEdxOmegaPlus);
    }
  }
  PROCESS_SWITCH(cascadePreselector, processBuildValiddEdx, "Switch to build cascades with dE/dx preselection", false);
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdxMCAssociated(aod::Collision const& collision, aod::Cascades const& cascades, aod::V0sLinked const&, aod::V0Datas const&, TracksExtraWithPIDandLabels const&)
  {
    for (auto& casc : cascades) {
      bool lIsdEdxInteresting = false;
      bool lIsQualityInteresting = false;
      bool lIsdEdxXiMinus = false;
      bool lIsdEdxXiPlus = false;
      bool lIsdEdxOmegaMinus = false;
      bool lIsdEdxOmegaPlus = false;

      bool lIsTrueInteresting = false;
      bool lIsTrueXiMinus = false;
      bool lIsTrueXiPlus = false;
      bool lIsTrueOmegaMinus = false;
      bool lIsTrueOmegaPlus = false;

      checkPDG<TracksExtraWithPIDandLabels>(casc, lIsTrueInteresting, lIsTrueXiMinus, lIsTrueXiPlus, lIsTrueOmegaMinus, lIsTrueOmegaPlus);
      checkdEdx<TracksExtraWithPIDandLabels>(casc, lIsdEdxInteresting, lIsdEdxXiMinus, lIsdEdxXiPlus, lIsdEdxOmegaMinus, lIsdEdxOmegaPlus);
      checkTrackQuality<TracksExtraWithPIDandLabels>(casc, lIsQualityInteresting, lIsdEdxXiMinus, lIsdEdxXiPlus, lIsdEdxOmegaMinus, lIsdEdxOmegaPlus);
      casctags(lIsTrueInteresting * lIsdEdxInteresting * lIsQualityInteresting,
               lIsTrueXiMinus, lIsTrueXiPlus, lIsTrueOmegaMinus, lIsTrueOmegaPlus,
               lIsdEdxXiMinus, lIsdEdxXiPlus, lIsdEdxOmegaMinus, lIsdEdxOmegaPlus);
    }
  }
  PROCESS_SWITCH(cascadePreselector, processBuildValiddEdxMCAssociated, "Switch to build MC-associated cascades with dE/dx preselection", false);
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
};

/// Extends the cascdata table with expression columns
struct cascadeInitializer {
  Spawns<aod::CascData> cascdataext;
  void init(InitContext const&) {}
};

struct cascadeLinkBuilder {
  Produces<aod::CascDataLink> cascdataLink;

  void init(InitContext const&) {}

  // build Cascade -> CascData link table
  void process(aod::Cascades const& casctable, aod::CascDatas const& cascdatatable)
  {
    std::vector<int> lIndices;
    lIndices.reserve(casctable.size());
    for (int ii = 0; ii < casctable.size(); ii++)
      lIndices[ii] = -1;
    for (auto& cascdata : cascdatatable) {
      lIndices[cascdata.cascadeId()] = cascdata.globalIndex();
    }
    for (int ii = 0; ii < casctable.size(); ii++) {
      cascdataLink(lIndices[ii]);
    }
  }
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<cascadeBuilder>(cfgc),
    adaptAnalysisTask<cascadePreselector>(cfgc),
    adaptAnalysisTask<cascadeInitializer>(cfgc),
    adaptAnalysisTask<cascadeLinkBuilder>(cfgc)};
}
