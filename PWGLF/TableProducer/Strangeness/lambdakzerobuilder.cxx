// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//  Lambdakzero builder task
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//
//  This task loops over a set of V0 indices and
//  creates the corresponding analysis tables that contain
//  the typical information required for analysis.
//
//  PERFORMANCE WARNING: this task includes several track
//  propagation calls that are intrinsically heavy. Please
//  also be cautious when adjusting selections: these can
//  increase / decrease CPU consumption quite significantly.
//
//  IDEAL USAGE: if you are interested in taking V0s and
//  cascades and propagating TrackParCovs based on these,
//  please do not re-propagate the daughters. Instead,
//  the tables generated by this builder task can be used
//  to instantiate a TrackPar object (default operation)
//  or even a TrackParCov object (for which you will
//  need to enable the option of producing the V0Cov and
//  CascCov tables too).
//
//    Comments, questions, complaints, suggestions?
//    Please write to:
//    david.dobrigkeit.chinellato@cern.ch
//

#include <string>
#include <vector>
#include <cmath>
#include <array>
#include <cstdlib>
#include <map>
#include <iterator>
#include <utility>

#include "TRandom3.h"
#include "Framework/runDataProcessing.h"
#include "Framework/RunningWorkflowInfo.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Framework/ASoAHelpers.h"
#include "DCAFitter/DCAFitterN.h"
#include "ReconstructionDataFormats/Track.h"
#include "Common/Core/RecoDecay.h"
#include "Common/Core/trackUtilities.h"
#include "PWGLF/DataModel/LFStrangenessTables.h"
#include "PWGLF/DataModel/LFStrangenessMLTables.h"
#include "PWGLF/DataModel/LFParticleIdentification.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"
#include "DetectorsBase/Propagator.h"
#include "DetectorsBase/GeometryManager.h"
#include "DataFormatsParameters/GRPObject.h"
#include "DataFormatsParameters/GRPMagField.h"
#include "CCDB/BasicCCDBManager.h"
#include "DataFormatsCalibration/MeanVertexObject.h"
#include "TableHelper.h"
#include "Tools/ML/MlResponse.h"
#include "Tools/ML/model.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;
using std::array;

// simple checkers
#define bitset(var, nbit) ((var) |= (1 << (nbit)))
#define bitcheck(var, nbit) ((var) & (1 << (nbit)))

// use parameters + cov mat non-propagated, aux info + (extension propagated)
using FullTracksExt = soa::Join<aod::Tracks, aod::TracksExtra, aod::TracksCov>;
using FullTracksExtIU = soa::Join<aod::TracksIU, aod::TracksExtra, aod::TracksCovIU>;
using TracksWithExtra = soa::Join<aod::Tracks, aod::TracksExtra>;

// For dE/dx association in pre-selection
using TracksExtraWithPID = soa::Join<aod::TracksExtra, aod::pidTPCFullEl, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullHe>;

// For MC and dE/dx association
using TracksExtraWithPIDandLabels = soa::Join<aod::TracksExtra, aod::pidTPCFullEl, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullHe, aod::McTrackLabels>;

// Pre-selected V0s
using TaggedV0s = soa::Join<aod::V0s, aod::V0Tags>;
using TaggedFindableV0s = soa::Join<aod::FindableV0s, aod::V0Tags>;

// For MC association in pre-selection
using LabeledTracksExtra = soa::Join<aod::TracksExtra, aod::McTrackLabels>;

struct lambdakzeroBuilder {
  o2::ml::OnnxModel mlModelK0Short;
  o2::ml::OnnxModel mlModelLambda;
  o2::ml::OnnxModel mlModelAntiLambda;
  o2::ml::OnnxModel mlModelGamma;

  std::map<std::string, std::string> metadata;

  Produces<aod::V0Indices> v0indices;
  Produces<aod::V0CoresBase> v0cores;
  Produces<aod::V0TrackXs> v0trackXs;
  Produces<aod::V0Covs> v0covs;                  // covariances
  Produces<aod::V0DauCovs> v0daucovs;            // covariances of daughter tracks
  Produces<aod::V0DauCovIUs> v0daucovIUs;        // covariances of daughter tracks
  Produces<aod::V0TraPosAtDCAs> v0dauPositions;  // auxiliary debug information
  Produces<aod::V0TraPosAtIUs> v0dauPositionsIU; // auxiliary debug information
  Produces<aod::V0Ivanovs> v0ivanovs;

  Produces<aod::V0fCIndices> v0fcindices;
  Produces<aod::StoredV0fCCores> v0fccores;
  Produces<aod::V0fCTrackXs> v0fctrackXs;
  Produces<aod::V0fCCovs> v0fccovs;

  // produces calls for machine-learning selections
  Produces<aod::V0GammaMLScores> gammaMLSelections;           // gamma scores
  Produces<aod::V0LambdaMLScores> lambdaMLSelections;         // lambda scores
  Produces<aod::V0AntiLambdaMLScores> antiLambdaMLSelections; // AntiLambda scores
  Produces<aod::V0K0ShortMLScores> k0ShortMLSelections;       // K0Short scores

  o2::ccdb::CcdbApi ccdbApi;
  Service<o2::ccdb::BasicCCDBManager> ccdb;

  // Configurables related to table creation
  Configurable<int> createV0CovMats{"createV0CovMats", -1, {"Produces V0 cov matrices. -1: auto, 0: don't, 1: yes. Default: auto (-1)"}};
  Configurable<int> createV0DauCovMats{"createV0DauCovMats", -1, {"Produces V0 cov matrices for daughter tracks. -1: auto, 0: don't, 1: yes. Default: auto (-1)"}};
  Configurable<int> createV0PosAtDCAs{"createV0PosAtDCAs", 0, {"Produces V0 track positions at minima. 0: don't, 1: yes. Default: no (0)"}};
  Configurable<int> createV0PosAtIUs{"createV0PosAtIUs", 0, {"Produces V0 track positions at IU. 0: don't, 1: yes. Default: no (0)"}};

  Configurable<bool> storePhotonCandidates{"storePhotonCandidates", false, "store photon candidates (yes/no)"};

  // use auto-detect configuration
  Configurable<bool> d_UseAutodetectMode{"d_UseAutodetectMode", false, "Autodetect requested topo sels"};

  // downscaling for testing
  unsigned int randomSeed = 0;

  TRandom3 prng;
  // downscaling for Marian Ivanov -> different strategies
  struct : ConfigurableGroup {
    Configurable<float> downscaleFactor{"downscalingOptions.downscaleFactor", 2, "Downscale factor (0: build nothing, 1: build all)"};
    Configurable<bool> downscale_adaptive{"downscalingOptions.downscale_adaptive", false, "Downscale: use pT-dependent techniques"};
    Configurable<float> downscale_mass{"downscalingOptions.downscale_mass", .139, "Downscale: Tsallis Mass"};
    Configurable<float> downscale_sqrts{"downscalingOptions.downscale_sqrts", 13.6, "Downscale: Tsallis sqrts"};
    Configurable<float> downscale_factorPt{"downscalingOptions.downscale_factorPt", 1.0, "Downscale: factor Pt"};
    Configurable<float> downscale_factor1Pt{"downscalingOptions.downscale_factor1Pt", 1.0, "Downscale: factor 1/Pt"};
    Configurable<float> downscale_factorUniform{"downscalingOptions.downscale_factorUniform", 1e-3, "Downscale: factor Pt"};
    Configurable<int> downscale_triggerMaskSelection{"downscalingOptions.downscale_triggerMaskSelection", 0, "Downscale: trigger mask selection"};
  } downscalingOptions;

  Configurable<float> dcanegtopv{"dcanegtopv", .1, "DCA Neg To PV"};
  Configurable<float> dcapostopv{"dcapostopv", .1, "DCA Pos To PV"};
  Configurable<double> v0cospa{"v0cospa", 0.995, "V0 CosPA"}; // double -> N.B. dcos(x)/dx = 0 at x=0)
  Configurable<float> dcav0dau{"dcav0dau", 1.0, "DCA V0 Daughters"};
  Configurable<float> v0radius{"v0radius", 0.9, "v0radius"};

  Configurable<int> tpcrefit{"tpcrefit", 0, "demand TPC refit"};

  // select momentum slice if desired
  Configurable<float> minimumPt{"minimumPt", 0.0f, "Minimum pT to store candidate"};
  Configurable<float> maximumPt{"maximumPt", 1000.0f, "Maximum pT to store candidate"};
  Configurable<float> maxDaughterEta{"maxDaughterEta", 5.0, "Maximum daughter eta"};

  // Machine learning evaluation for pre-selection and corresponding information generation
  struct : ConfigurableGroup {
    // ML classifiers: master flags to populate ML Selection tables
    Configurable<bool> calculateK0ShortScores{"mlConfigurations.calculateK0ShortScores", false, "calculate K0Short ML scores"};
    Configurable<bool> calculateLambdaScores{"mlConfigurations.calculateLambdaScores", false, "calculate Lambda ML scores"};
    Configurable<bool> calculateAntiLambdaScores{"mlConfigurations.calculateAntiLambdaScores", false, "calculate AntiLambda ML scores"};
    Configurable<bool> calculateGammaScores{"mlConfigurations.calculateGammaScores", false, "calculate Gamma ML scores"};

    // ML input for ML calculation
    Configurable<std::string> modelPathCCDB{"mlConfigurations.modelPathCCDB", "", "ML Model path in CCDB"};
    Configurable<int64_t> timestampCCDB{"mlConfigurations.timestampCCDB", -1, "timestamp of the ONNX file for ML model used to query in CCDB.  Exceptions: > 0 for the specific timestamp, 0 gets the run dependent timestamp"};
    Configurable<bool> loadModelsFromCCDB{"mlConfigurations.loadModelsFromCCDB", false, "Flag to enable or disable the loading of models from CCDB"};
    Configurable<bool> enableOptimizations{"mlConfigurations.enableOptimizations", false, "Enables the ONNX extended model-optimization: sessionOptions.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_EXTENDED)"};

    // Local paths for test purposes
    Configurable<std::string> localModelPathLambda{"mlConfigurations.localModelPathLambda", "Lambda_BDTModel.onnx", "(std::string) Path to the local .onnx file."};
    Configurable<std::string> localModelPathAntiLambda{"mlConfigurations.localModelPathAntiLambda", "AntiLambda_BDTModel.onnx", "(std::string) Path to the local .onnx file."};
    Configurable<std::string> localModelPathGamma{"mlConfigurations.localModelPathGamma", "Gamma_BDTModel.onnx", "(std::string) Path to the local .onnx file."};
    Configurable<std::string> localModelPathK0Short{"mlConfigurations.localModelPathK0Short", "KZeroShort_BDTModel.onnx", "(std::string) Path to the local .onnx file."};

    // Thresholds for choosing to populate V0Cores tables with pre-selections
    Configurable<float> thresholdGamma{"mlConfigurations.thresholdGamma", -1.0f, "Threshold to keep gamma candidates"};
    Configurable<float> thresholdLambda{"mlConfigurations.thresholdLambda", -1.0f, "Threshold to keep Lambda candidates"};
    Configurable<float> thresholdAntiLambda{"mlConfigurations.thresholdAntiLambda", -1.0f, "Threshold to keep AntiLambda candidates"};
    Configurable<float> thresholdK0Short{"mlConfigurations.thresholdK0Short", -1.0f, "Threshold to keep K0Short candidates"};
  } mlConfigurations;

  // Operation and minimisation criteria
  struct : ConfigurableGroup {
    Configurable<double> d_bz_input{"dcaFitterConfigurations.d_bz", -999, "bz field, -999 is automatic"};
    Configurable<bool> d_UseAbsDCA{"dcaFitterConfigurations.d_UseAbsDCA", true, "Use Abs DCAs"};
    Configurable<bool> d_UseWeightedPCA{"dcaFitterConfigurations.d_UseWeightedPCA", false, "Vertices use cov matrices"};
    Configurable<bool> d_UseCollinearFit{"dcaFitterConfigurations.d_UseCollinearFit", false, "Fit V0s via the collinear Method in DCAFitter"};
    Configurable<float> d_maxDZIni{"dcaFitterConfigurations.d_maxDZIni", 1e9, "Dont consider a seed (circles intersection) if Z distance exceeds this"};
    Configurable<float> d_maxDXYIni{"dcaFitterConfigurations.d_maxDXYIni", 4, "Dont consider a seed (circles intersection) if XY distance exceeds this"};
    Configurable<int> useMatCorrType{"dcaFitterConfigurations.useMatCorrType", 2, "0: none, 1: TGeo, 2: LUT"};
    Configurable<int> rejDiffCollTracks{"dcaFitterConfigurations.rejDiffCollTracks", 0, "rejDiffCollTracks"};
  } dcaFitterConfigurations;

  // CCDB options
  struct : ConfigurableGroup {
    Configurable<std::string> ccdburl{"ccdbConfigurations.ccdb-url", "http://alice-ccdb.cern.ch", "url of the ccdb repository"};
    Configurable<std::string> grpPath{"ccdbConfigurations.grpPath", "GLO/GRP/GRP", "Path of the grp file"};
    Configurable<std::string> grpmagPath{"ccdbConfigurations.grpmagPath", "GLO/Config/GRPMagField", "CCDB path of the GRPMagField object"};
    Configurable<std::string> lutPath{"ccdbConfigurations.lutPath", "GLO/Param/MatLUT", "Path of the Lut parametrization"};
    Configurable<std::string> geoPath{"ccdbConfigurations.geoPath", "GLO/Config/GeometryAligned", "Path of the geometry file"};
    Configurable<std::string> mVtxPath{"ccdbConfigurations.mVtxPath", "GLO/Calib/MeanVertex", "Path of the mean vertex file"};
  } ccdbConfigurations;

  // round some V0 core variables up to a certain level of precision if requested
  // useful to keep derived data sizes under control
  // variables that are rounded include the DCAs but not the CosPA (precision needed)
  Configurable<bool> roundDCAVariables{"roundDCAVariables", false, "round topological variables"};
  Configurable<float> precisionDCAs{"precisionDCAs", 0.01f, "precision to keep the DCAs with"};

  // generate and fill extra QA histograms if requested
  struct : ConfigurableGroup {
    Configurable<bool> d_doQA{"qaConfigurations.d_doQA", false, "Do basic QA"};
    Configurable<int> dQANBinsRadius{"qaConfigurations.dQANBinsRadius", 500, "Number of radius bins in QA histo"};
    Configurable<int> dQANBinsPtCoarse{"qaConfigurations.dQANBinsPtCoarse", 10, "Number of pT bins in QA histo"};
    Configurable<int> dQANBinsMass{"qaConfigurations.dQANBinsMass", 400, "Number of mass bins for QA histograms"};
    Configurable<float> dQAMaxPt{"qaConfigurations.dQAMaxPt", 5, "max pT in QA histo"};
    Configurable<float> dQAGammaMassWindow{"qaConfigurations.dQAGammaMassWindow", 0.05, "gamma mass window for ITS cluster map QA"};
    Configurable<float> dQAK0ShortMassWindow{"qaConfigurations.dQAK0ShortMassWindow", 0.005, "K0 mass window for ITS cluster map QA"};
    Configurable<float> dQALambdaMassWindow{"qaConfigurations.dQALambdaMassWindow", 0.005, "Lambda/AntiLambda mass window for ITS cluster map QA"};
    Configurable<bool> d_doTrackQA{"qaConfigurations.d_doTrackQA", false, "do track QA"};
    Configurable<bool> d_QA_checkMC{"qaConfigurations.d_QA_checkMC", true, "check MC truth in QA"};
    Configurable<bool> d_QA_checkdEdx{"qaConfigurations.d_QA_checkdEdx", false, "check dEdx in QA"};
  } qaConfigurations;

  // for topo var QA
  struct : ConfigurableGroup {
    ConfigurableAxis axisTopoVarPointingAngle{"axisConfigurations.axisTopoVarPointingAngle", {50, 0.0, 1.0}, "pointing angle"};
    ConfigurableAxis axisTopoVarRAP{"axisConfigurations.axisTopoVarRAP", {50, 0.0, 1.0}, "radius x pointing angle axis"};
    ConfigurableAxis axisTopoVarV0Radius{"axisConfigurations.axisTopoVarV0Radius", {500, 0.0, 100.0}, "V0 decay radius (cm)"};
    ConfigurableAxis axisTopoVarDCAV0Dau{"axisConfigurations.axisTopoVarDCAV0Dau", {200, 0.0, 2.0}, "DCA between V0 daughters (cm)"};
    ConfigurableAxis axisTopoVarDCAToPV{"axisConfigurations.axisTopoVarDCAToPV", {200, -1, 1.0}, "single track DCA to PV (cm)"};
    ConfigurableAxis axisTopoVarDCAV0ToPV{"axisConfigurations.axisTopoVarDCAV0ToPV", {200, 0, 5.0}, "V0 DCA to PV (cm)"};

    ConfigurableAxis axisX{"axisConfigurations.axisX", {200, 0, 200}, "X_{IU}"};
    ConfigurableAxis axisRadius{"axisConfigurations.axisRadius", {500, 0, 50}, "Radius (cm)"};
    ConfigurableAxis axisDeltaDistanceRadii{"axisConfigurations.axisDeltaDistanceRadii", {500, -50, 50}, "(cm)"};
    ConfigurableAxis axisDCAXY{"axisConfigurations.axisDCAXY", {500, -50, 50}, "(cm)"};
    ConfigurableAxis axisDCACHI2{"axisConfigurations.axisDCACHI2", {500, 0, 50}, "#chi^{2}"};
    ConfigurableAxis axisPositionGuess{"axisConfigurations.axisPositionGuess", {240, 0, 120}, "(cm)"};

    ConfigurableAxis axisPtQA{"axisConfigurations.axisPtQA", {VARIABLE_WIDTH, 0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f, 0.8f, 0.9f, 1.0f, 1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f, 1.8f, 1.9f, 2.0f, 2.2f, 2.4f, 2.6f, 2.8f, 3.0f, 3.2f, 3.4f, 3.6f, 3.8f, 4.0f, 4.4f, 4.8f, 5.2f, 5.6f, 6.0f, 6.5f, 7.0f, 7.5f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 17.0f, 19.0f, 21.0f, 23.0f, 25.0f, 30.0f, 35.0f, 40.0f, 50.0f}, "pt axis for QA histograms"};
  } axisConfigurations;

  // default parameters from central Pb-Pb (worst case scenario), PbPb 2023 pass1
  // fuctional form: [0]+[1]*x+[2]*TMath::Exp(-x/[3])

  static constexpr float defaultK0MassWindowParameters[1][4] = {{2.81882e-03, 1.14057e-03, 1.72138e-03, 5.00262e-01}};
  static constexpr float defaultLambdaWindowParameters[1][4] = {{1.17518e-03, 1.24099e-04, 5.47937e-03, 3.08009e-01}};
  Configurable<LabeledArray<float>> massCutK0{"massCutK0", {defaultK0MassWindowParameters[0], 4, {"constant", "linear", "expoConstant", "expoRelax"}}, "mass parameters for K0"};
  Configurable<LabeledArray<float>> massCutLambda{"massCutLambda", {defaultLambdaWindowParameters[0], 4, {"constant", "linear", "expoConstant", "expoRelax"}}, "mass parameters for Lambda"};
  Configurable<float> massCutPhoton{"massCutPhoton", 0.2, "Photon max mass"};
  Configurable<float> massWindownumberOfSigmas{"massWindownumberOfSigmas", 5e+6, "number of sigmas around mass peaks to keep"};
  Configurable<bool> massWindowWithTPCPID{"massWindowWithTPCPID", false, "when checking mass windows, correlate with TPC dE/dx"};
  Configurable<float> massWindowSafetyMargin{"massWindowSafetyMargin", 0.001, "Extra mass window safety margin"};

  // apply lifetime cuts to K0Short and Lambda candidates
  // unit of measurement: centimeters
  // lifetime of Lambda ~7.9cm but keep in mind feeddown from cascades
  // lifetime of K0Short ~2.5cm, no feeddown and plenty to cut
  static constexpr float defaultLifetimeCuts[1][2] = {{1e+6, 1e+6}};
  Configurable<LabeledArray<float>> lifetimecut{"lifetimecut", {defaultLifetimeCuts[0], 2, {"lifetimecutLambda", "lifetimecutK0S"}}, "lifetimecut"};

  int mRunNumber;
  float d_bz;
  float maxSnp;  // max sine phi for propagation
  float maxStep; // max step size (cm) for propagation
  o2::base::MatLayerCylSet* lut = nullptr;
  o2::dataformats::MeanVertexObject* mVtx = nullptr;

  // Define o2 fitter, 2-prong, active memory (no need to redefine per event)
  o2::vertexing::DCAFitterN<2> fitter;

  // provision to repeat mass selections while doing AND with PID selections
  // fixme : this could be done more uniformly svertexer with reconstruction
  //         but that requires decoupling the mass window selections in O2
  //         - to be done at a later stage

  float getMassSigmaK0Short(float pt)
  {
    return massCutK0->get("constant") + pt * massCutK0->get("linear") + massCutK0->get("expoConstant") * TMath::Exp(-pt / massCutK0->get("expoRelax"));
  }
  float getMassSigmaLambda(float pt)
  {
    return massCutLambda->get("constant") + pt * massCutLambda->get("linear") + massCutLambda->get("expoConstant") * TMath::Exp(-pt / massCutLambda->get("expoRelax"));
  }

  Filter taggedFilter = aod::v0tag::isInteresting == true;

  // For manual sliceBy
  Preslice<aod::V0s> perCollision = o2::aod::v0::collisionId;

  enum v0step { kV0All = 0,
                kV0TPCrefit,
                kV0DCAxy,
                kV0DCADau,
                kV0CosPA,
                kV0Radius,
                kWithinMomentumRange,
                kCountStandardV0,
                kCountV0forCascade,
                kNV0Steps };

  // Helper struct to pass V0 information
  struct {
    float posTrackX;
    float negTrackX;
    std::array<float, 3> pos;
    std::array<float, 3> posP;
    std::array<float, 3> negP;
    std::array<float, 3> posPosition;
    std::array<float, 3> negPosition;
    float dcaV0dau;
    float posDCAxy;
    float negDCAxy;
    float cosPA;
    float dcav0topv;
    float V0radius;
    float k0ShortMass;
    float lambdaMass;
    float antiLambdaMass;
  } v0candidate;

  // Helper struct to do bookkeeping of building parameters
  struct {
    std::array<int32_t, kNV0Steps> v0stats;
    std::array<int32_t, kNV0Steps> v0statsUnassociated;
    std::array<int32_t, 10> posITSclu;
    std::array<int32_t, 10> negITSclu;
    int32_t exceptions;
    int32_t eventCounter;
  } statisticsRegistry;

  HistogramRegistry registry{
    "registry",
    {{"hEventCounter", "hEventCounter", {HistType::kTH1D, {{1, 0.0f, 1.0f}}}},
     {"hCaughtExceptions", "hCaughtExceptions", {HistType::kTH1D, {{1, 0.0f, 1.0f}}}},
     {"hPositiveITSClusters", "hPositiveITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}},
     {"hNegativeITSClusters", "hNegativeITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}}}};

  // +-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+
  // tools for downsampling (Marian)
  float TsallisCharged(float pt)
  {
    const float a = 6.81, b = 59.24;
    const float c = 0.082, d = 0.151;
    float mt = TMath::Sqrt(downscalingOptions.downscale_mass * downscalingOptions.downscale_mass + pt * pt);
    float n = a + b / downscalingOptions.downscale_sqrts;
    float T = c + d / downscalingOptions.downscale_sqrts;
    float p0 = n * T;
    float result = TMath::Power((1. + mt / p0), -n);
    result *= pt;
    return result;
  }

  int DownsampleMap(float pt)
  {
    float prob = TsallisCharged(pt);
    float probNorm = TsallisCharged(1.);
    int triggerMask = 0;
    if (prng.Rndm() * prob / probNorm < downscalingOptions.downscale_factorPt)
      triggerMask |= 1;
    if ((prng.Rndm() * ((prob / probNorm) * pt * pt)) < downscalingOptions.downscale_factor1Pt)
      triggerMask |= 2;
    if (prng.Rndm() < downscalingOptions.downscale_factorPt)
      triggerMask |= 4;
    if (prng.Rndm() < downscalingOptions.downscale_factorUniform)
      triggerMask |= 8;
    return triggerMask;
  }
  // +-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+-~-+

  float CalculateDCAStraightToPV(float X, float Y, float Z, float Px, float Py, float Pz, float pvX, float pvY, float pvZ)
  {
    return std::sqrt((std::pow((pvY - Y) * Pz - (pvZ - Z) * Py, 2) + std::pow((pvX - X) * Pz - (pvZ - Z) * Px, 2) + std::pow((pvX - X) * Py - (pvY - Y) * Px, 2)) / (Px * Px + Py * Py + Pz * Pz));
  }

  float roundToPrecision(float number, float step = 0.01)
  {
    // this function rounds a certain number in an axis that is quantized by
    // the variable 'step'; the rounded number is placed halfway between
    // n*step and (n+1)*step such that analysis can be done with absolutely
    // no issue with precision 'step'.
    return step * static_cast<float>(static_cast<int>((number) / step)) + TMath::Sign(1.0f, number) * (0.5f) * step;
  }

  void roundV0CandidateVariables()
  {
    v0candidate.dcaV0dau = roundToPrecision(v0candidate.dcaV0dau, precisionDCAs);
    v0candidate.posDCAxy = roundToPrecision(v0candidate.posDCAxy, precisionDCAs);
    v0candidate.negDCAxy = roundToPrecision(v0candidate.negDCAxy, precisionDCAs);
    v0candidate.dcav0topv = roundToPrecision(v0candidate.dcav0topv, precisionDCAs);
  }

  void resetHistos()
  {
    statisticsRegistry.exceptions = 0;
    statisticsRegistry.eventCounter = 0;
    for (Int_t ii = 0; ii < kNV0Steps; ii++) {
      statisticsRegistry.v0stats[ii] = 0;
      statisticsRegistry.v0statsUnassociated[ii] = 0;
    }
    for (Int_t ii = 0; ii < 10; ii++) {
      statisticsRegistry.posITSclu[ii] = 0;
      statisticsRegistry.negITSclu[ii] = 0;
    }
  }

  void fillHistos()
  {
    registry.fill(HIST("hEventCounter"), 0.0, statisticsRegistry.eventCounter);
    registry.fill(HIST("hCaughtExceptions"), 0.0, statisticsRegistry.exceptions);
    for (Int_t ii = 0; ii < kNV0Steps; ii++) {
      registry.fill(HIST("hV0Criteria"), ii, statisticsRegistry.v0stats[ii]);
      registry.fill(HIST("hV0CriteriaUnassociated"), ii, statisticsRegistry.v0statsUnassociated[ii]);
    }
    if (qaConfigurations.d_doTrackQA) {
      for (Int_t ii = 0; ii < 10; ii++) {
        registry.fill(HIST("hPositiveITSClusters"), ii, statisticsRegistry.posITSclu[ii]);
        registry.fill(HIST("hNegativeITSClusters"), ii, statisticsRegistry.negITSclu[ii]);
      }
    }
  }

  o2::track::TrackParCov lPositiveTrack;
  o2::track::TrackParCov lNegativeTrack;
  o2::track::TrackParCov lPositiveTrackIU;
  o2::track::TrackParCov lNegativeTrackIU;

  void init(InitContext& context)
  {
    prng.SetSeed(0);
    resetHistos();
    auto h = registry.add<TH1>("hV0Criteria", "hV0Criteria", kTH1D, {{10, -0.5f, 9.5f}});
    h->GetXaxis()->SetBinLabel(1, "All sel");
    h->GetXaxis()->SetBinLabel(2, "TPC requirement");
    h->GetXaxis()->SetBinLabel(3, "DCAxy Dau to PV");
    h->GetXaxis()->SetBinLabel(4, "DCA V0 Dau");
    h->GetXaxis()->SetBinLabel(5, "CosPA");
    h->GetXaxis()->SetBinLabel(6, "Radius");
    h->GetXaxis()->SetBinLabel(7, "Within momentum range");
    h->GetXaxis()->SetBinLabel(8, "Count: Standard V0");
    h->GetXaxis()->SetBinLabel(9, "Count: V0 exc. for casc");

    auto h2 = registry.add<TH1>("hV0CriteriaUnassociated", "hV0CriteriaUnassociated", kTH1D, {{10, -0.5f, 9.5f}});
    h2->GetXaxis()->SetBinLabel(1, "All sel");
    h2->GetXaxis()->SetBinLabel(2, "TPC requirement");
    h2->GetXaxis()->SetBinLabel(3, "DCAxy Dau to PV");
    h2->GetXaxis()->SetBinLabel(4, "DCA V0 Dau");
    h2->GetXaxis()->SetBinLabel(5, "CosPA");
    h2->GetXaxis()->SetBinLabel(6, "Radius");
    h2->GetXaxis()->SetBinLabel(7, "Within momentum range");
    h2->GetXaxis()->SetBinLabel(8, "Count: Standard V0");
    h2->GetXaxis()->SetBinLabel(9, "Count: V0 exc. for casc");

    randomSeed = static_cast<unsigned int>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());

    // Optionally, add extra QA histograms to processing chain
    if (qaConfigurations.d_doQA) {
      // Basic histograms containing invariant masses of all built candidates
      const AxisSpec axisVsPtCoarse{static_cast<int32_t>(qaConfigurations.dQANBinsPtCoarse), 0, qaConfigurations.dQAMaxPt, "#it{p}_{T} (GeV/c)"};
      const AxisSpec axisGammaMass{static_cast<int32_t>(qaConfigurations.dQANBinsMass), 0.000f, 0.400f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisK0ShortMass{static_cast<int32_t>(qaConfigurations.dQANBinsMass), 0.400f, 0.600f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisLambdaMass{static_cast<int32_t>(5 * qaConfigurations.dQANBinsMass), 1.01f, 2.01f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisHypertritonMass{static_cast<int32_t>(qaConfigurations.dQANBinsMass), 2.900f, 3.300f, "Inv. Mass (GeV/c^{2})"};

      registry.add("h2dGammaMass", "h2dGammaMass", kTH2F, {axisVsPtCoarse, axisGammaMass});
      registry.add("h2dK0ShortMass", "h2dK0ShortMass", kTH2F, {axisVsPtCoarse, axisK0ShortMass});
      registry.add("h2dLambdaMass", "h2dLambdaMass", kTH2F, {axisVsPtCoarse, axisLambdaMass});
      registry.add("h2dAntiLambdaMass", "h2dAntiLambdaMass", kTH2F, {axisVsPtCoarse, axisLambdaMass});
      registry.add("h2dHypertritonMass", "h2dHypertritonMass", kTH2F, {axisVsPtCoarse, axisHypertritonMass});
      registry.add("h2dAntiHypertritonMass", "h2dAntiHypertritonMass", kTH2F, {axisVsPtCoarse, axisHypertritonMass});

      // bit packed ITS cluster map
      const AxisSpec axisITSCluMap{static_cast<int32_t>(128), -0.5f, +127.5f, "Packed ITS map"};

      // Histogram to bookkeep cluster maps
      registry.add("h2dITSCluMap_Gamma", "h2dITSCluMap_Gamma", kTH3D, {axisITSCluMap, axisITSCluMap, axisConfigurations.axisRadius});
      registry.add("h2dITSCluMap_K0Short", "h2dITSCluMap_K0Short", kTH3D, {axisITSCluMap, axisITSCluMap, axisConfigurations.axisRadius});
      registry.add("h2dITSCluMap_Lambda", "h2dITSCluMap_Lambda", kTH3D, {axisITSCluMap, axisITSCluMap, axisConfigurations.axisRadius});
      registry.add("h2dITSCluMap_AntiLambda", "h2dITSCluMap_AntiLambda", kTH3D, {axisITSCluMap, axisITSCluMap, axisConfigurations.axisRadius});

      // Histogram to bookkeep cluster maps
      registry.add("h2dXIU_Gamma", "h2dXIU_Gamma", kTH3D, {axisConfigurations.axisX, axisConfigurations.axisX, axisConfigurations.axisRadius});
      registry.add("h2dXIU_K0Short", "h2dXIU_K0Short", kTH3D, {axisConfigurations.axisX, axisConfigurations.axisX, axisConfigurations.axisRadius});
      registry.add("h2dXIU_Lambda", "h2dXIU_Lambda", kTH3D, {axisConfigurations.axisX, axisConfigurations.axisX, axisConfigurations.axisRadius});
      registry.add("h2dXIU_AntiLambda", "h2dXIU_AntiLambda", kTH3D, {axisConfigurations.axisX, axisConfigurations.axisX, axisConfigurations.axisRadius});

      // QA plots of topological variables using axisPtQA
      registry.add("h2dTopoVarPointingAngle", "h2dTopoVarPointingAngle", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarPointingAngle});
      registry.add("h2dTopoVarRAP", "h2dTopoVarRAP", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarRAP});
      registry.add("h2dTopoVarV0Radius", "h2dTopoVarV0Radius", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarV0Radius});
      registry.add("h2dTopoVarDCAV0Dau", "h2dTopoVarDCAV0Dau", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarDCAV0Dau});
      registry.add("h2dTopoVarPosDCAToPV", "h2dTopoVarPosDCAToPV", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarDCAToPV});
      registry.add("h2dTopoVarNegDCAToPV", "h2dTopoVarNegDCAToPV", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarDCAToPV});
      registry.add("h2dTopoVarDCAV0ToPV", "h2dTopoVarDCAV0ToPV", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarDCAV0ToPV});

      // QA for PCM
      registry.add("h2d_pcm_DCAXY_True", "h2d_pcm_DCAXY_True", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisDCAXY});
      registry.add("h2d_pcm_DCAXY_Bg", "h2d_pcm_DCAXY_Bg", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisDCAXY});
      registry.add("h2d_pcm_DCACHI2_True", "h2d_pcm_DCACHI2_True", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisDCACHI2});
      registry.add("h2d_pcm_DCACHI2_Bg", "h2d_pcm_DCACHI2_Bg", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisDCACHI2});
      registry.add("h2d_pcm_DeltaDistanceRadii_True", "h2d_pcm_DeltaDistanceRadii_True", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisDeltaDistanceRadii});
      registry.add("h2d_pcm_DeltaDistanceRadii_Bg", "h2d_pcm_DeltaDistanceRadii_Bg", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisDeltaDistanceRadii});
      registry.add("h2d_pcm_PositionGuess_True", "h2d_pcm_PositionGuess_True", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisPositionGuess});
      registry.add("h2d_pcm_PositionGuess_Bg", "h2d_pcm_PositionGuess_Bg", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius1_True", "h2d_pcm_RadiallyOutgoingAtThisRadius1_True", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius2_True", "h2d_pcm_RadiallyOutgoingAtThisRadius2_True", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius1_Bg", "h2d_pcm_RadiallyOutgoingAtThisRadius1_Bg", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisPositionGuess});
      registry.add("h2d_pcm_RadiallyOutgoingAtThisRadius2_Bg", "h2d_pcm_RadiallyOutgoingAtThisRadius2_Bg", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisPositionGuess});
    }

    mRunNumber = 0;
    d_bz = 0;
    maxSnp = 0.85f;  // could be changed later
    maxStep = 2.00f; // could be changed later

    ccdb->setURL(ccdbConfigurations.ccdburl);
    ccdb->setCaching(true);
    ccdb->setLocalObjectValidityChecking();
    ccdb->setFatalWhenNull(false);

    if (dcaFitterConfigurations.useMatCorrType == 1) {
      LOGF(info, "TGeo correction requested, loading geometry");
      if (!o2::base::GeometryManager::isGeometryLoaded()) {
        ccdb->get<TGeoManager>(ccdbConfigurations.geoPath);
      }
    }
    if (dcaFitterConfigurations.useMatCorrType == 2) {
      LOGF(info, "LUT correction requested, will load LUT when initializing with timestamp...");
    }

    if (doprocessRun2 == false && doprocessRun3 == false && doprocessFindableRun3 == false) {
      LOGF(fatal, "Neither processRun2 nor processRun3 nor processFindableRun3 enabled. Please choose one.");
    }
    if (doprocessRun2 == true && doprocessRun3 == true) {
      LOGF(fatal, "Cannot enable processRun2 and processRun3 at the same time. Please choose one.");
    }
    if (doprocessRun2 == true && doprocessFindableRun3 == true) {
      LOGF(fatal, "Cannot enable processRun2 and processFindableRun3 at the same time. Please choose one.");
    }
    if (doprocessRun3 == true && doprocessFindableRun3 == true) {
      LOGF(fatal, "Cannot enable processRun3 and processFindableRun3 at the same time. Please choose one.");
    }

    if (d_UseAutodetectMode) {
      double loosest_v0cospa = 100;
      float loosest_dcav0dau = -100;
      float loosest_dcapostopv = 100;
      float loosest_dcanegtopv = 100;
      float loosest_radius = 100;

      double detected_v0cospa = -100;
      float detected_dcav0dau = -100;
      float detected_dcapostopv = 100;
      float detected_dcanegtopv = 100;
      float detected_radius = 100;

      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      LOGF(info, " Single-strange builder self-configuration");
      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      auto& workflows = context.services().get<RunningWorkflowInfo const>();
      for (DeviceSpec const& device : workflows.devices) {
        // Step 1: check if this device subscribed to the V0data table
        for (auto const& input : device.inputs) {
          if (device.name.compare("lambdakzero-initializer") == 0 || device.name.compare("cascade-initializer") == 0)
            continue; // don't listen to the initializers, it's just to extend stuff
          const std::string v0CoresName = "V0Cores";
          const std::string v0fCCoressName = "V0fCCores";
          const std::string CascCoresName = "StoredCascCores";
          const std::string KFCascCoresName = "StoredKFCascCores";
          const std::string TraCascCoresName = "StoredTraCascCores";
          // Logic: device is subscribed to a V0 table (excluding the cascade builder) or it's subscribed a Casc table
          if (((input.matcher.binding == v0CoresName || input.matcher.binding == v0fCCoressName) && device.name.compare("cascade-builder") != 0) ||
              input.matcher.binding == CascCoresName || input.matcher.binding == KFCascCoresName || input.matcher.binding == TraCascCoresName) {
            LOGF(info, "Device named %s has subscribed to a V0/Casc Cores table! Will now scan for desired settings...", device.name);
            for (auto const& option : device.options) {
              // 5 V0 topological selections
              if (option.name.compare("v0setting_cospa") == 0) {
                detected_v0cospa = option.defaultValue.get<double>();
                LOGF(info, "%s requested V0 cospa = %f", device.name, detected_v0cospa);
                if (detected_v0cospa < loosest_v0cospa)
                  loosest_v0cospa = detected_v0cospa;
              }
              if (option.name.compare("v0setting_dcav0dau") == 0) {
                detected_dcav0dau = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA V0 daughters = %f", device.name, detected_dcav0dau);
                if (detected_dcav0dau > loosest_dcav0dau)
                  loosest_dcav0dau = detected_dcav0dau;
              }
              if (option.name.compare("v0setting_dcapostopv") == 0) {
                detected_dcapostopv = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA positive daughter to PV = %f", device.name, detected_dcapostopv);
                if (detected_dcapostopv < loosest_dcapostopv)
                  loosest_dcapostopv = detected_dcapostopv;
              }
              if (option.name.compare("v0setting_dcanegtopv") == 0) {
                detected_dcanegtopv = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA negative daughter to PV = %f", device.name, detected_dcanegtopv);
                if (detected_dcanegtopv < loosest_dcanegtopv)
                  loosest_dcanegtopv = detected_dcanegtopv;
              }
              if (option.name.compare("v0setting_radius") == 0) {
                detected_radius = option.defaultValue.get<float>();
                LOGF(info, "%s requested minimum V0 radius = %f", device.name, detected_radius);
                if (detected_radius < loosest_radius)
                  loosest_radius = detected_radius;
              }
            }
          }
          const std::string V0CovsName = "V0Covs";
          if (input.matcher.binding == V0CovsName) {
            LOGF(info, "Device named %s has subscribed to V0Covs table! Enabling.", device.name);
            createV0CovMats.value = 1;
          }
          enableFlagIfTableRequired(context, "V0DauCovs", createV0DauCovMats);
        }
      }
      LOGF(info, "Self-configuration finished! Decided on selections:");
      LOGF(info, " -+*> V0 cospa ..............: %.6f", loosest_v0cospa);
      LOGF(info, " -+*> DCA V0 daughters ......: %.6f", loosest_dcav0dau);
      LOGF(info, " -+*> DCA positive daughter .: %.6f", loosest_dcapostopv);
      LOGF(info, " -+*> DCA negative daughter .: %.6f", loosest_dcanegtopv);
      LOGF(info, " -+*> Minimum V0 radius .....: %.6f", loosest_radius);

      dcanegtopv.value = loosest_dcanegtopv;
      dcapostopv.value = loosest_dcapostopv;
      v0cospa.value = loosest_v0cospa;
      dcav0dau.value = loosest_dcav0dau;
      v0radius.value = loosest_radius;
    }

    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
    LOGF(info, " -+*> process call configuration:");
    if (doprocessRun2 == true) {
      LOGF(info, " ---+*> Run 2 processing enabled. Will subscribe to Tracks table.");
    }
    if (doprocessRun3 == true) {
      LOGF(info, " ---+*> Run 3 processing enabled. Will subscribe to TracksIU table.");
    }
    if (createV0CovMats > 0) {
      LOGF(info, " ---+*> Will produce V0 cov mat table");
    }
    if (createV0DauCovMats > 0) {
      LOGF(info, " ---+*> Will produce V0 cov mat table for decay daughters");
    }
    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*

    // initialize O2 2-prong fitter (only once)
    fitter.setPropagateToPCA(true);
    fitter.setMaxR(200.);
    fitter.setMinParamChange(1e-3);
    fitter.setMinRelChi2Change(0.9);
    fitter.setMaxDZIni(dcaFitterConfigurations.d_maxDZIni);
    fitter.setMaxDXYIni(dcaFitterConfigurations.d_maxDXYIni);
    fitter.setMaxChi2(1e9);
    fitter.setUseAbsDCA(dcaFitterConfigurations.d_UseAbsDCA);
    fitter.setWeightedFinalPCA(dcaFitterConfigurations.d_UseWeightedPCA);

    // Material correction in the DCA fitter
    o2::base::Propagator::MatCorrType matCorr = o2::base::Propagator::MatCorrType::USEMatCorrNONE;
    if (dcaFitterConfigurations.useMatCorrType == 1)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrTGeo;
    if (dcaFitterConfigurations.useMatCorrType == 2)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrLUT;
    fitter.setMatCorrType(matCorr);
  }

  void initCCDB(aod::BCsWithTimestamps::iterator const& bc)
  {
    if (mRunNumber == bc.runNumber()) {
      return;
    }

    // machine learning initialization if requested
    if (mlConfigurations.calculateK0ShortScores ||
        mlConfigurations.calculateLambdaScores ||
        mlConfigurations.calculateAntiLambdaScores ||
        mlConfigurations.calculateGammaScores) {
      int64_t timeStampML = bc.timestamp();
      if (mlConfigurations.timestampCCDB.value != -1)
        timeStampML = mlConfigurations.timestampCCDB.value;
      LoadMachines(timeStampML);
    }

    // In case override, don't proceed, please - no CCDB access required
    if (dcaFitterConfigurations.d_bz_input > -990) {
      d_bz = dcaFitterConfigurations.d_bz_input;
      fitter.setBz(d_bz);
      o2::parameters::GRPMagField grpmag;
      if (fabs(d_bz) > 1e-5) {
        grpmag.setL3Current(30000.f / (d_bz / 5.0f));
      }
      o2::base::Propagator::initFieldFromGRP(&grpmag);
      mVtx = ccdb->getForTimeStamp<o2::dataformats::MeanVertexObject>(ccdbConfigurations.mVtxPath, bc.timestamp());
      mRunNumber = bc.runNumber();
      return;
    }

    auto timestamp = bc.timestamp();
    o2::parameters::GRPObject* grpo = 0x0;
    o2::parameters::GRPMagField* grpmag = 0x0;
    if (doprocessRun2) {
      grpo = ccdb->getForTimeStamp<o2::parameters::GRPObject>(ccdbConfigurations.grpPath, timestamp);
      if (!grpo) {
        LOG(fatal) << "Got nullptr from CCDB for path " << ccdbConfigurations.grpPath << " of object GRPObject for timestamp " << timestamp;
      }
      o2::base::Propagator::initFieldFromGRP(grpo);
    } else {
      grpmag = ccdb->getForTimeStamp<o2::parameters::GRPMagField>(ccdbConfigurations.grpmagPath, timestamp);
      if (!grpmag) {
        LOG(fatal) << "Got nullptr from CCDB for path " << ccdbConfigurations.grpmagPath << " of object GRPMagField for timestamp " << timestamp;
      }
      o2::base::Propagator::initFieldFromGRP(grpmag);
    }
    // Fetch magnetic field from ccdb for current collision
    d_bz = o2::base::Propagator::Instance()->getNominalBz();
    LOG(info) << "Retrieved GRP for timestamp " << timestamp << " with magnetic field of " << d_bz << " kG";
    mVtx = ccdb->getForTimeStamp<o2::dataformats::MeanVertexObject>(ccdbConfigurations.mVtxPath, bc.timestamp());
    mRunNumber = bc.runNumber();
    // Set magnetic field value once known
    fitter.setBz(d_bz);

    if (dcaFitterConfigurations.useMatCorrType == 2 && !lut) {
      // setMatLUT only after magfield has been initalized
      // (setMatLUT has implicit and problematic init field call if not)
      LOG(info) << "Loading material look-up table for timestamp: " << timestamp;
      lut = o2::base::MatLayerCylSet::rectifyPtrFromFile(ccdb->getForTimeStamp<o2::base::MatLayerCylSet>(ccdbConfigurations.lutPath, timestamp));
      o2::base::Propagator::Instance()->setMatLUT(lut);
    }
  }

  // function to load models for ML-based classifiers
  void LoadMachines(int64_t timeStampML)
  {
    if (mlConfigurations.loadModelsFromCCDB) {
      ccdbApi.init(ccdbConfigurations.ccdburl);
      LOG(info) << "Fetching models for timestamp: " << timeStampML;

      if (mlConfigurations.calculateLambdaScores) {
        bool retrieveSuccessLambda = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathLambda.value);
        if (retrieveSuccessLambda) {
          mlModelLambda.initModel(mlConfigurations.localModelPathLambda.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the Lambda model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }

      if (mlConfigurations.calculateAntiLambdaScores) {
        bool retrieveSuccessAntiLambda = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathAntiLambda.value);
        if (retrieveSuccessAntiLambda) {
          mlModelAntiLambda.initModel(mlConfigurations.localModelPathAntiLambda.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the AntiLambda model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }

      if (mlConfigurations.calculateGammaScores) {
        bool retrieveSuccessGamma = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathGamma.value);
        if (retrieveSuccessGamma) {
          mlModelGamma.initModel(mlConfigurations.localModelPathGamma.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the Gamma model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }

      if (mlConfigurations.calculateK0ShortScores) {
        bool retrieveSuccessKZeroShort = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathK0Short.value);
        if (retrieveSuccessKZeroShort) {
          mlModelK0Short.initModel(mlConfigurations.localModelPathK0Short.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the K0Short model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }
    } else {
      if (mlConfigurations.calculateLambdaScores)
        mlModelLambda.initModel(mlConfigurations.localModelPathLambda.value, mlConfigurations.enableOptimizations.value);
      if (mlConfigurations.calculateAntiLambdaScores)
        mlModelAntiLambda.initModel(mlConfigurations.localModelPathAntiLambda.value, mlConfigurations.enableOptimizations.value);
      if (mlConfigurations.calculateGammaScores)
        mlModelGamma.initModel(mlConfigurations.localModelPathGamma.value, mlConfigurations.enableOptimizations.value);
      if (mlConfigurations.calculateK0ShortScores)
        mlModelK0Short.initModel(mlConfigurations.localModelPathK0Short.value, mlConfigurations.enableOptimizations.value);
    }
    LOG(info) << "ML Models loaded.";
  }

  template <class TTrackTo, typename TV0Object>
  bool buildV0Candidate(TV0Object const& V0)
  {
    // Get tracks
    auto const& posTrack = V0.template posTrack_as<TTrackTo>();
    auto const& negTrack = V0.template negTrack_as<TTrackTo>();

    // for storing whatever is the relevant quantity for the PV
    o2::dataformats::VertexBase primaryVertex;
    if (V0.has_collision()) {
      auto const& collision = V0.collision();
      primaryVertex.setPos({collision.posX(), collision.posY(), collision.posZ()});
      primaryVertex.setCov(collision.covXX(), collision.covXY(), collision.covYY(), collision.covXZ(), collision.covYZ(), collision.covZZ());
    } else {
      primaryVertex.setPos({mVtx->getX(), mVtx->getY(), mVtx->getZ()});
    }

    // value 0.5: any considered V0
    statisticsRegistry.v0stats[kV0All]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kV0All]++;

    if (tpcrefit) {
      if (!(posTrack.trackType() & o2::aod::track::TPCrefit)) {
        return false;
      }
      if (!(negTrack.trackType() & o2::aod::track::TPCrefit)) {
        return false;
      }
    }

    // Passes TPC refit
    statisticsRegistry.v0stats[kV0TPCrefit]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kV0TPCrefit]++;

    // Calculate DCA with respect to the collision associated to the V0, not individual tracks
    gpu::gpustd::array<float, 2> dcaInfo;

    auto posTrackPar = getTrackPar(posTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ()}, posTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    auto posTrackdcaXY = dcaInfo[0];

    auto negTrackPar = getTrackPar(negTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ()}, negTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    auto negTrackdcaXY = dcaInfo[0];

    if (fabs(posTrackdcaXY) < dcapostopv || fabs(negTrackdcaXY) < dcanegtopv) {
      return false;
    }

    // Initialize properly, please
    v0candidate.posDCAxy = posTrackdcaXY;
    v0candidate.negDCAxy = negTrackdcaXY;

    // passes DCAxy
    statisticsRegistry.v0stats[kV0DCAxy]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kV0DCAxy]++;

    // Change strangenessBuilder tracks
    lPositiveTrack = getTrackParCov(posTrack);
    lNegativeTrack = getTrackParCov(negTrack);
    lPositiveTrackIU = getTrackParCov(posTrack);
    lNegativeTrackIU = getTrackParCov(negTrack);

    //---/---/---/
    // Move close to minima
    int nCand = 0;
    fitter.setCollinear(dcaFitterConfigurations.d_UseCollinearFit || V0.isCollinearV0());
    try {
      nCand = fitter.process(lPositiveTrack, lNegativeTrack);
    } catch (...) {
      statisticsRegistry.exceptions++;
      LOG(error) << "Exception caught in DCA fitter process call!";
      return false;
    }
    if (nCand == 0) {
      return false;
    }

    v0candidate.posTrackX = fitter.getTrack(0).getX();
    v0candidate.negTrackX = fitter.getTrack(1).getX();

    lPositiveTrack = fitter.getTrack(0);
    lNegativeTrack = fitter.getTrack(1);
    lPositiveTrack.getPxPyPzGlo(v0candidate.posP);
    lNegativeTrack.getPxPyPzGlo(v0candidate.negP);
    lPositiveTrack.getXYZGlo(v0candidate.posPosition);
    lNegativeTrack.getXYZGlo(v0candidate.negPosition);

    // get decay vertex coordinates
    const auto& vtx = fitter.getPCACandidate();
    for (int i = 0; i < 3; i++) {
      v0candidate.pos[i] = vtx[i];
    }

    v0candidate.dcaV0dau = TMath::Sqrt(fitter.getChi2AtPCACandidate());

    // Apply selections so a skimmed table is created only
    if (v0candidate.dcaV0dau > dcav0dau) {
      return false;
    }

    // Passes DCA between daughters check
    statisticsRegistry.v0stats[kV0DCADau]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kV0DCADau]++;

    v0candidate.cosPA = RecoDecay::cpa(array{primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ()}, array{v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2]}, array{v0candidate.posP[0] + v0candidate.negP[0], v0candidate.posP[1] + v0candidate.negP[1], v0candidate.posP[2] + v0candidate.negP[2]});
    if (v0candidate.cosPA < v0cospa) {
      return false;
    }

    v0candidate.dcav0topv = CalculateDCAStraightToPV(
      v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2],
      v0candidate.posP[0] + v0candidate.negP[0],
      v0candidate.posP[1] + v0candidate.negP[1],
      v0candidate.posP[2] + v0candidate.negP[2],
      primaryVertex.getX(), primaryVertex.getY(), primaryVertex.getZ());

    // Passes CosPA check
    statisticsRegistry.v0stats[kV0CosPA]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kV0CosPA]++;

    v0candidate.V0radius = RecoDecay::sqrtSumOfSquares(v0candidate.pos[0], v0candidate.pos[1]);
    if (v0candidate.V0radius < v0radius) {
      return false;
    }

    // Passes radius check
    statisticsRegistry.v0stats[kV0Radius]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kV0Radius]++;
    // Return OK: passed all v0 candidate selecton criteria

    auto px = v0candidate.posP[0] + v0candidate.negP[0];
    auto py = v0candidate.posP[1] + v0candidate.negP[1];
    auto pz = v0candidate.posP[2] + v0candidate.negP[2];
    auto lPt = RecoDecay::sqrtSumOfSquares(v0candidate.posP[0] + v0candidate.negP[0], v0candidate.posP[1] + v0candidate.negP[1]);
    auto lPtotal = RecoDecay::sqrtSumOfSquares(lPt, v0candidate.posP[2] + v0candidate.negP[2]);
    auto lLengthTraveled = RecoDecay::sqrtSumOfSquares(v0candidate.pos[0] - primaryVertex.getX(), v0candidate.pos[1] - primaryVertex.getY(), v0candidate.pos[2] - primaryVertex.getZ());

    // Momentum range check
    if (lPt < minimumPt || lPt > maximumPt) {
      return false; // reject if not within desired window
    }

    // Daughter eta check
    if (TMath::Abs(RecoDecay::eta(std::array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]})) > maxDaughterEta ||
        TMath::Abs(RecoDecay::eta(std::array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]})) > maxDaughterEta) {
      return false; // reject - daughters have too large eta to be reliable for MC corrections
    }

    // calculate proper lifetime
    // m*L/p for each hypothesis
    float lML2P_K0Short = o2::constants::physics::MassKaonNeutral * lLengthTraveled / lPtotal;
    float lML2P_Lambda = o2::constants::physics::MassLambda * lLengthTraveled / lPtotal;

    // Passes momentum window check
    statisticsRegistry.v0stats[kWithinMomentumRange]++;
    if (!V0.has_collision())
      statisticsRegistry.v0statsUnassociated[kWithinMomentumRange]++;

    // Calculate masses
    auto lGammaMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassElectron, o2::constants::physics::MassElectron});
    v0candidate.k0ShortMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassPionCharged});
    v0candidate.lambdaMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassProton, o2::constants::physics::MassPionCharged});
    v0candidate.antiLambdaMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassProton});
    auto lHypertritonMass = RecoDecay::m(array{array{2.0f * v0candidate.posP[0], 2.0f * v0candidate.posP[1], 2.0f * v0candidate.posP[2]}, array{v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2]}}, array{o2::constants::physics::MassHelium3, o2::constants::physics::MassPionCharged});
    auto lAntiHypertritonMass = RecoDecay::m(array{array{v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2]}, array{2.0f * v0candidate.negP[0], 2.0f * v0candidate.negP[1], 2.0f * v0candidate.negP[2]}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassHelium3});

    // mass window check
    bool keepCandidate = false;

    bool desiredMassK0Short = false;
    bool desiredMassLambda = false;
    bool desiredMassAntiLambda = false;
    bool desiredMassGamma = false;

    if (massWindownumberOfSigmas > 1e+3) {
      desiredMassK0Short = true;    // safety fallback
      desiredMassLambda = true;     // safety fallback
      desiredMassAntiLambda = true; // safety fallback
      desiredMassGamma = true;      // safety fallback
    } else {
      desiredMassK0Short = TMath::Abs(v0candidate.k0ShortMass - o2::constants::physics::MassKaonNeutral) < massWindownumberOfSigmas * getMassSigmaK0Short(lPt) + massWindowSafetyMargin;
      desiredMassLambda = TMath::Abs(v0candidate.lambdaMass - o2::constants::physics::MassLambda) < massWindownumberOfSigmas * getMassSigmaLambda(lPt) + massWindowSafetyMargin;
      desiredMassAntiLambda = TMath::Abs(v0candidate.antiLambdaMass - o2::constants::physics::MassLambda) < massWindownumberOfSigmas * getMassSigmaLambda(lPt) + massWindowSafetyMargin;
      desiredMassGamma = TMath::Abs(lGammaMass) < massCutPhoton;
    }

    // check if user requested to correlate mass requirement with TPC PID
    // (useful for data volume reduction)
    bool dEdxK0Short = V0.isdEdxK0Short() || !massWindowWithTPCPID;
    bool dEdxLambda = V0.isdEdxLambda() || !massWindowWithTPCPID;
    bool dEdxAntiLambda = V0.isdEdxAntiLambda() || !massWindowWithTPCPID;
    bool dEdxGamma = V0.isdEdxGamma() || !massWindowWithTPCPID;

    // check proper lifetime if asked for
    bool passML2P_K0Short = lML2P_K0Short < lifetimecut->get("lifetimecutK0S") || lifetimecut->get("lifetimecutK0S") > 1000;
    bool passML2P_Lambda = lML2P_Lambda < lifetimecut->get("lifetimecutLambda") || lifetimecut->get("lifetimecutLambda") > 1000;

    if (passML2P_K0Short && dEdxK0Short && desiredMassK0Short)
      keepCandidate = true;
    if (passML2P_Lambda && dEdxLambda && desiredMassLambda)
      keepCandidate = true;
    if (passML2P_Lambda && dEdxAntiLambda && desiredMassAntiLambda)
      keepCandidate = true;
    if (dEdxGamma && desiredMassGamma)
      keepCandidate = true;

    if (!keepCandidate)
      return false;

    if (qaConfigurations.d_doTrackQA) {
      if (posTrack.itsNCls() < 10)
        statisticsRegistry.posITSclu[posTrack.itsNCls()]++;
      if (negTrack.itsNCls() < 10)
        statisticsRegistry.negITSclu[negTrack.itsNCls()]++;
    }

    if (qaConfigurations.d_doQA) {
      bool mcUnchecked = !qaConfigurations.d_QA_checkMC;
      bool dEdxUnchecked = !qaConfigurations.d_QA_checkdEdx;

      auto lPtHy = RecoDecay::sqrtSumOfSquares(2.0f * v0candidate.posP[0] + v0candidate.negP[0], 2.0f * v0candidate.posP[1] + v0candidate.negP[1]);
      auto lPtAnHy = RecoDecay::sqrtSumOfSquares(v0candidate.posP[0] + 2.0f * v0candidate.negP[0], v0candidate.posP[1] + 2.0f * v0candidate.negP[1]);

      // Fill basic mass histograms
      if (TMath::Abs(RecoDecay::eta(std::array{px, py, pz})) < 0.5) {
        if ((V0.isdEdxGamma() || dEdxUnchecked) && (V0.isTrueGamma() || mcUnchecked))
          registry.fill(HIST("h2dGammaMass"), lPt, lGammaMass);
        if ((V0.isdEdxK0Short() || dEdxUnchecked) && (V0.isTrueK0Short() || mcUnchecked))
          registry.fill(HIST("h2dK0ShortMass"), lPt, v0candidate.k0ShortMass);
        if ((V0.isdEdxLambda() || dEdxUnchecked) && (V0.isTrueLambda() || mcUnchecked))
          registry.fill(HIST("h2dLambdaMass"), lPt, v0candidate.lambdaMass);
        if ((V0.isdEdxAntiLambda() || dEdxUnchecked) && (V0.isTrueAntiLambda() || mcUnchecked))
          registry.fill(HIST("h2dAntiLambdaMass"), lPt, v0candidate.antiLambdaMass);
        if ((V0.isdEdxHypertriton() || dEdxUnchecked) && (V0.isTrueHypertriton() || mcUnchecked))
          registry.fill(HIST("h2dHypertritonMass"), lPtHy, lHypertritonMass);
        if ((V0.isdEdxAntiHypertriton() || dEdxUnchecked) && (V0.isTrueAntiHypertriton() || mcUnchecked))
          registry.fill(HIST("h2dAntiHypertritonMass"), lPtAnHy, lAntiHypertritonMass);
      }

      // Fill ITS cluster maps with specific mass cuts
      if (TMath::Abs(lGammaMass - 0.0) < qaConfigurations.dQAGammaMassWindow && ((V0.isdEdxGamma() || dEdxUnchecked) && (V0.isTrueGamma() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_Gamma"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_Gamma"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }
      if (TMath::Abs(v0candidate.k0ShortMass - 0.497) < qaConfigurations.dQAK0ShortMassWindow && ((V0.isdEdxK0Short() || dEdxUnchecked) && (V0.isTrueK0Short() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_K0Short"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_K0Short"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }
      if (TMath::Abs(v0candidate.lambdaMass - 1.116) < qaConfigurations.dQALambdaMassWindow && ((V0.isdEdxLambda() || dEdxUnchecked) && (V0.isTrueLambda() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_Lambda"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_Lambda"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }
      if (TMath::Abs(v0candidate.antiLambdaMass - 1.116) < qaConfigurations.dQALambdaMassWindow && ((V0.isdEdxAntiLambda() || dEdxUnchecked) && (V0.isTrueAntiLambda() || mcUnchecked))) {
        registry.fill(HIST("h2dITSCluMap_AntiLambda"), static_cast<float>(posTrack.itsClusterMap()), static_cast<float>(negTrack.itsClusterMap()), v0candidate.V0radius);
        registry.fill(HIST("h2dXIU_AntiLambda"), static_cast<float>(posTrack.x()), static_cast<float>(negTrack.x()), v0candidate.V0radius);
      }

      // QA extra: DCA to PV
      float dcaV0toPV = std::sqrt((std::pow((primaryVertex.getY() - v0candidate.pos[1]) * pz - (primaryVertex.getZ() - v0candidate.pos[2]) * py, 2) + std::pow((primaryVertex.getX() - v0candidate.pos[0]) * pz - (primaryVertex.getZ() - v0candidate.pos[2]) * px, 2) + std::pow((primaryVertex.getX() - v0candidate.pos[0]) * py - (primaryVertex.getY() - v0candidate.pos[1]) * px, 2)) / (px * px + py * py + pz * pz));

      registry.fill(HIST("h2dTopoVarPointingAngle"), lPt, TMath::ACos(v0candidate.cosPA));
      registry.fill(HIST("h2dTopoVarRAP"), lPt, TMath::ACos(v0candidate.cosPA) * v0candidate.V0radius);
      registry.fill(HIST("h2dTopoVarV0Radius"), lPt, v0candidate.V0radius);
      registry.fill(HIST("h2dTopoVarDCAV0Dau"), lPt, v0candidate.dcaV0dau);
      registry.fill(HIST("h2dTopoVarPosDCAToPV"), lPt, v0candidate.posDCAxy);
      registry.fill(HIST("h2dTopoVarNegDCAToPV"), lPt, v0candidate.negDCAxy);
      registry.fill(HIST("h2dTopoVarDCAV0ToPV"), lPt, dcaV0toPV);

      // -------------------------------------------------------------------------------------
      // PCM finding tests
      //
      // a) delta1 = D - R1 - R2
      //             D: distance between two track helix centers in xy
      //             R1, R2: track radii

      o2::math_utils::CircleXYf_t trcCircle1, trcCircle2;
      float sna, csa;
      posTrackPar.getCircleParams(d_bz, trcCircle1, sna, csa);
      negTrackPar.getCircleParams(d_bz, trcCircle2, sna, csa);

      // distance between circle centers (one circle is at origin -> easy)
      float centerDistance = std::hypot(trcCircle1.xC - trcCircle2.xC, trcCircle1.yC - trcCircle2.yC);

      // b) delta2 = abs(R2/(R1+R2)*rvec1 + R1/(R1+R2)*rvec2)
      float r1_r = trcCircle1.rC / (trcCircle1.rC + trcCircle2.rC);
      float r2_r = trcCircle2.rC / (trcCircle1.rC + trcCircle2.rC);
      float delta2 = std::hypot(r2_r * trcCircle1.xC + r1_r * trcCircle2.xC, r2_r * trcCircle1.yC + r1_r * trcCircle2.yC);

      // c) delta3 = sqrt(D^2-R^2); D: distance origin-center, R: radius
      float delta3_track1 = TMath::Sqrt(TMath::Power(trcCircle1.xC, 2) + TMath::Power(trcCircle1.yC, 2) - TMath::Power(trcCircle1.rC, 2));
      float delta3_track2 = TMath::Sqrt(TMath::Power(trcCircle2.xC, 2) + TMath::Power(trcCircle2.yC, 2) - TMath::Power(trcCircle2.rC, 2));

      // let's just use tagged, cause we can
      if (!posTrack.hasITS() && !posTrack.hasTRD() && !posTrack.hasTOF() && !negTrack.hasITS() && !negTrack.hasTRD() && !negTrack.hasTOF()) {
        if (V0.isTrueGamma()) {
          registry.fill(HIST("h2d_pcm_DCAXY_True"), lPt, std::hypot(dcaInfo[0], dcaInfo[1]));
          registry.fill(HIST("h2d_pcm_DCACHI2_True"), lPt, fitter.getChi2AtPCACandidate());
          registry.fill(HIST("h2d_pcm_DeltaDistanceRadii_True"), lPt, centerDistance - trcCircle1.rC - trcCircle2.rC);
          registry.fill(HIST("h2d_pcm_PositionGuess_True"), lPt, delta2);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius1_True"), lPt, delta3_track1);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius2_True"), lPt, delta3_track2);
        } else {
          registry.fill(HIST("h2d_pcm_DCAXY_Bg"), lPt, std::hypot(dcaInfo[0], dcaInfo[1]));
          registry.fill(HIST("h2d_pcm_DCACHI2_Bg"), lPt, fitter.getChi2AtPCACandidate());
          registry.fill(HIST("h2d_pcm_DeltaDistanceRadii_Bg"), lPt, centerDistance - trcCircle1.rC - trcCircle2.rC);
          registry.fill(HIST("h2d_pcm_PositionGuess_Bg"), lPt, delta2);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius1_Bg"), lPt, delta3_track1);
          registry.fill(HIST("h2d_pcm_RadiallyOutgoingAtThisRadius2_Bg"), lPt, delta3_track2);
        }
      }
      // -------------------------------------------------------------------------------------
    } // end QA
    return true;
  }

  template <class TTrackTo, typename TV0Table>
  void buildStrangenessTables(TV0Table const& V0s)
  {
    // Loops over all V0s in the time frame
    for (auto& V0 : V0s) {
      // downscale some V0s if requested to do so
      if (downscalingOptions.downscaleFactor < 1.f && (static_cast<float>(rand_r(&randomSeed)) / static_cast<float>(RAND_MAX)) > downscalingOptions.downscaleFactor) {
        return;
      }

      // populates v0candidate struct declared inside strangenessbuilder
      bool validCandidate = buildV0Candidate<TTrackTo>(V0);

      if (!validCandidate) {
        continue; // doesn't pass selections
      }

      int ivanovMap = 0;
      float pt = RecoDecay::sqrtSumOfSquares(v0candidate.posP[0] + v0candidate.negP[0], v0candidate.posP[1] + v0candidate.negP[1]);
      if (downscalingOptions.downscale_adaptive) {
        ivanovMap = DownsampleMap(pt);
        if (ivanovMap == 0)
          continue; // skip this V0, passes nothing
      }

      // round the DCA variables to a certain precision if asked
      if (roundDCAVariables)
        roundV0CandidateVariables();

      // evaluate machine-learning scores
      float gammaScore = -1.0f, lambdaScore = -1.0f, antiLambdaScore = -1.0f, k0ShortScore = -1.0f;

      if (mlConfigurations.calculateK0ShortScores ||
          mlConfigurations.calculateLambdaScores ||
          mlConfigurations.calculateAntiLambdaScores ||
          mlConfigurations.calculateGammaScores) {
        // machine learning is on, go for calculation of thresholds
        // FIXME THIS NEEDS ADJUSTING
        std::vector<float> inputFeatures{pt, 0.0f,
                                         0.0f, v0candidate.V0radius,
                                         v0candidate.cosPA, v0candidate.dcaV0dau,
                                         v0candidate.posDCAxy, v0candidate.negDCAxy};

        // calculate scores
        if (mlConfigurations.calculateLambdaScores) {
          float* lambdaProbability = mlModelLambda.evalModel(inputFeatures);
          lambdaScore = lambdaProbability[1];
        }
        if (mlConfigurations.calculateGammaScores) {
          float* gammaProbability = mlModelGamma.evalModel(inputFeatures);
          gammaScore = gammaProbability[1];
        }

        // Skip anything that doesn't fulfull any of the desired conditions
        if (gammaScore < mlConfigurations.thresholdGamma.value &&
            lambdaScore < mlConfigurations.thresholdLambda.value &&
            antiLambdaScore < mlConfigurations.thresholdAntiLambda.value &&
            k0ShortScore < mlConfigurations.thresholdK0Short.value) {
          continue; // skipped as uninteresting in any hypothesis considered
        }
      }

      // V0 logic reminder
      // 0: v0 saved for the only due to the cascade, 1: standalone v0, 3: standard v0 with photon-only test
      if (V0.v0Type() > 0) {
        if (V0.v0Type() > 1 && !storePhotonCandidates)
          continue;

        // at this stage, the candidate is interesting -> populate table
        gammaMLSelections(gammaScore);
        lambdaMLSelections(lambdaScore);
        antiLambdaMLSelections(antiLambdaScore);
        k0ShortMLSelections(k0ShortScore);

        // populates the various tables for analysis
        statisticsRegistry.v0stats[kCountStandardV0]++;
        if (!V0.has_collision())
          statisticsRegistry.v0statsUnassociated[kCountStandardV0]++;

        v0indices(V0.posTrackId(), V0.negTrackId(),
                  V0.collisionId(), V0.globalIndex());
        v0trackXs(v0candidate.posTrackX, v0candidate.negTrackX);
        v0cores(v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2],
                v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2],
                v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2],
                v0candidate.dcaV0dau,
                v0candidate.posDCAxy,
                v0candidate.negDCAxy,
                v0candidate.cosPA,
                v0candidate.dcav0topv,
                V0.v0Type());
        if (createV0PosAtDCAs)
          v0dauPositions(v0candidate.posPosition[0], v0candidate.posPosition[1], v0candidate.posPosition[2],
                         v0candidate.negPosition[0], v0candidate.negPosition[1], v0candidate.negPosition[2]);
        if (createV0PosAtIUs) {
          std::array<float, 3> posPositionIU;
          std::array<float, 3> negPositionIU;
          lPositiveTrackIU.getXYZGlo(posPositionIU);
          lNegativeTrackIU.getXYZGlo(negPositionIU);
          v0dauPositionsIU(posPositionIU[0], posPositionIU[1], posPositionIU[2],
                           negPositionIU[0], negPositionIU[1], negPositionIU[2]);
        }
        if (downscalingOptions.downscale_adaptive) {
          v0ivanovs(ivanovMap);
        }
      } else {
        // place V0s built exclusively for the sake of cascades
        // in a fully independent table (though identical) to make
        // sure there's no accidental usage of those candidates
        // N.B.: these are obtained with *other selections* in
        //       the svertexer!
        statisticsRegistry.v0stats[kCountV0forCascade]++;
        v0fcindices(V0.posTrackId(), V0.negTrackId(),
                    V0.collisionId(), V0.globalIndex());
        v0fctrackXs(v0candidate.posTrackX, v0candidate.negTrackX);
        v0fccores(v0candidate.pos[0], v0candidate.pos[1], v0candidate.pos[2],
                  v0candidate.posP[0], v0candidate.posP[1], v0candidate.posP[2],
                  v0candidate.negP[0], v0candidate.negP[1], v0candidate.negP[2],
                  v0candidate.dcaV0dau,
                  v0candidate.posDCAxy,
                  v0candidate.negDCAxy,
                  v0candidate.cosPA,
                  v0candidate.dcav0topv,
                  V0.v0Type());
      }

      // populate V0 covariance matrices if required by any other task
      if (createV0CovMats) {
        // Calculate position covariance matrix
        auto covVtxV = fitter.calcPCACovMatrix(0);
        // std::array<float, 6> positionCovariance;
        float positionCovariance[6];
        positionCovariance[0] = covVtxV(0, 0);
        positionCovariance[1] = covVtxV(1, 0);
        positionCovariance[2] = covVtxV(1, 1);
        positionCovariance[3] = covVtxV(2, 0);
        positionCovariance[4] = covVtxV(2, 1);
        positionCovariance[5] = covVtxV(2, 2);
        std::array<float, 21> covTpositive = {0.};
        std::array<float, 21> covTnegative = {0.};
        std::array<float, 21> covTpositiveIU = {0.};
        std::array<float, 21> covTnegativeIU = {0.};
        // std::array<float, 6> momentumCovariance;
        float momentumCovariance[6];
        lPositiveTrack.getCovXYZPxPyPzGlo(covTpositive);
        lNegativeTrack.getCovXYZPxPyPzGlo(covTnegative);
        lPositiveTrackIU.getCovXYZPxPyPzGlo(covTpositiveIU);
        lNegativeTrackIU.getCovXYZPxPyPzGlo(covTnegativeIU);
        constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
        for (int i = 0; i < 6; i++) {
          momentumCovariance[i] = covTpositive[MomInd[i]] + covTnegative[MomInd[i]];
        }
        if (V0.v0Type() > 0) {
          if (V0.v0Type() > 1 && !storePhotonCandidates)
            continue;
          v0covs(positionCovariance, momentumCovariance);
          if (createV0DauCovMats) {
            // store momentum covariance matrix
            float covariancePosTrack[21];
            float covarianceNegTrack[21];
            float covariancePosTrackIU[21];
            float covarianceNegTrackIU[21];
            for (int i = 0; i < 21; i++) {
              covariancePosTrack[i] = covTpositive[i];
              covarianceNegTrack[i] = covTnegative[i];
              covariancePosTrackIU[i] = covTpositiveIU[i];
              covarianceNegTrackIU[i] = covTnegativeIU[i];
            }
            v0daucovs(covariancePosTrack, covarianceNegTrack);
            v0daucovIUs(covariancePosTrackIU, covarianceNegTrackIU);
          }
        } else {
          v0fccovs(positionCovariance, momentumCovariance);
        }
      }
    }
    // En masse histo filling at end of process call
    fillHistos();
    resetHistos();
  }

  void processRun2(aod::Collisions const& collisions, soa::Filtered<TaggedV0s> const& V0s, FullTracksExt const&, aod::BCsWithTimestamps const&)
  {
    statisticsRegistry.eventCounter += collisions.size();
    // Fire up CCDB
    auto collision = collisions.begin();
    auto bc = collision.bc_as<aod::BCsWithTimestamps>();
    initCCDB(bc);
    buildStrangenessTables<FullTracksExt>(V0s);
  }
  PROCESS_SWITCH(lambdakzeroBuilder, processRun2, "Produce Run 2 V0 tables", false);

  void processRun3(aod::Collisions const& collisions, soa::Filtered<TaggedV0s> const& V0s, FullTracksExtIU const&, aod::BCsWithTimestamps const& bcs)
  {
    statisticsRegistry.eventCounter += collisions.size();
    // Fire up CCDB
    auto bc = collisions.size() ? collisions.begin().bc_as<aod::BCsWithTimestamps>() : bcs.begin();
    if (!bcs.size()) {
      LOGF(warn, "No BC found, skipping this DF.");
      return;
    }
    initCCDB(bc);
    buildStrangenessTables<FullTracksExtIU>(V0s);
  }
  PROCESS_SWITCH(lambdakzeroBuilder, processRun3, "Produce Run 3 V0 tables", true);

  void processFindableRun3(aod::Collisions const& collisions, soa::Filtered<TaggedFindableV0s> const& V0s, FullTracksExtIU const&, aod::BCsWithTimestamps const& bcs)
  {
    statisticsRegistry.eventCounter += collisions.size();
    // Fire up CCDB
    auto bc = collisions.size() ? collisions.begin().bc_as<aod::BCsWithTimestamps>() : bcs.begin();
    if (!bcs.size()) {
      LOGF(warn, "No BC found, skipping this DF.");
      return;
    }
    initCCDB(bc);
    buildStrangenessTables<FullTracksExtIU>(V0s);
  }
  PROCESS_SWITCH(lambdakzeroBuilder, processFindableRun3, "Produce Run 3 V0 tables with all findable candidates", false);
};

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct lambdakzeroPreselector {
  Produces<aod::V0Tags> v0tags; // MC tags

  // for bookkeeping
  HistogramRegistry histos{"Histos", {}, OutputObjHandlingPolicy::AnalysisObject};

  Configurable<bool> dIfMCgenerateK0Short{"dIfMCgenerateK0Short", true, "if MC, generate MC true K0Short (yes/no)"};
  Configurable<bool> dIfMCgenerateLambda{"dIfMCgenerateLambda", true, "if MC, generate MC true Lambda (yes/no)"};
  Configurable<bool> dIfMCgenerateAntiLambda{"dIfMCgenerateAntiLambda", true, "if MC, generate MC true AntiLambda (yes/no)"};
  Configurable<bool> dIfMCgenerateGamma{"dIfMCgenerateGamma", false, "if MC, generate MC true gamma (yes/no)"};
  Configurable<bool> dIfMCgenerateHypertriton{"dIfMCgenerateHypertriton", false, "if MC, generate MC true hypertritons (yes/no)"};
  Configurable<bool> dIfMCgenerateAntiHypertriton{"dIfMCgenerateAntiHypertriton", false, "if MC, generate MC true antihypertritons (yes/no)"};
  Configurable<int> dIfMCselectV0MotherPDG{"dIfMCselectV0MotherPDG", 0, "if MC, selects based on mother particle (zero for no selection)"};
  Configurable<bool> dIfMCselectPhysicalPrimary{"dIfMCselectPhysicalPrimary", true, "if MC, select MC physical primary (yes/no)"};

  Configurable<bool> ddEdxPreSelectK0Short{"ddEdxPreSelectK0Short", true, "pre-select dE/dx compatibility with K0Short (yes/no)"};
  Configurable<bool> ddEdxPreSelectLambda{"ddEdxPreSelectLambda", true, "pre-select dE/dx compatibility with Lambda (yes/no)"};
  Configurable<bool> ddEdxPreSelectAntiLambda{"ddEdxPreSelectAntiLambda", true, "pre-select dE/dx compatibility with AntiLambda (yes/no)"};
  Configurable<bool> ddEdxPreSelectGamma{"ddEdxPreSelectGamma", false, "pre-select dE/dx compatibility with gamma (yes/no)"};
  Configurable<bool> ddEdxPreSelectHypertriton{"ddEdxPreSelectHypertriton", false, "pre-select dE/dx compatibility with hypertritons (yes/no)"};
  Configurable<bool> ddEdxPreSelectAntiHypertriton{"ddEdxPreSelectAntiHypertriton", false, "pre-select dE/dx compatibility with antihypertritons (yes/no)"};

  // dEdx pre-selection compatibility
  Configurable<float> ddEdxPreSelectionWindow{"ddEdxPreSelectionWindow", 7, "Nsigma window for dE/dx preselection"};

  // tpc quality pre-selection
  Configurable<int> dTPCNCrossedRows{"dTPCNCrossedRows", 50, "Minimum TPC crossed rows"};

  // context-aware selections
  Configurable<bool> dPreselectOnlyBaryons{"dPreselectOnlyBaryons", false, "apply TPC dE/dx only to baryon daughters"};

  // for debugging and further tests
  Configurable<bool> forceITSOnlyMesons{"forceITSOnlyMesons", false, "force meson-like daughters to be ITS-only to pass Lambda/AntiLambda selections (yes/no)"};
  Configurable<int> minITSCluITSOnly{"minITSCluITSOnly", 0, "minimum number of ITS clusters to ask for if daughter track does not have TPC"};

  // for bit-packed maps
  std::vector<uint32_t> selectionMask;
  enum v0bit { bitInteresting = 0,
               bitTrackQuality,
               bitTrueGamma,
               bitTrueK0Short,
               bitTrueLambda,
               bitTrueAntiLambda,
               bitTrueHypertriton,
               bitTrueAntiHypertriton,
               bitPhysicalPrimary,
               bitdEdxGamma,
               bitdEdxK0Short,
               bitdEdxLambda,
               bitdEdxAntiLambda,
               bitdEdxHypertriton,
               bitdEdxAntiHypertriton,
               bitUsedInCascade,
               bitUsedInTrackedCascade };

  void init(InitContext const&)
  {
    // check settings and stop if not viable
    if (doprocessBuildAll == false && doprocessBuildMCAssociated == false && doprocessBuildValiddEdx == false && doprocessBuildValiddEdxMCAssociated == false && doprocessBuildFindable == false) {
      LOGF(fatal, "No processBuild function enabled. Please choose one.");
    }
    LOGF(info, "Process function processBuildAll status: %i", static_cast<int>(doprocessBuildAll));
    LOGF(info, "Process function doprocessBuildMCAssociated status: %i", static_cast<int>(doprocessBuildMCAssociated));
    LOGF(info, "Process function doprocessBuildValiddEdx status: %i", static_cast<int>(doprocessBuildValiddEdx));
    LOGF(info, "Process function doprocessBuildValiddEdxMCAssociated status: %i", static_cast<int>(doprocessBuildValiddEdxMCAssociated));
    LOGF(info, "Process function doprocessBuildFindable status: %i", static_cast<int>(doprocessBuildFindable));

    auto h = histos.add<TH1>("hPreselectorStatistics", "hPreselectorStatistics", kTH1D, {{6, -0.5f, 5.5f}});
    h->GetXaxis()->SetBinLabel(1, "All");
    h->GetXaxis()->SetBinLabel(2, "Tracks OK");
    h->GetXaxis()->SetBinLabel(3, "MC label OK");
    h->GetXaxis()->SetBinLabel(4, "dEdx OK");
    h->GetXaxis()->SetBinLabel(5, "Used in Casc");
    h->GetXaxis()->SetBinLabel(6, "Used in Tra-Casc");
  }

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check track quality
  template <class TTrackTo, typename TV0Object>
  void checkTrackQuality(TV0Object const& lV0Candidate, uint32_t& maskElement, bool passdEdx = false)
  {
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // crossed rows conditionals
    bool posRowsOK = lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows;
    bool negRowsOK = lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows;

    // check track explicitly for absence of TPC
    bool posITSonly = !lPosTrack.hasTPC();
    bool negITSonly = !lNegTrack.hasTPC();
    bool longPosITSonly = posITSonly && lPosTrack.itsNCls() >= minITSCluITSOnly;
    bool longNegITSonly = negITSonly && lNegTrack.itsNCls() >= minITSCluITSOnly;

    // No baryons in decay
    if (((bitcheck(maskElement, bitdEdxGamma) || bitcheck(maskElement, bitdEdxK0Short)) || passdEdx) && (posRowsOK && negRowsOK) && (!forceITSOnlyMesons || (posITSonly && negITSonly)))
      bitset(maskElement, bitTrackQuality);
    // With baryons in decay
    if ((bitcheck(maskElement, bitdEdxLambda) || passdEdx) &&               // logical AND with dEdx
        (posRowsOK && (negRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || negITSonly))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxAntiLambda) || passdEdx) &&           // logical AND with dEdx
        (negRowsOK && (posRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || posITSonly))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxHypertriton) || passdEdx) &&          // logical AND with dEdx
        (posRowsOK && (negRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || negITSonly))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxAntiHypertriton) || passdEdx) &&      // logical AND with dEdx
        (negRowsOK && (posRowsOK || dPreselectOnlyBaryons)) &&              // rows requirement
        ((posRowsOK || longPosITSonly) && (negRowsOK || longNegITSonly)) && // if ITS-only, check for min length
        (!forceITSOnlyMesons || posITSonly))
      bitset(maskElement, bitTrackQuality);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check PDG association
  template <class TTrackTo, typename TV0Object>
  void checkPDG(TV0Object const& lV0Candidate, uint32_t& maskElement)
  {
    int lPDG = -1;
    bool physicalPrimary = false;
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // Association check
    // There might be smarter ways of doing this in the future
    if (lNegTrack.has_mcParticle() && lPosTrack.has_mcParticle()) {
      auto lMCNegTrack = lNegTrack.template mcParticle_as<aod::McParticles>();
      auto lMCPosTrack = lPosTrack.template mcParticle_as<aod::McParticles>();
      if (lMCNegTrack.has_mothers() && lMCPosTrack.has_mothers()) {
        for (auto& lNegMother : lMCNegTrack.template mothers_as<aod::McParticles>()) {
          for (auto& lPosMother : lMCPosTrack.template mothers_as<aod::McParticles>()) {
            if (lNegMother.globalIndex() == lPosMother.globalIndex() && (!dIfMCselectPhysicalPrimary || lNegMother.isPhysicalPrimary())) {
              lPDG = lNegMother.pdgCode();
              physicalPrimary = lNegMother.isPhysicalPrimary();

              // additionally check PDG of the mother particle if requested
              if (dIfMCselectV0MotherPDG != 0) {
                lPDG = 0; // this is not the species you're looking for
                if (lNegMother.has_mothers()) {
                  for (auto& lNegGrandMother : lNegMother.template mothers_as<aod::McParticles>()) {
                    if (lNegGrandMother.pdgCode() == dIfMCselectV0MotherPDG)
                      lPDG = lNegMother.pdgCode();
                  }
                }
              }
              // end extra PDG of mother check
            }
          }
        }
      }
    } // end association check
    if (lPDG == 310)
      bitset(maskElement, bitTrueK0Short);
    if (lPDG == 3122)
      bitset(maskElement, bitTrueLambda);
    if (lPDG == -3122)
      bitset(maskElement, bitTrueAntiLambda);
    if (lPDG == 22)
      bitset(maskElement, bitTrueGamma);
    if (lPDG == 1010010030)
      bitset(maskElement, bitTrueHypertriton);
    if (lPDG == -1010010030)
      bitset(maskElement, bitTrueAntiHypertriton);
    if (physicalPrimary)
      bitset(maskElement, bitPhysicalPrimary);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  template <class TTrackTo, typename TV0Object>
  void checkdEdx(TV0Object const& lV0Candidate, uint32_t& maskElement)
  {
    auto lNegTrack = lV0Candidate.template negTrack_as<TTrackTo>();
    auto lPosTrack = lV0Candidate.template posTrack_as<TTrackTo>();

    // dEdx check with LF PID
    if (TMath::Abs(lNegTrack.tpcNSigmaEl()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaEl()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxGamma);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxK0Short);
    if ((TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons) &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxLambda);
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        (TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons))
      bitset(maskElement, bitdEdxAntiLambda);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        (TMath::Abs(lPosTrack.tpcNSigmaHe()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons))
      bitset(maskElement, bitdEdxHypertriton);
    if ((TMath::Abs(lNegTrack.tpcNSigmaHe()) < ddEdxPreSelectionWindow || dPreselectOnlyBaryons) &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxAntiHypertriton);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Initialization of mask vectors if uninitialized
  void initializeMasks(int size)
  {
    if (selectionMask.size() < 1) {
      // reserve // FIXME check speed / optimise
      selectionMask.resize(size, 0);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Clear mask vectors
  void resetMasks()
  {
    selectionMask.clear();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// checks and publishes tags if last
  void checkAndFinalize()
  {
    // parse + publish tag table now
    for (std::size_t ii = 0; ii < selectionMask.size(); ii++) {
      histos.fill(HIST("hPreselectorStatistics"), 0.0f); // all V0s
      bool validV0 = bitcheck(selectionMask[ii], bitTrackQuality);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 1.0f); // pass track quality
      }
      if (doprocessBuildMCAssociated || doprocessBuildValiddEdxMCAssociated)
        validV0 = validV0 && ((bitcheck(selectionMask[ii], bitTrueK0Short) && dIfMCgenerateK0Short) ||
                              (bitcheck(selectionMask[ii], bitTrueLambda) && dIfMCgenerateLambda) ||
                              (bitcheck(selectionMask[ii], bitTrueAntiLambda) && dIfMCgenerateAntiLambda) ||
                              (bitcheck(selectionMask[ii], bitTrueGamma) && dIfMCgenerateGamma) ||
                              (bitcheck(selectionMask[ii], bitTrueHypertriton) && dIfMCgenerateHypertriton) ||
                              (bitcheck(selectionMask[ii], bitTrueAntiHypertriton) && dIfMCgenerateAntiHypertriton));
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 2.0f); // pass MC
      }
      if (doprocessBuildValiddEdx || doprocessBuildValiddEdxMCAssociated)
        validV0 = validV0 && ((bitcheck(selectionMask[ii], bitdEdxK0Short) && ddEdxPreSelectK0Short) ||
                              (bitcheck(selectionMask[ii], bitdEdxLambda) && ddEdxPreSelectLambda) ||
                              (bitcheck(selectionMask[ii], bitdEdxAntiLambda) && ddEdxPreSelectAntiLambda) ||
                              (bitcheck(selectionMask[ii], bitdEdxGamma) && ddEdxPreSelectGamma) ||
                              (bitcheck(selectionMask[ii], bitdEdxHypertriton) && ddEdxPreSelectHypertriton) ||
                              (bitcheck(selectionMask[ii], bitdEdxAntiHypertriton) && ddEdxPreSelectAntiHypertriton));
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 3.0f); // pass dEdx
      }
      if (doprocessSkipV0sNotUsedInCascades)
        validV0 = validV0 && bitcheck(selectionMask[ii], bitUsedInCascade);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 4.0f); // pass used in casc
      }
      if (doprocessSkipV0sNotUsedInTrackedCascades)
        validV0 = validV0 && bitcheck(selectionMask[ii], bitUsedInTrackedCascade);
      if (validV0) {
        histos.fill(HIST("hPreselectorStatistics"), 5.0f); // pass used in tracasc
      }
      v0tags(validV0,
             bitcheck(selectionMask[ii], bitTrueGamma), bitcheck(selectionMask[ii], bitTrueK0Short), bitcheck(selectionMask[ii], bitTrueLambda),
             bitcheck(selectionMask[ii], bitTrueAntiLambda),
             bitcheck(selectionMask[ii], bitTrueHypertriton), bitcheck(selectionMask[ii], bitTrueAntiHypertriton), bitcheck(selectionMask[ii], bitPhysicalPrimary),
             bitcheck(selectionMask[ii], bitdEdxGamma), bitcheck(selectionMask[ii], bitdEdxK0Short), bitcheck(selectionMask[ii], bitdEdxLambda),
             bitcheck(selectionMask[ii], bitdEdxAntiLambda), bitcheck(selectionMask[ii], bitdEdxHypertriton), bitcheck(selectionMask[ii], bitdEdxAntiHypertriton),
             bitcheck(selectionMask[ii], bitUsedInCascade), bitcheck(selectionMask[ii], bitUsedInTrackedCascade));
    }
    resetMasks();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all V0s are built. It will simply tag everything as true.
  void processBuildAll(aod::V0s const& v0table, aod::TracksExtra const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkTrackQuality<aod::TracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildMCAssociated(aod::Collisions const& /*collisions*/, aod::V0s const& v0table, LabeledTracksExtra const&, aod::McParticles const& /*particlesMC*/)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkPDG<LabeledTracksExtra>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<LabeledTracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdx(aod::Collisions const& /*collisions*/, aod::V0s const& v0table, TracksExtraWithPID const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkdEdx<TracksExtraWithPID>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<TracksExtraWithPID>(v0, selectionMask[v0.globalIndex()]);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdxMCAssociated(aod::Collisions const& /*collisions*/, aod::V0s const& v0table, TracksExtraWithPIDandLabels const&, aod::McParticles const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkPDG<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
      checkdEdx<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
      checkTrackQuality<TracksExtraWithPIDandLabels>(v0, selectionMask[v0.globalIndex()]);
    }
    if (!doprocessSkipV0sNotUsedInCascades && !doprocessSkipV0sNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all findable V0s are built.
  void processBuildFindable(aod::FindableV0s const& v0table, aod::TracksExtra const&)
  {
    initializeMasks(v0table.size());
    for (auto const& v0 : v0table) {
      checkTrackQuality<aod::TracksExtra>(v0, selectionMask[v0.globalIndex()], true);
    }
    checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of V0s in cascades
  /// They are then marked appropriately; the user could then operate
  /// the lambdakzerobuilder to construct only those V0s.
  void processSkipV0sNotUsedInCascades(aod::Cascades const& casctable)
  {
    for (auto const& casc : casctable) {
      bitset(selectionMask[casc.v0Id()], bitUsedInCascade); // tag V0s needed by cascades
    }
    checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of V0s in strangeness tracked cascades
  /// They are then marked appropriately; the user could then operate
  /// the lambdakzerobuilder to construct only those V0s.
  void processSkipV0sNotUsedInTrackedCascades(aod::TrackedCascades const& tracasctable, aod::Cascades const& /*casctable*/)
  {
    for (auto const& tracasc : tracasctable) {
      auto casc = tracasc.cascade();
      bitset(selectionMask[casc.v0Id()], bitUsedInTrackedCascade); // tag V0s needed by tracked cascades
    }
    checkAndFinalize();
  }
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
  /// basic building options (one of them must be chosen)
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildAll, "Switch to build all V0s", true);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildMCAssociated, "Switch to build MC-associated V0s", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildValiddEdx, "Switch to build V0s with dE/dx preselection", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildValiddEdxMCAssociated, "Switch to build MC-associated V0s with dE/dx preselection", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processBuildFindable, "Switch to build findable V0s. Requires lambdakzeromcfinder", false);
  /// skippers options (choose one in addition to a processBuild if you like)
  PROCESS_SWITCH(lambdakzeroPreselector, processSkipV0sNotUsedInCascades, "skip all V0s not used in cascades", false);
  PROCESS_SWITCH(lambdakzeroPreselector, processSkipV0sNotUsedInTrackedCascades, "skip all V0s not used in tracked cascades", false);
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
};

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct lambdakzeroV0DataLinkBuilder {
  Produces<aod::V0DataLink> v0dataLink;

  void init(InitContext const&) {}

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  // build V0 -> V0Data link table
  void processFound(aod::V0s const& v0table, aod::V0Datas const& v0datatable, aod::V0fCDatas const& v0fcdatatable)
  {
    std::vector<int> lIndices, lfCIndices;
    lIndices.reserve(v0table.size());
    lfCIndices.reserve(v0table.size());
    for (int ii = 0; ii < v0table.size(); ii++) {
      lIndices[ii] = -1;
      lfCIndices[ii] = -1;
    }
    for (auto& v0data : v0datatable) {
      lIndices[v0data.v0Id()] = v0data.globalIndex();
    }
    for (auto& v0fcdata : v0fcdatatable) {
      lfCIndices[v0fcdata.v0Id()] = v0fcdata.globalIndex();
    }
    for (int ii = 0; ii < v0table.size(); ii++) {
      v0dataLink(lIndices[ii], lfCIndices[ii]);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  // build V0Findable -> V0Data link table
  void processFindable(aod::FindableV0s const& v0table, aod::V0Datas const& v0datatable)
  {
    std::vector<int> lIndices;
    lIndices.reserve(v0table.size());
    for (int ii = 0; ii < v0table.size(); ii++) {
      lIndices[ii] = -1;
    }
    for (auto& v0data : v0datatable) {
      lIndices[v0data.v0Id()] = v0data.globalIndex();
    }
    for (int ii = 0; ii < v0table.size(); ii++) {
      v0dataLink(lIndices[ii], -1);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  PROCESS_SWITCH(lambdakzeroV0DataLinkBuilder, processFound, "process found V0s (default)", true);
  PROCESS_SWITCH(lambdakzeroV0DataLinkBuilder, processFindable, "process findable V0s", false);
};

// Extends the v0data table with expression columns
struct lambdakzeroInitializer {
  Spawns<aod::V0Cores> v0cores;
  Spawns<aod::V0fCCores> v0fccores;
  void init(InitContext const&) {}
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<lambdakzeroBuilder>(cfgc),
    adaptAnalysisTask<lambdakzeroPreselector>(cfgc),
    adaptAnalysisTask<lambdakzeroV0DataLinkBuilder>(cfgc),
    adaptAnalysisTask<lambdakzeroInitializer>(cfgc)};
}
