// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
//
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//  Cascade builder task
//  *+-+*+-+*+-+*+-+*+-+*+-+*
//
//  This task loops over a set of cascade indices and
//  creates the corresponding analysis tables that contain
//  the typical information required for analysis.
//
//  PERFORMANCE WARNING: this task includes several track
//  propagation calls that are intrinsically heavy. Please
//  also be cautious when adjusting selections: these can
//  increase / decrease CPU consumption quite significantly.
//
//  IDEAL USAGE: if you are interested in taking V0s and
//  cascades and propagating TrackParCovs based on these,
//  please do not re-propagate the daughters. Instead,
//  the tables generated by this builder task can be used
//  to instantiate a TrackPar object (default operation)
//  or even a TrackParCov object (for which you will
//  need to enable the option of producing the V0Cov and
//  CascCov tables too).
//
//    Comments, questions, complaints, suggestions?
//    Please write to:
//    david.dobrigkeit.chinellato@cern.ch
//

#include <string>
#include <vector>
#include <cmath>
#include <array>
#include <cstdlib>
#include <map>
#include <iterator>
#include <utility>
#include <string>
#include <vector>

#include "Framework/runDataProcessing.h"
#include "Framework/RunningWorkflowInfo.h"
#include "Framework/AnalysisTask.h"
#include "Framework/AnalysisDataModel.h"
#include "Framework/ASoAHelpers.h"
#include "DCAFitter/DCAFitterN.h"
#include "ReconstructionDataFormats/Track.h"
#include "Common/Core/RecoDecay.h"
#include "Common/Core/trackUtilities.h"
#include "PWGLF/DataModel/LFStrangenessTables.h"
#include "PWGLF/DataModel/LFStrangenessMLTables.h"
#include "PWGLF/DataModel/LFParticleIdentification.h"
#include "Common/Core/TrackSelection.h"
#include "Common/DataModel/TrackSelectionTables.h"
#include "DetectorsBase/Propagator.h"
#include "DetectorsBase/GeometryManager.h"
#include "DataFormatsParameters/GRPObject.h"
#include "DataFormatsParameters/GRPMagField.h"
#include "CCDB/BasicCCDBManager.h"
#include "Tools/ML/MlResponse.h"
#include "Tools/ML/model.h"

#ifndef HomogeneousField
#define HomogeneousField
#endif

/// includes KFParticle
#include "KFParticle.h"
#include "KFPTrack.h"
#include "KFPVertex.h"
#include "KFParticleBase.h"
#include "KFVertex.h"

using namespace o2;
using namespace o2::framework;
using namespace o2::framework::expressions;
using std::array;

// simple checkers
#define bitset(var, nbit) ((var) |= (1 << (nbit)))
#define bitcheck(var, nbit) ((var) & (1 << (nbit)))

// use parameters + cov mat non-propagated, aux info + (extension propagated)
using FullTracksExt = soa::Join<aod::Tracks, aod::TracksExtra, aod::TracksCov>;
using FullTracksExtIU = soa::Join<aod::TracksIU, aod::TracksExtra, aod::TracksCovIU>;
using TracksWithExtra = soa::Join<aod::Tracks, aod::TracksExtra>; // generally always need DCA, will have Tracks too

// For dE/dx association in pre-selection
using TracksExtraWithPID = soa::Join<aod::TracksExtra, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullKa>;

// For MC and dE/dx association
using TracksExtraWithPIDandLabels = soa::Join<aod::TracksExtra, aod::pidTPCFullPi, aod::pidTPCFullPr, aod::pidTPCFullKa, aod::McTrackLabels>;

// Pre-selected V0s
using V0full = soa::Join<aod::V0Datas, aod::V0Covs>;
using V0fCfull = soa::Join<aod::V0fCDatas, aod::V0fCCovs>;
using TaggedCascades = soa::Join<aod::Cascades, aod::CascTags>;
using TaggedFindableCascades = soa::Join<aod::FindableCascades, aod::CascTags>;

// For MC association in pre-selection
using LabeledTracksExtra = soa::Join<aod::TracksExtra, aod::McTrackLabels>;

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
// Builder task: rebuilds multi-strange candidates
struct cascadeBuilder {
  o2::ml::OnnxModel mlModelXiMinus;
  o2::ml::OnnxModel mlModelXiPlus;
  o2::ml::OnnxModel mlModelOmegaMinus;
  o2::ml::OnnxModel mlModelOmegaPlus;

  std::map<std::string, std::string> metadata;

  Produces<aod::CascIndices> cascidx;
  Produces<aod::KFCascIndices> kfcascidx;
  Produces<aod::TraCascIndices> trackedcascidx;
  Produces<aod::StoredCascCores> cascdata;
  Produces<aod::StoredKFCascCores> kfcascdata;
  Produces<aod::StoredTraCascCores> trackedcascdata;
  Produces<aod::CascTrackXs> cascTrackXs; // if desired for replaying of position information
  Produces<aod::CascBBs> cascbb;          // if enabled
  Produces<aod::CascCovs> casccovs;       // if requested by someone
  Produces<aod::TraCascCovs> tracasccovs; // if requested by someone
  Produces<aod::KFCascCovs> kfcasccovs;   // if requested by someone

  // produces calls for machine-learning selections
  Produces<aod::CascXiMLScores> xiMLSelections;    // Xi scores
  Produces<aod::CascOmMLScores> omegaMLSelections; // Omega scores

  o2::ccdb::CcdbApi ccdbApi;
  Service<o2::ccdb::BasicCCDBManager> ccdb;

  Configurable<bool> d_UseAutodetectMode{"d_UseAutodetectMode", false, "Autodetect requested topo sels"};

  // Configurables related to table creation
  Configurable<int> createCascCovMats{"createCascCovMats", -1, {"Produces casc cov matrices. -1: auto, 0: don't, 1: yes. Default: auto (-1)"}};
  Configurable<int> createCascTrackXs{"createCascTrackXs", -1, {"Produces track X at minima table. -1: auto, 0: don't, 1: yes. Default: auto (-1)"}};

  // Topological selection criteria
  Configurable<int> tpcrefit{"tpcrefit", 0, "demand TPC refit"};
  Configurable<float> dcabachtopv{"dcabachtopv", .05, "DCA Bach To PV"};
  Configurable<float> cascradius{"cascradius", 0.9, "cascradius"};
  Configurable<float> casccospa{"casccospa", 0.95, "casccospa"};
  Configurable<float> dcacascdau{"dcacascdau", 1.0, "DCA cascade Daughters"};
  Configurable<float> lambdaMassWindow{"lambdaMassWindow", .01, "Distance from Lambda mass"};
  Configurable<float> dcaXYCascToPV{"dcaXYCascToPV", 1e+6, "dcaXYCascToPV"};
  Configurable<float> dcaZCascToPV{"dcaZCascToPV", 1e+6, "dcaZCascToPV"};
  Configurable<bool> d_doPtDep_CosPaCut{"d_doPtDep_CosPaCut", false, "Enable pt dependent cos PA cut"};
  Configurable<float> cas_cospaParameter{"cas_cospaParameter", 0.341715, "Parameter for pt dependent cos PA cut"};

  // Operation and minimisation criteria
  Configurable<double> d_bz_input{"d_bz", -999, "bz field, -999 is automatic"};
  Configurable<bool> d_UseAbsDCA{"d_UseAbsDCA", true, "Use Abs DCAs"};
  Configurable<bool> d_UseWeightedPCA{"d_UseWeightedPCA", false, "Vertices use cov matrices"};
  Configurable<int> useMatCorrType{"useMatCorrType", 2, "0: none, 1: TGeo, 2: LUT"};
  Configurable<int> useMatCorrTypeCasc{"useMatCorrTypeCasc", 2, "0: none, 1: TGeo, 2: LUT"};
  Configurable<int> rejDiffCollTracks{"rejDiffCollTracks", 0, "rejDiffCollTracks"};
  Configurable<bool> d_doTrackQA{"d_doTrackQA", false, "do track QA"};
  Configurable<bool> d_doStraTrackQA{"d_doStraTrackQA", false, "do strangeness tracking QA"};
  Configurable<bool> d_GenerateOnlyTrackedCascades{"d_GenerateOnlyTrackedCascades", false, "Skip cascades that aren't tracked"};
  Configurable<bool> d_QA_checkMC{"d_QA_checkMC", true, "check MC truth in QA"};
  Configurable<bool> d_QA_checkdEdx{"d_QA_checkdEdx", false, "check dEdx in QA"};
  Configurable<bool> calculateBachBaryonVars{"calculateBachBaryonVars", false, "calculate variables for removing cascade inv mass bump"};

  // CCDB options
  struct : ConfigurableGroup {
    Configurable<std::string> ccdburl{"ccdb-url", "http://alice-ccdb.cern.ch", "url of the ccdb repository"};
    Configurable<std::string> grpPath{"grpPath", "GLO/GRP/GRP", "Path of the grp file"};
    Configurable<std::string> grpmagPath{"grpmagPath", "GLO/Config/GRPMagField", "CCDB path of the GRPMagField object"};
    Configurable<std::string> lutPath{"lutPath", "GLO/Param/MatLUT", "Path of the Lut parametrization"};
    Configurable<std::string> geoPath{"geoPath", "GLO/Config/GeometryAligned", "Path of the geometry file"};
  } ccdbConfigurations;

  // generate and fill extra QA histograms if requested
  struct : ConfigurableGroup {
    Configurable<bool> d_doQA{"qaConfigurations.d_doQA", false, "Do basic QA"};
    Configurable<int> dQANBinsRadius{"qaConfigurations.dQANBinsRadius", 500, "Number of radius bins in QA histo"};
    Configurable<int> dQANBinsPtCoarse{"qaConfigurations.dQANBinsPtCoarse", 10, "Number of pT bins in QA histo"};
    Configurable<int> dQANBinsMass{"qaConfigurations.dQANBinsMass", 400, "Number of mass bins for QA histograms"};
    Configurable<int> dQANBinsDCAxy{"qaConfigurations.dQANBinsDCAxy", 200, "DCAxy of cascade to PV Nbins"};
    Configurable<int> dQANBinsChi2{"qaConfigurations.dQANBinsChi2", 200, "Chi2 Nbins"};
    Configurable<int> dQANBinsCluSize{"qaConfigurations.dQANBinsCluSize", 200, "Cluster size Nbins"};
    Configurable<float> dQAMaxPt{"qaConfigurations.dQAMaxPt", 5, "max pT in QA histo"};
    Configurable<float> dQAMaxDCA{"qaConfigurations.dQAMaxDCA", 1, "max DCAxy QA histo"};
    Configurable<float> dQAMaxChi2{"qaConfigurations.dQAMaxChi2", 20, "max chi2"};
    Configurable<float> dQAMaxCluSize{"qaConfigurations.dQAMaxCluSize", 10, "max ITS clu size"};
    Configurable<float> dQAXiMassWindow{"qaConfigurations.dQAXiMassWindow", 0.005, "Xi mass window for ITS cluster map QA"};
    Configurable<float> dQAOmegaMassWindow{"qaConfigurations.dQAOmegaMassWindow", 0.005, "Omega mass window for ITS cluster map QA"};
  } qaConfigurations;

  // for KF particle operation
  Configurable<bool> kfTuneForOmega{"kfTuneForOmega", false, "if enabled, take main cascade properties from Omega fit instead of Xi fit (= default)"};
  Configurable<int> kfConstructMethod{"kfConstructMethod", 2, "KF Construct Method"};
  Configurable<bool> kfUseV0MassConstraint{"kfUseV0MassConstraint", true, "KF: use Lambda mass constraint"};
  Configurable<bool> kfUseCascadeMassConstraint{"kfUseCascadeMassConstraint", false, "KF: use Cascade mass constraint - WARNING: not adequate for inv mass analysis of Xi"};
  Configurable<bool> kfDoDCAFitterPreMinimV0{"kfDoDCAFitterPreMinimV0", true, "KF: do DCAFitter pre-optimization before KF fit to include material corrections for V0"};
  Configurable<bool> kfDoDCAFitterPreMinimCasc{"kfDoDCAFitterPreMinimCasc", true, "KF: do DCAFitter pre-optimization before KF fit to include material corrections for Xi"};

  // for using cascade momentum at prim. vtx
  Configurable<bool> useCascadeMomentumAtPrimVtx{"useCascadeMomentumAtPrimVtx", false, "if enabled, store cascade momentum at prim. vtx instead of decay point (= default)"};
  // for topo var QA
  struct : ConfigurableGroup {
    ConfigurableAxis axisTopoVarPointingAngle{"axisConfigurations.axisTopoVarPointingAngle", {50, 0.0, 1.0}, "pointing angle"};
    ConfigurableAxis axisTopoVarRAP{"axisConfigurations.axisTopoVarRAP", {50, 0.0, 1.0}, "radius x pointing angle axis"};
    ConfigurableAxis axisTopoVarV0Radius{"axisConfigurations.axisTopoVarV0Radius", {500, 0.0, 100.0}, "V0 decay radius (cm)"};
    ConfigurableAxis axisTopoVarDCAV0Dau{"axisConfigurations.axisTopoVarDCAV0Dau", {200, 0.0, 2.0}, "DCA between V0 daughters (cm)"};
    ConfigurableAxis axisTopoVarDCAToPV{"axisConfigurations.axisTopoVarDCAToPV", {200, -1, 1.0}, "single track DCA to PV (cm)"};
    ConfigurableAxis axisTopoVarDCAV0ToPV{"axisConfigurations.axisTopoVarDCAV0ToPV", {200, 0, 5.0}, "V0 DCA to PV (cm)"};
    ConfigurableAxis axisPtQA{"axisPtQA", {VARIABLE_WIDTH, 0.0f, 0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f, 0.8f, 0.9f, 1.0f, 1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f, 1.8f, 1.9f, 2.0f, 2.2f, 2.4f, 2.6f, 2.8f, 3.0f, 3.2f, 3.4f, 3.6f, 3.8f, 4.0f, 4.4f, 4.8f, 5.2f, 5.6f, 6.0f, 6.5f, 7.0f, 7.5f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, 13.0f, 14.0f, 15.0f, 17.0f, 19.0f, 21.0f, 23.0f, 25.0f, 30.0f, 35.0f, 40.0f, 50.0f}, "pt axis for QA histograms"};
  } axisConfigurations;

  // Machine learning evaluation for pre-selection and corresponding information generation
  struct : ConfigurableGroup {
    // ML classifiers: master flags to populate ML Selection tables
    Configurable<bool> calculateXiMinusScores{"mlConfigurations.calculateXiMinusScores", false, "calculate XiMinus ML scores"};
    Configurable<bool> calculateXiPlusScores{"mlConfigurations.calculateXiPlusScores", false, "calculate XiPlus ML scores"};
    Configurable<bool> calculateOmegaMinusScores{"mlConfigurations.calculateOmegaMinusScores", false, "calculate OmegaMinus ML scores"};
    Configurable<bool> calculateOmegaPlusScores{"mlConfigurations.calculateOmegaPlusScores", false, "calculate OmegaPlus ML scores"};

    // ML input for ML calculation
    Configurable<std::string> modelPathCCDB{"mlConfigurations.modelPathCCDB", "", "ML Model path in CCDB"};
    Configurable<int64_t> timestampCCDB{"mlConfigurations.timestampCCDB", -1, "timestamp of the ONNX file for ML model used to query in CCDB.  Exceptions: > 0 for the specific timestamp, 0 gets the run dependent timestamp"};
    Configurable<bool> loadModelsFromCCDB{"mlConfigurations.loadModelsFromCCDB", false, "Flag to enable or disable the loading of models from CCDB"};
    Configurable<bool> enableOptimizations{"mlConfigurations.enableOptimizations", false, "Enables the ONNX extended model-optimization: sessionOptions.SetGraphOptimizationLevel(GraphOptimizationLevel::ORT_ENABLE_EXTENDED)"};

    // Local paths for test purposes
    Configurable<std::string> localModelPathXiMinus{"mlConfigurations.localModelPathXiMinus", "XiMinus_BDTModel.onnx", "(std::string) Path to the local .onnx file."};
    Configurable<std::string> localModelPathXiPlus{"mlConfigurations.localModelPathXiPlus", "XiPlus_BDTModel.onnx", "(std::string) Path to the local .onnx file."};
    Configurable<std::string> localModelPathOmegaMinus{"mlConfigurations.localModelPathOmegaMinus", "OmegaMinus_BDTModel.onnx", "(std::string) Path to the local .onnx file."};
    Configurable<std::string> localModelPathOmegaPlus{"mlConfigurations.localModelPathOmegaPlus", "OmegaPlus_BDTModel.onnx", "(std::string) Path to the local .onnx file."};

    // Thresholds for choosing to populate V0Cores tables with pre-selections
    Configurable<float> thresholdXiMinus{"mlConfigurations.thresholdXiMinus", -1.0f, "Threshold to keep XiMinus candidates"};
    Configurable<float> thresholdXiPlus{"mlConfigurations.thresholdXiPlus", -1.0f, "Threshold to keep XiPlus candidates"};
    Configurable<float> thresholdOmegaMinus{"mlConfigurations.thresholdOmegaMinus", -1.0f, "Threshold to keep OmegaMinus candidates"};
    Configurable<float> thresholdOmegaPlus{"mlConfigurations.thresholdOmegaPlus", -1.0f, "Threshold to keep OmegaPlus candidates"};
  } mlConfigurations;

  // round some V0 core variables up to a certain level of precision if requested
  // useful to keep derived data sizes under control
  // variables that are rounded include the DCAs but not the CosPA (precision needed)
  Configurable<bool> roundDCAVariables{"roundDCAVariables", false, "round topological variables"};
  Configurable<float> precisionDCAs{"precisionDCAs", 0.01f, "precision to keep the DCAs with"};

  Configurable<float> maxDaughterEta{"maxDaughterEta", 5.0, "Maximum daughter eta"};

  int mRunNumber;
  float d_bz;
  float maxSnp;  // max sine phi for propagation
  float maxStep; // max step size (cm) for propagation
  o2::base::MatLayerCylSet* lut = nullptr;
  o2::base::Propagator::MatCorrType matCorr;
  o2::base::Propagator::MatCorrType matCorrCascade;

  Filter taggedFilter = aod::casctag::isInteresting == true;

  // For manual sliceBy
  Preslice<aod::Cascades> perCollision = o2::aod::cascade::collisionId;
  Preslice<aod::FindableCascades> perCollisionFindable = o2::aod::cascade::collisionId;
  Preslice<aod::TrackedCascades> perCascade = o2::aod::strangenesstracking::cascadeId;

  // Define o2 fitter, 2-prong, active memory (no need to redefine per event)
  o2::vertexing::DCAFitterN<2> fitter;
  enum cascstep { kCascAll = 0,
                  kCascHasV0Data,
                  kCascLambdaMass,
                  kBachTPCrefit,
                  kBachDCAxy,
                  kCascDCADau,
                  kCascCosPA,
                  kCascRadius,
                  kCascDauEta,
                  kCascTracked,
                  kNCascSteps };

  // Helper struct to pass cascade information
  struct {
    int v0Id;
    int positiveId;
    int negativeId;
    int bachelorId;
    float positiveX;
    float negativeX;
    float bachelorX;
    int charge;
    std::array<float, 3> pos;
    std::array<float, 3> bachP;
    float dcacascdau;
    float bachDCAxy;
    float cosPA;
    float cascradius;
    float cascDCAxy; // cascade DCA xy (with bending)
    float cascDCAz;  // cascade DCA z
    std::array<float, 3> v0pos;
    std::array<float, 3> v0mompos;
    std::array<float, 3> v0momneg;
    std::array<float, 3> v0pospos;
    std::array<float, 3> v0posneg;
    std::array<float, 3> cascademom;
    std::array<float, 3> kfv0mom;
    float v0dcadau;
    float v0dcapostopv;
    float v0dcanegtopv;
    float mXi;
    float mOmega;
    float yXi;
    float yOmega;
    float bachBaryonCosPA;
    float bachBaryonDCAxyToPV;
    float kfMLambda;
    float kfV0Chi2;
    float kfCascadeChi2;
    std::array<float, 21> kfCascadeCov;
    std::array<float, 21> kfV0Cov;
    std::array<float, 21> kfV0DauPosCov;
    std::array<float, 21> kfV0DauNegCov;
    float mlXiMinusScore;
    float mlXiPlusScore;
    float mlOmegaMinusScore;
    float mlOmegaPlusScore;
  } cascadecandidate;

  o2::track::TrackParCov lBachelorTrack;
  o2::track::TrackParCov lV0Track;
  o2::track::TrackParCov lCascadeTrack;

  // Helper struct to do bookkeeping of building parameters
  struct {
    std::array<int32_t, kNCascSteps> cascstats;
    std::array<int32_t, 10> posITSclu;
    std::array<int32_t, 10> negITSclu;
    std::array<int32_t, 10> bachITSclu;
    int32_t exceptions;
    int32_t eventCounter;
  } statisticsRegistry;

  HistogramRegistry registry{
    "registry",
    {{"hEventCounter", "hEventCounter", {HistType::kTH1D, {{1, 0.0f, 1.0f}}}},
     {"hCaughtExceptions", "hCaughtExceptions", {HistType::kTH1D, {{1, 0.0f, 1.0f}}}},
     {"hPositiveITSClusters", "hPositiveITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}},
     {"hNegativeITSClusters", "hNegativeITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}},
     {"hBachelorITSClusters", "hBachelorITSClusters", {HistType::kTH1D, {{10, -0.5f, 9.5f}}}}}};

  float roundToPrecision(float number, float step = 0.01)
  {
    // this function rounds a certain number in an axis that is quantized by
    // the variable 'step'; the rounded number is placed halfway between
    // n*step and (n+1)*step such that analysis can be done with absolutely
    // no issue with precision 'step'.
    return step * static_cast<float>(static_cast<int>((number) / step)) + TMath::Sign(1.0f, number) * (0.5f) * step;
  }

  void roundCascadeCandidateVariables()
  {
    // Do not round actual cascade (pseudo-)track DCAs -> consider they may be tracked, high precision
    cascadecandidate.dcacascdau = roundToPrecision(cascadecandidate.dcacascdau, precisionDCAs);
    cascadecandidate.v0dcadau = roundToPrecision(cascadecandidate.v0dcadau, precisionDCAs);
    cascadecandidate.v0dcanegtopv = roundToPrecision(cascadecandidate.v0dcanegtopv, precisionDCAs);
    cascadecandidate.v0dcapostopv = roundToPrecision(cascadecandidate.v0dcapostopv, precisionDCAs);
    cascadecandidate.bachDCAxy = roundToPrecision(cascadecandidate.bachDCAxy, precisionDCAs);
  }

  void resetHistos()
  {
    statisticsRegistry.exceptions = 0;
    statisticsRegistry.eventCounter = 0;
    for (Int_t ii = 0; ii < kNCascSteps; ii++)
      statisticsRegistry.cascstats[ii] = 0;
    for (Int_t ii = 0; ii < 10; ii++) {
      statisticsRegistry.posITSclu[ii] = 0;
      statisticsRegistry.negITSclu[ii] = 0;
      statisticsRegistry.bachITSclu[ii] = 0;
    }
  }

  void fillHistos()
  {
    registry.fill(HIST("hEventCounter"), 0.0, statisticsRegistry.eventCounter);
    registry.fill(HIST("hCaughtExceptions"), 0.0, statisticsRegistry.exceptions);
    for (Int_t ii = 0; ii < kNCascSteps; ii++)
      registry.fill(HIST("hCascadeCriteria"), ii, statisticsRegistry.cascstats[ii]);
    if (d_doTrackQA) {
      for (Int_t ii = 0; ii < 10; ii++) {
        registry.fill(HIST("hPositiveITSClusters"), ii, statisticsRegistry.posITSclu[ii]);
        registry.fill(HIST("hNegativeITSClusters"), ii, statisticsRegistry.negITSclu[ii]);
        registry.fill(HIST("hBachelorITSClusters"), ii, statisticsRegistry.bachITSclu[ii]);
      }
    }
  }

  void init(InitContext& context)
  {
    resetHistos();
    registry.add("hKFParticleStatistics", "hKFParticleStatistics", kTH1F, {{10, -0.5f, 9.5f}});

    auto h = registry.add<TH1>("hCascadeCriteria", "hCascadeCriteria", kTH1D, {{10, -0.5f, 9.5f}});
    h->GetXaxis()->SetBinLabel(1, "All sel");
    h->GetXaxis()->SetBinLabel(2, "has V0Data");
    h->GetXaxis()->SetBinLabel(3, "Lam mass");
    h->GetXaxis()->SetBinLabel(4, "TPC refit");
    h->GetXaxis()->SetBinLabel(5, "track DCAxy");
    h->GetXaxis()->SetBinLabel(6, "DCA dau");
    h->GetXaxis()->SetBinLabel(7, "CosPA");
    h->GetXaxis()->SetBinLabel(8, "Radius");
    h->GetXaxis()->SetBinLabel(9, "Pass dau eta");
    h->GetXaxis()->SetBinLabel(10, "Tracked");

    // Optionally, add extra QA histograms to processing chain
    if (qaConfigurations.d_doQA) {
      // Basic histograms containing invariant masses of all built candidates
      const AxisSpec axisVsPtCoarse{static_cast<int>(qaConfigurations.dQANBinsPtCoarse), 0, qaConfigurations.dQAMaxPt, "#it{p}_{T} (GeV/c)"};
      const AxisSpec axisLamMass{static_cast<int>(qaConfigurations.dQANBinsMass), 1.075f, 1.275f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisXiMass{static_cast<int>(qaConfigurations.dQANBinsMass), 1.222f, 1.422f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisOmegaMass{static_cast<int>(qaConfigurations.dQANBinsMass), 1.572f, 1.772f, "Inv. Mass (GeV/c^{2})"};
      const AxisSpec axisCascadeDCAtoPV{static_cast<int>(qaConfigurations.dQANBinsDCAxy), -qaConfigurations.dQAMaxDCA, qaConfigurations.dQAMaxDCA, "DCA_{xy} (cm)"};

      registry.add("h2dLambdaMass", "h2dLambdaMass", kTH2F, {axisConfigurations.axisPtQA, axisLamMass});
      registry.add("h2dAntiLambdaMass", "h2dAntiLambdaMass", kTH2F, {axisConfigurations.axisPtQA, axisLamMass});
      registry.add("MassHistograms/h2dXiMinusMass", "h2dXiMinusMass", kTH2F, {axisConfigurations.axisPtQA, axisXiMass});
      registry.add("MassHistograms/h2dXiPlusMass", "h2dXiPlusMass", kTH2F, {axisConfigurations.axisPtQA, axisXiMass});
      registry.add("MassHistograms/h2dOmegaMinusMass", "h2dOmegaMinusMass", kTH2F, {axisConfigurations.axisPtQA, axisOmegaMass});
      registry.add("MassHistograms/h2dOmegaPlusMass", "h2dOmegaPlusMass", kTH2F, {axisConfigurations.axisPtQA, axisOmegaMass});

      if (d_doPtDep_CosPaCut)
        registry.addClone("MassHistograms/", "MassHistograms_BefPAcut/");

      // bit packed ITS cluster map
      const AxisSpec axisITSCluMap{static_cast<int>(128), -0.5f, +127.5f, "Packed ITS map"};
      const AxisSpec axisRadius{static_cast<int>(qaConfigurations.dQANBinsRadius), 0.0f, +50.0f, "Radius (cm)"};

      // Histogram to bookkeep cluster maps
      registry.add("h2dITSCluMap_XiMinusPositive", "h2dITSCluMap_XiMinusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiMinusNegative", "h2dITSCluMap_XiMinusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiMinusBachelor", "h2dITSCluMap_XiMinusBachelor", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiPlusPositive", "h2dITSCluMap_XiPlusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiPlusNegative", "h2dITSCluMap_XiPlusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_XiPlusBachelor", "h2dITSCluMap_XiPlusBachelor", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaMinusPositive", "h2dITSCluMap_OmegaMinusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaMinusNegative", "h2dITSCluMap_OmegaMinusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaMinusBachelor", "h2dITSCluMap_OmegaMinusBachelor", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaPlusPositive", "h2dITSCluMap_OmegaPlusPositive", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaPlusNegative", "h2dITSCluMap_OmegaPlusNegative", kTH2D, {axisITSCluMap, axisRadius});
      registry.add("h2dITSCluMap_OmegaPlusBachelor", "h2dITSCluMap_OmegaPlusBachelor", kTH2D, {axisITSCluMap, axisRadius});

      // QA plots of topological variables using axisPtQA
      registry.add("h2dTopoVarCascPointingAngle", "h2dTopoVarCascPointingAngle", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarPointingAngle});
      registry.add("h2dTopoVarCascRAP", "h2dTopoVarCascRAP", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarRAP});
      registry.add("h2dTopoVarCascRadius", "h2dTopoVarCascRadius", kTH2D, {axisConfigurations.axisPtQA, axisConfigurations.axisTopoVarV0Radius});

      // if basic strangeness tracking QA is desired, do it here
      // convenience: equivalence between regular cascade and tracked cascade is easy to check here
      //              -> completely automatic, easy comparison of 'trackable' candidates (<< all)

      if (d_doStraTrackQA) {
        // Radius QA
        registry.add("hRadius_XiMinus_All", "hRadius_XiMinus_All", kTH1D, {axisRadius});
        registry.add("hRadius_XiPlus_All", "hRadius_XiPlus_All", kTH1D, {axisRadius});
        registry.add("hRadius_OmegaMinus_All", "hRadius_OmegaMinus_All", kTH1D, {axisRadius});
        registry.add("hRadius_OmegaPlus_All", "hRadius_OmegaPlus_All", kTH1D, {axisRadius});
        registry.add("hRadius_XiMinus_Tracked", "hRadius_XiMinus_Tracked", kTH1D, {axisRadius});
        registry.add("hRadius_XiPlus_Tracked", "hRadius_XiPlus_Tracked", kTH1D, {axisRadius});
        registry.add("hRadius_OmegaMinus_Tracked", "hRadius_OmegaMinus_Tracked", kTH1D, {axisRadius});
        registry.add("hRadius_OmegaPlus_Tracked", "hRadius_OmegaPlus_Tracked", kTH1D, {axisRadius});

        // Step 1: mass versus transverse momentum, original variety (given it was tracked)
        registry.add("h2dTrackableXiMinusMass", "h2dTrackableXiMinusMass", kTH2F, {axisVsPtCoarse, axisXiMass});
        registry.add("h2dTrackableXiPlusMass", "h2dTrackableXiPlusMass", kTH2F, {axisVsPtCoarse, axisXiMass});
        registry.add("h2dTrackableOmegaMinusMass", "h2dTrackableOmegaMinusMass", kTH2F, {axisVsPtCoarse, axisOmegaMass});
        registry.add("h2dTrackableOmegaPlusMass", "h2dTrackableOmegaPlusMass", kTH2F, {axisVsPtCoarse, axisOmegaMass});
        registry.add("h2dTrackedXiMinusMass", "h2dTrackedXiMinusMass", kTH2F, {axisVsPtCoarse, axisXiMass});
        registry.add("h2dTrackedXiPlusMass", "h2dTrackedXiPlusMass", kTH2F, {axisVsPtCoarse, axisXiMass});
        registry.add("h2dTrackedOmegaMinusMass", "h2dTrackedOmegaMinusMass", kTH2F, {axisVsPtCoarse, axisOmegaMass});
        registry.add("h2dTrackedOmegaPlusMass", "h2dTrackedOmegaPlusMass", kTH2F, {axisVsPtCoarse, axisOmegaMass});

        // Step 2: DCA, original variety (all) / trackable / tracked
        registry.add("hDCACascadeToPVXiMinus", "hDCACascadeToPVXiMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCACascadeToPVXiPlus", "hDCACascadeToPVXiPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCACascadeToPVOmegaMinus", "hDCACascadeToPVOmegaMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCACascadeToPVOmegaPlus", "hDCACascadeToPVOmegaPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackableCascadeToPVXiMinus", "hDCATrackableCascadeToPVXiMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackableCascadeToPVXiPlus", "hDCATrackableCascadeToPVXiPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackableCascadeToPVOmegaMinus", "hDCATrackableCascadeToPVOmegaMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackableCascadeToPVOmegaPlus", "hDCATrackableCascadeToPVOmegaPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackedCascadeToPVXiMinus", "hDCATrackedCascadeToPVXiMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackedCascadeToPVXiPlus", "hDCATrackedCascadeToPVXiPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackedCascadeToPVOmegaMinus", "hDCATrackedCascadeToPVOmegaMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCATrackedCascadeToPVOmegaPlus", "hDCATrackedCascadeToPVOmegaPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});

        registry.add("hDCAzCascadeToPVXiMinus", "hDCAzCascadeToPVXiMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzCascadeToPVXiPlus", "hDCAzCascadeToPVXiPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzCascadeToPVOmegaMinus", "hDCAzCascadeToPVOmegaMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzCascadeToPVOmegaPlus", "hDCAzCascadeToPVOmegaPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackableCascadeToPVXiMinus", "hDCAzTrackableCascadeToPVXiMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackableCascadeToPVXiPlus", "hDCAzTrackableCascadeToPVXiPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackableCascadeToPVOmegaMinus", "hDCAzTrackableCascadeToPVOmegaMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackableCascadeToPVOmegaPlus", "hDCAzTrackableCascadeToPVOmegaPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackedCascadeToPVXiMinus", "hDCAzTrackedCascadeToPVXiMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackedCascadeToPVXiPlus", "hDCAzTrackedCascadeToPVXiPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackedCascadeToPVOmegaMinus", "hDCAzTrackedCascadeToPVOmegaMinus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});
        registry.add("hDCAzTrackedCascadeToPVOmegaPlus", "hDCAzTrackedCascadeToPVOmegaPlus", kTH2F, {axisVsPtCoarse, axisCascadeDCAtoPV});

        // specific variables associated to strangeness tracking
        const AxisSpec axisChi2{static_cast<int>(qaConfigurations.dQANBinsChi2), 0.0f, qaConfigurations.dQAMaxChi2, "#chi^{2}"};
        const AxisSpec axisCluSize{static_cast<int>(qaConfigurations.dQANBinsCluSize), 0.0f, qaConfigurations.dQAMaxCluSize, "Mean ITS cluster size"};
        registry.add("hMatchingChi2_XiMinus", "hMatchingChi2_XiMinus", kTH1D, {axisChi2});
        registry.add("hMatchingChi2_XiPlus", "hMatchingChi2_XiPlus", kTH1D, {axisChi2});
        registry.add("hMatchingChi2_OmegaMinus", "hMatchingChi2_OmegaMinus", kTH1D, {axisChi2});
        registry.add("hMatchingChi2_OmegaPlus", "hMatchingChi2_OmegaPlus", kTH1D, {axisChi2});
        registry.add("hTopologyChi2_XiMinus", "hTopologyChi2_XiMinus", kTH1D, {axisChi2});
        registry.add("hTopologyChi2_XiPlus", "hTopologyChi2_XiPlus", kTH1D, {axisChi2});
        registry.add("hTopologyChi2_OmegaMinus", "hTopologyChi2_OmegaMinus", kTH1D, {axisChi2});
        registry.add("hTopologyChi2_OmegaPlus", "hTopologyChi2_OmegaPlus", kTH1D, {axisChi2});
        registry.add("hCluSize_XiMinus", "hCluSize_XiMinus", kTH1D, {axisCluSize});
        registry.add("hCluSize_XiPlus", "hCluSize_XiPlus", kTH1D, {axisCluSize});
        registry.add("hCluSize_OmegaMinus", "hCluSize_OmegaMinus", kTH1D, {axisCluSize});
        registry.add("hCluSize_OmegaPlus", "hCluSize_OmegaPlus", kTH1D, {axisCluSize});
      }
    }

    mRunNumber = 0;
    d_bz = 0;
    maxSnp = 0.85f;  // could be changed later
    maxStep = 2.00f; // could be changed later

    ccdb->setURL(ccdbConfigurations.ccdburl);
    ccdb->setCaching(true);
    ccdb->setLocalObjectValidityChecking();
    ccdb->setFatalWhenNull(false);

    if (useMatCorrType == 1) {
      LOGF(info, "TGeo correction requested, loading geometry");
      if (!o2::base::GeometryManager::isGeometryLoaded()) {
        ccdb->get<TGeoManager>(ccdbConfigurations.geoPath);
      }
    }
    if (useMatCorrType == 2) {
      LOGF(info, "LUT correction requested, will load LUT when initializing with timestamp...");
    }

    if (doprocessRun2 == false && doprocessRun3 == false && doprocessRun3withStrangenessTracking == false && doprocessRun3withKFParticle == false && doprocessFindableRun3 == false) {
      LOGF(fatal, "Neither processRun2 nor processRun3 nor processRun3withstrangenesstracking nor processFindableRun3 enabled. Please choose one!");
    }
    if (doprocessRun2 == true && doprocessRun3 == true) {
      LOGF(fatal, "Cannot enable processRun2 and processRun3 at the same time. Please choose one.");
    }
    if (doprocessRun3 == true && doprocessRun3withStrangenessTracking == true) {
      LOGF(fatal, "Cannot enable processRun3 and processRun3withstrangenesstracking at the same time. Please choose one.");
    }
    if (doprocessRun2 == true && doprocessRun3withStrangenessTracking == true) {
      LOGF(fatal, "Cannot enable processRun2 and processRun3withstrangenesstracking at the same time. Please choose one.");
    }

    if (d_UseAutodetectMode) {
      // Checking for subscriptions to:
      double loosest_casccospa = 100;
      float loosest_dcacascdau = -100;
      float loosest_dcabachtopv = 100;
      float loosest_dcav0topv = 100;
      float loosest_radius = 100;
      float loosest_v0masswindow = -100;

      double detected_casccospa = 100;
      float detected_dcacascdau = -100;
      float detected_dcabachtopv = 100;
      float detected_dcav0topv = 100;
      float detected_radius = 100;
      float detected_v0masswindow = -100;

      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      LOGF(info, " Multi-strange builder self-configuration");
      LOGF(info, "*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*");
      auto& workflows = context.services().get<RunningWorkflowInfo const>();
      for (DeviceSpec const& device : workflows.devices) {
        // Step 1: check if this device subscribed to the V0data table
        for (auto const& input : device.inputs) {
          if (device.name.compare("cascade-initializer") == 0)
            continue; // don't listen to the initializer, it's just to extend stuff
          const std::string CascCoresName = "StoredCascCores";
          const std::string KFCascCoresName = "StoredKFCascCores";
          const std::string TraCascCoresName = "StoredTraCascCores";
          if (input.matcher.binding == CascCoresName || input.matcher.binding == KFCascCoresName || input.matcher.binding == TraCascCoresName) {
            LOGF(info, "Device named %s has subscribed to a CascCores table! Will now scan for desired settings...", device.name);
            for (auto const& option : device.options) {
              // 5 V0 topological selections + 1 mass
              if (option.name.compare("cascadesetting_cospa") == 0) {
                detected_casccospa = option.defaultValue.get<double>();
                LOGF(info, "%s requested cascade cospa = %f", device.name, detected_casccospa);
                if (detected_casccospa < loosest_casccospa)
                  loosest_casccospa = detected_casccospa;
              }
              if (option.name.compare("cascadesetting_dcacascdau") == 0) {
                detected_dcacascdau = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA cascade daughters = %f", device.name, detected_dcacascdau);
                if (detected_dcacascdau > loosest_dcacascdau)
                  loosest_dcacascdau = detected_dcacascdau;
              }
              if (option.name.compare("cascadesetting_dcabachtopv") == 0) {
                detected_dcabachtopv = option.defaultValue.get<float>();
                LOGF(info, "%s requested DCA bachelor daughter = %f", device.name, detected_dcabachtopv);
                if (detected_dcabachtopv < loosest_dcabachtopv)
                  loosest_dcabachtopv = detected_dcabachtopv;
              }
              if (option.name.compare("cascadesetting_cascradius") == 0) {
                detected_radius = option.defaultValue.get<float>();
                LOGF(info, "%s requested  to PV = %f", device.name, detected_radius);
                if (detected_radius < loosest_radius)
                  loosest_radius = detected_radius;
              }
              if (option.name.compare("cascadesetting_mindcav0topv") == 0) {
                detected_dcav0topv = option.defaultValue.get<float>();
                LOGF(info, "%s requested minimum V0 DCA to PV = %f", device.name, detected_dcav0topv);
                if (detected_dcav0topv < loosest_dcav0topv)
                  loosest_dcav0topv = detected_dcav0topv;
              }
              if (option.name.compare("cascadesetting_v0masswindow") == 0) {
                detected_v0masswindow = option.defaultValue.get<float>();
                LOGF(info, "%s requested minimum V0 mass window (GeV/c^2) = %f", device.name, detected_v0masswindow);
                if (detected_v0masswindow > loosest_v0masswindow)
                  loosest_v0masswindow = detected_v0masswindow;
              }
            }
          }
          const std::string CascCovsName = "CascCovs";
          if (input.matcher.binding == CascCovsName) {
            LOGF(info, "Device named %s has subscribed to CascCovs table! Enabling.", device.name);
            createCascCovMats.value = 1;
          }
          const std::string CascTracksXName = "CascTrackXs";
          if (input.matcher.binding == CascTracksXName) {
            LOGF(info, "Device named %s has subscribed to CascTrackXs table! Enabling.", device.name);
            createCascTrackXs.value = 1;
          }
        }
      }

      LOGF(info, "Self-configuration finished! Decided on selections:");
      LOGF(info, " -+*> Cascade cospa ............: %.6f", loosest_casccospa);
      LOGF(info, " -+*> DCA cascade daughters ....: %.6f", loosest_dcacascdau);
      LOGF(info, " -+*> DCA bachelor daughter ....: %.6f", loosest_dcabachtopv);
      LOGF(info, " -+*> Min DCA V0 to PV .........: %.6f", loosest_dcav0topv);
      LOGF(info, " -+*> Min cascade decay radius .: %.6f", loosest_radius);
      LOGF(info, " -+*> V0 mass window ...........: %.6f", loosest_v0masswindow);

      casccospa.value = loosest_casccospa;
      dcacascdau.value = loosest_dcacascdau;
      dcabachtopv.value = loosest_dcabachtopv;
      // dcav0dau.value = loosest_dcav0topv;
      cascradius.value = loosest_radius;
      lambdaMassWindow.value = loosest_v0masswindow;
    }

    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
    LOGF(info, "Strangeness builder configuration:");
    if (doprocessRun2 == true) {
      LOGF(info, "Run 2 processing enabled. Will subscribe to Tracks table.");
    }
    if (doprocessRun3 == true) {
      LOGF(info, "Run 3 processing enabled. Will subscribe to TracksIU table.");
    }
    if (createCascCovMats > 0) {
      LOGF(info, "-> Will produce cascade cov mat table");
    }
    //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*

    // initialize O2 2-prong fitter (only once)
    fitter.setPropagateToPCA(true);
    fitter.setMaxR(200.);
    fitter.setMinParamChange(1e-3);
    fitter.setMinRelChi2Change(0.9);
    fitter.setMaxDZIni(1e9);
    fitter.setMaxChi2(1e9);
    fitter.setUseAbsDCA(d_UseAbsDCA);
    fitter.setWeightedFinalPCA(d_UseWeightedPCA);

    // Material correction in the DCA fitter
    matCorr = o2::base::Propagator::MatCorrType::USEMatCorrNONE;
    if (useMatCorrType == 1)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrTGeo;
    if (useMatCorrType == 2)
      matCorr = o2::base::Propagator::MatCorrType::USEMatCorrLUT;
    fitter.setMatCorrType(matCorr);

    matCorrCascade = o2::base::Propagator::MatCorrType::USEMatCorrNONE;
    if (useMatCorrTypeCasc == 1)
      matCorrCascade = o2::base::Propagator::MatCorrType::USEMatCorrTGeo;
    if (useMatCorrTypeCasc == 2)
      matCorrCascade = o2::base::Propagator::MatCorrType::USEMatCorrLUT;

    // initialize bach baryon variables just in case
    cascadecandidate.bachBaryonCosPA = 1;     // would ordinarily reject all
    cascadecandidate.bachBaryonDCAxyToPV = 0; // would ordinarily reject all
  }

  void initCCDB(aod::BCsWithTimestamps::iterator const& bc)
  {
    if (mRunNumber == bc.runNumber()) {
      return;
    }

    // machine learning initialization if requested
    if (mlConfigurations.calculateXiMinusScores ||
        mlConfigurations.calculateXiPlusScores ||
        mlConfigurations.calculateOmegaMinusScores ||
        mlConfigurations.calculateOmegaPlusScores) {
      int64_t timeStampML = bc.timestamp();
      if (mlConfigurations.timestampCCDB.value != -1)
        timeStampML = mlConfigurations.timestampCCDB.value;
      LoadMachines(timeStampML);
    }

    // In case override, don't proceed, please - no CCDB access required
    if (d_bz_input > -990) {
      d_bz = d_bz_input;
      fitter.setBz(d_bz);
      o2::parameters::GRPMagField grpmag;
      if (fabs(d_bz) > 1e-5) {
        grpmag.setL3Current(30000.f / (d_bz / 5.0f));
      }
      o2::base::Propagator::initFieldFromGRP(&grpmag);
      mRunNumber = bc.runNumber();
      return;
    }

    auto timestamp = bc.timestamp();
    o2::parameters::GRPObject* grpo = 0x0;
    o2::parameters::GRPMagField* grpmag = 0x0;
    if (doprocessRun2) {
      grpo = ccdb->getForTimeStamp<o2::parameters::GRPObject>(ccdbConfigurations.grpPath, timestamp);
      if (!grpo) {
        LOG(fatal) << "Got nullptr from CCDB for path " << ccdbConfigurations.grpPath << " of object GRPObject for timestamp " << timestamp;
      }
      o2::base::Propagator::initFieldFromGRP(grpo);
    } else {
      grpmag = ccdb->getForTimeStamp<o2::parameters::GRPMagField>(ccdbConfigurations.grpmagPath, timestamp);
      if (!grpmag) {
        LOG(fatal) << "Got nullptr from CCDB for path " << ccdbConfigurations.grpmagPath << " of object GRPMagField for timestamp " << timestamp;
      }
      o2::base::Propagator::initFieldFromGRP(grpmag);
    }
    // Fetch magnetic field from ccdb for current collision
    d_bz = o2::base::Propagator::Instance()->getNominalBz();
    LOG(info) << "Retrieved GRP for timestamp " << timestamp << " with magnetic field of " << d_bz << " kG";
    mRunNumber = bc.runNumber();
    // Set magnetic field value once known
    fitter.setBz(d_bz);
    /// Set magnetic field for KF vertexing
    KFParticle::SetField(d_bz);

    if (useMatCorrType == 2 && !lut) {
      // setMatLUT only after magfield has been initalized
      // (setMatLUT has implicit and problematic init field call if not)
      LOG(info) << "Loading material look-up table for timestamp: " << timestamp;
      lut = o2::base::MatLayerCylSet::rectifyPtrFromFile(ccdb->getForTimeStamp<o2::base::MatLayerCylSet>(ccdbConfigurations.lutPath, timestamp));
      o2::base::Propagator::Instance()->setMatLUT(lut);
    }
  }

  // function to load models for ML-based classifiers
  void LoadMachines(int64_t timeStampML)
  {
    if (mlConfigurations.loadModelsFromCCDB) {
      ccdbApi.init(ccdbConfigurations.ccdburl);
      LOG(info) << "Fetching cascade models for timestamp: " << timeStampML;

      if (mlConfigurations.calculateXiMinusScores) {
        bool retrieveSuccess = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathXiMinus.value);
        if (retrieveSuccess) {
          mlModelXiMinus.initModel(mlConfigurations.localModelPathXiMinus.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the XiMinus model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }

      if (mlConfigurations.calculateXiPlusScores) {
        bool retrieveSuccess = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathXiPlus.value);
        if (retrieveSuccess) {
          mlModelXiPlus.initModel(mlConfigurations.localModelPathXiPlus.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the XiPlus model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }

      if (mlConfigurations.calculateOmegaMinusScores) {
        bool retrieveSuccess = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathOmegaMinus.value);
        if (retrieveSuccess) {
          mlModelOmegaMinus.initModel(mlConfigurations.localModelPathOmegaMinus.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the OmegaMinus model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }

      if (mlConfigurations.calculateOmegaPlusScores) {
        bool retrieveSuccess = ccdbApi.retrieveBlob(mlConfigurations.modelPathCCDB, ".", metadata, timeStampML, false, mlConfigurations.localModelPathOmegaPlus.value);
        if (retrieveSuccess) {
          mlModelOmegaPlus.initModel(mlConfigurations.localModelPathOmegaPlus.value, mlConfigurations.enableOptimizations.value);
        } else {
          LOG(fatal) << "Error encountered while fetching/loading the OmegaPlus model from CCDB! Maybe the model doesn't exist yet for this runnumber/timestamp?";
        }
      }
    } else {
      if (mlConfigurations.calculateXiMinusScores)
        mlModelXiMinus.initModel(mlConfigurations.localModelPathXiMinus.value, mlConfigurations.enableOptimizations.value);
      if (mlConfigurations.calculateXiPlusScores)
        mlModelXiPlus.initModel(mlConfigurations.localModelPathXiPlus.value, mlConfigurations.enableOptimizations.value);
      if (mlConfigurations.calculateOmegaMinusScores)
        mlModelOmegaMinus.initModel(mlConfigurations.localModelPathOmegaMinus.value, mlConfigurations.enableOptimizations.value);
      if (mlConfigurations.calculateOmegaPlusScores)
        mlModelOmegaPlus.initModel(mlConfigurations.localModelPathOmegaPlus.value, mlConfigurations.enableOptimizations.value);
    }
    LOG(info) << "Cascade ML Models loaded.";
  }

  // TrackParCov to KF converter
  // FIXME: could be an utility somewhere else
  // from Carolina Reetz (thank you!)
  template <typename T>
  KFParticle createKFParticleFromTrackParCov(const o2::track::TrackParametrizationWithError<T>& trackparCov, int charge, float mass)
  {
    std::array<T, 3> xyz, pxpypz;
    float xyzpxpypz[6];
    trackparCov.getPxPyPzGlo(pxpypz);
    trackparCov.getXYZGlo(xyz);
    for (int i{0}; i < 3; ++i) {
      xyzpxpypz[i] = xyz[i];
      xyzpxpypz[i + 3] = pxpypz[i];
    }

    std::array<float, 21> cv;
    try {
      trackparCov.getCovXYZPxPyPzGlo(cv);
    } catch (std::runtime_error& e) {
      LOG(debug) << "Failed to get cov matrix from TrackParCov" << e.what();
    }

    KFParticle kfPart;
    float Mini, SigmaMini, M, SigmaM;
    kfPart.GetMass(Mini, SigmaMini);
    LOG(debug) << "Daughter KFParticle mass before creation: " << Mini << " +- " << SigmaMini;

    try {
      kfPart.Create(xyzpxpypz, cv.data(), charge, mass);
    } catch (std::runtime_error& e) {
      LOG(debug) << "Failed to create KFParticle from daughter TrackParCov" << e.what();
    }

    kfPart.GetMass(M, SigmaM);
    LOG(debug) << "Daughter KFParticle mass after creation: " << M << " +- " << SigmaM;
    return kfPart;
  }

  // KF to TrackParCov converter
  // FIXME: could be an utility somewhere else
  // from Carolina Reetz (thank you!)
  o2::track::TrackParCov getTrackParCovFromKFP(const KFParticle& kfParticle, const o2::track::PID pid, const int sign)
  {
    o2::gpu::gpustd::array<float, 3> xyz, pxpypz;
    o2::gpu::gpustd::array<float, 21> cv;

    // get parameters from kfParticle
    xyz[0] = kfParticle.GetX();
    xyz[1] = kfParticle.GetY();
    xyz[2] = kfParticle.GetZ();
    pxpypz[0] = kfParticle.GetPx();
    pxpypz[1] = kfParticle.GetPy();
    pxpypz[2] = kfParticle.GetPz();

    // set covariance matrix elements (lower triangle)
    for (int i = 0; i < 21; i++) {
      cv[i] = kfParticle.GetCovariance(i);
    }

    // create TrackParCov track
    o2::track::TrackParCov track = o2::track::TrackParCov(xyz, pxpypz, cv, sign, true, pid);
    return track;
  }

  template <typename TCollision, typename TTrack>
  void processBachBaryonVariables(TCollision const& collision, TTrack const& track1, TTrack const& track2)
  {
    cascadecandidate.bachBaryonCosPA = 0;        // would ordinarily accept all
    cascadecandidate.bachBaryonDCAxyToPV = 1e+3; // would ordinarily accept all

    // create tracks from table rows
    o2::track::TrackParCov tr1 = getTrackParCov(track1);
    o2::track::TrackParCov tr2 = getTrackParCov(track2);

    //---/---/---/
    // Move close to minima
    int nCand = 0;
    try {
      nCand = fitter.process(tr1, tr2);
    } catch (...) {
      registry.fill(HIST("hCaughtExceptions"), 0.5f);
      LOG(error) << "Exception caught in DCA fitter process call!";
      return;
    }
    if (nCand == 0)
      return; // variables are such that candidate is accepted (not obvious...)

    // Calculate DCAxy of the cascade (with bending)
    o2::track::TrackPar wrongV0 = fitter.createParentTrackPar();
    wrongV0.setAbsCharge(0); // charge zero
    gpu::gpustd::array<float, 2> dcaInfo;
    dcaInfo[0] = 999;
    dcaInfo[1] = 999;

    // bachelor-baryon DCAxy to PV
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, wrongV0, 2.f, matCorr, &dcaInfo);
    cascadecandidate.bachBaryonDCAxyToPV = dcaInfo[0];

    const auto& vtx = fitter.getPCACandidate();
    if (!fitter.isPropagateTracksToVertexDone())
      return;

    std::array<float, 3> tr1p;
    std::array<float, 3> tr2p;

    fitter.getTrack(1).getPxPyPzGlo(tr1p);
    fitter.getTrack(2).getPxPyPzGlo(tr2p);

    // bachelor-baryon CosPA
    cascadecandidate.bachBaryonCosPA = RecoDecay::cpa(
      array{collision.posX(), collision.posY(), collision.posZ()},
      array{vtx[0], vtx[1], vtx[2]},
      array{tr1p[0] + tr2p[0], tr1p[1] + tr2p[1], tr1p[2] + tr2p[2]});

    // Potentially also to be considered: bachelor-baryon DCA (between the two tracks)
    // to be added here as complementary information in the future
  }

  template <class TTrackTo, typename TCascObject, typename TV0Object>
  bool buildCascadeCandidate(TCascObject const& cascade, TV0Object const& v0)
  {
    // value 0.5: any considered cascade
    statisticsRegistry.cascstats[kCascAll]++;

    // Track casting
    auto bachTrack = cascade.template bachelor_as<TTrackTo>();
    auto posTrack = v0.template posTrack_as<TTrackTo>();
    auto negTrack = v0.template negTrack_as<TTrackTo>();
    auto const& collision = cascade.collision();

    if (calculateBachBaryonVars) {
      // Calculates properties of the V0 comprised of bachelor and baryon in the cascade
      // baryon: distinguished via bachelor charge
      if (bachTrack.sign() < 0) {
        processBachBaryonVariables(collision, bachTrack, posTrack);
      } else {
        processBachBaryonVariables(collision, bachTrack, negTrack);
      }
    }

    // value 0.5: any considered cascade
    statisticsRegistry.cascstats[kCascHasV0Data]++;

    // Overall cascade charge
    cascadecandidate.charge = bachTrack.signed1Pt() > 0 ? +1 : -1;

    if (qaConfigurations.d_doQA) {
      // produce a plot that showcases the mass of the received lambdas
      if (cascadecandidate.charge < 0)
        registry.fill(HIST("h2dLambdaMass"), v0.pt(), v0.mLambda());
      if (cascadecandidate.charge > 0)
        registry.fill(HIST("h2dAntiLambdaMass"), v0.pt(), v0.mAntiLambda());
    }

    // check also against charge
    if (cascadecandidate.charge < 0 && TMath::Abs(v0.mLambda() - 1.116) > lambdaMassWindow)
      return false;
    if (cascadecandidate.charge > 0 && TMath::Abs(v0.mAntiLambda() - 1.116) > lambdaMassWindow)
      return false;
    statisticsRegistry.cascstats[kCascLambdaMass]++;

    if (tpcrefit) {
      if (!(bachTrack.trackType() & o2::aod::track::TPCrefit)) {
        return false;
      }
    }
    statisticsRegistry.cascstats[kBachTPCrefit]++;

    // bachelor DCA track to PV
    // Calculate DCA with respect to the collision associated to the V0, not individual tracks
    gpu::gpustd::array<float, 2> dcaInfo;

    auto bachTrackPar = getTrackPar(bachTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, bachTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    cascadecandidate.bachDCAxy = dcaInfo[0];

    if (TMath::Abs(cascadecandidate.bachDCAxy) < dcabachtopv)
      return false;
    statisticsRegistry.cascstats[kBachDCAxy]++;

    // Do actual minimization
    lBachelorTrack = getTrackParCov(bachTrack);

    // Set up covariance matrices (should in fact be optional)
    std::array<float, 21> covV = {0.};
    constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
    for (int i = 0; i < 6; i++) {
      covV[MomInd[i]] = v0.momentumCovMat()[i];
      covV[i] = v0.positionCovMat()[i];
    }
    lV0Track = o2::track::TrackParCov(
      {v0.x(), v0.y(), v0.z()},
      {v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()},
      covV, 0, true);
    lV0Track.setAbsCharge(0);
    lV0Track.setPID(o2::track::PID::Lambda);

    //---/---/---/
    // Move close to minima
    int nCand = 0;
    try {
      nCand = fitter.process(lV0Track, lBachelorTrack);
    } catch (...) {
      registry.fill(HIST("hCaughtExceptions"), 0.5f);
      LOG(error) << "Exception caught in DCA fitter process call!";
      return false;
    }
    if (nCand == 0)
      return false;

    lV0Track = fitter.getTrack(0);
    lBachelorTrack = fitter.getTrack(1);

    // DCA between cascade daughters
    cascadecandidate.dcacascdau = TMath::Sqrt(fitter.getChi2AtPCACandidate());
    if (cascadecandidate.dcacascdau > dcacascdau)
      return false;
    statisticsRegistry.cascstats[kCascDCADau]++;

    fitter.getTrack(1).getPxPyPzGlo(cascadecandidate.bachP);
    // get decay vertex coordinates
    const auto& vtx = fitter.getPCACandidate();
    for (int i = 0; i < 3; i++) {
      cascadecandidate.pos[i] = vtx[i];
    }

    if (qaConfigurations.d_doQA && d_doPtDep_CosPaCut) {
      bool mcUnchecked = !d_QA_checkMC;
      bool dEdxUnchecked = !d_QA_checkdEdx;

      // Calculate masses
      auto lPt = RecoDecay::sqrtSumOfSquares(v0.pxpos() + v0.pxneg() + cascadecandidate.bachP[0], v0.pypos() + v0.pyneg() + cascadecandidate.bachP[1]);

      // Fill basic mass histograms
      // Note: all presel bools are true if unchecked
      if ((cascade.isdEdxXiMinus() || dEdxUnchecked) && (cascade.isTrueXiMinus() || mcUnchecked) && cascadecandidate.charge < 0)
        registry.fill(HIST("MassHistograms_BefPAcut/h2dXiMinusMass"), lPt, RecoDecay::m(array{array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}, array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassLambda}));
      if ((cascade.isdEdxXiPlus() || dEdxUnchecked) && (cascade.isTrueXiPlus() || mcUnchecked) && cascadecandidate.charge > 0)
        registry.fill(HIST("MassHistograms_BefPAcut/h2dXiPlusMass"), lPt, RecoDecay::m(array{array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}, array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassLambda}));
      if ((cascade.isdEdxOmegaMinus() || dEdxUnchecked) && (cascade.isTrueOmegaMinus() || mcUnchecked) && cascadecandidate.charge < 0)
        registry.fill(HIST("MassHistograms_BefPAcut/h2dOmegaMinusMass"), lPt, RecoDecay::m(array{array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}, array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}}, array{o2::constants::physics::MassKaonCharged, o2::constants::physics::MassLambda}));
      if ((cascade.isdEdxOmegaPlus() || dEdxUnchecked) && (cascade.isTrueOmegaPlus() || mcUnchecked) && cascadecandidate.charge > 0)
        registry.fill(HIST("MassHistograms_BefPAcut/h2dOmegaPlusMass"), lPt, RecoDecay::m(array{array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}, array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}}, array{o2::constants::physics::MassKaonCharged, o2::constants::physics::MassLambda}));
    }

    cascadecandidate.cosPA = RecoDecay::cpa(
      array{collision.posX(), collision.posY(), collision.posZ()},
      array{cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2]},
      array{v0.pxpos() + v0.pxneg() + cascadecandidate.bachP[0], v0.pypos() + v0.pyneg() + cascadecandidate.bachP[1], v0.pzpos() + v0.pzneg() + cascadecandidate.bachP[2]});
    if (d_doPtDep_CosPaCut) {
      auto lPt = RecoDecay::sqrtSumOfSquares(v0.pxpos() + v0.pxneg() + cascadecandidate.bachP[0], v0.pypos() + v0.pyneg() + cascadecandidate.bachP[1]);
      double ptdepCut = cas_cospaParameter / lPt;
      if (ptdepCut > 0.3 || lPt < 0.5)
        ptdepCut = 0.3;
      if (cascadecandidate.cosPA < TMath::Cos(ptdepCut)) {
        return false;
      }
    } else if (cascadecandidate.cosPA < casccospa) {
      return false;
    }
    statisticsRegistry.cascstats[kCascCosPA]++;

    // Cascade radius
    cascadecandidate.cascradius = RecoDecay::sqrtSumOfSquares(cascadecandidate.pos[0], cascadecandidate.pos[1]);
    if (cascadecandidate.cascradius < cascradius)
      return false;
    statisticsRegistry.cascstats[kCascRadius]++;

    // Daughter eta check
    if (TMath::Abs(RecoDecay::eta(std::array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]})) > maxDaughterEta) {
      return false; // reject - daughters have too large eta to be reliable for MC corrections
    }
    statisticsRegistry.cascstats[kCascDauEta]++;

    // Calculate DCAxy of the cascade (with bending)
    lCascadeTrack = fitter.createParentTrackParCov();
    lCascadeTrack.setAbsCharge(cascadecandidate.charge); // to be sure
    lCascadeTrack.setPID(o2::track::PID::XiMinus);       // FIXME: not OK for omegas
    dcaInfo[0] = 999;
    dcaInfo[1] = 999;

    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, lCascadeTrack, 2.f, matCorrCascade, &dcaInfo);
    cascadecandidate.cascDCAxy = dcaInfo[0];
    cascadecandidate.cascDCAz = dcaInfo[1];

    // Calculate masses a priori
    cascadecandidate.mXi = RecoDecay::m(array{array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}, array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}}, array{o2::constants::physics::MassPionCharged, o2::constants::physics::MassLambda});
    cascadecandidate.mOmega = RecoDecay::m(array{array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]}, array{v0.pxpos() + v0.pxneg(), v0.pypos() + v0.pyneg(), v0.pzpos() + v0.pzneg()}}, array{o2::constants::physics::MassKaonCharged, o2::constants::physics::MassLambda});
    cascadecandidate.yXi = RecoDecay::y(array{cascadecandidate.bachP[0] + v0.pxpos() + v0.pxneg(), cascadecandidate.bachP[1] + v0.pypos() + v0.pyneg(), cascadecandidate.bachP[2] + v0.pzpos() + v0.pzneg()}, o2::constants::physics::MassXiMinus);
    cascadecandidate.yOmega = RecoDecay::y(array{cascadecandidate.bachP[0] + v0.pxpos() + v0.pxneg(), cascadecandidate.bachP[1] + v0.pypos() + v0.pyneg(), cascadecandidate.bachP[2] + v0.pzpos() + v0.pzneg()}, o2::constants::physics::MassOmegaMinus);

    // Populate information
    // cascadecandidate.v0Id = v0index.globalIndex();
    cascadecandidate.positiveId = posTrack.globalIndex();
    cascadecandidate.negativeId = negTrack.globalIndex();
    cascadecandidate.bachelorId = bachTrack.globalIndex();
    cascadecandidate.positiveX = v0.posX();             // from prior minimization
    cascadecandidate.negativeX = v0.negX();             // from prior minimization
    cascadecandidate.bachelorX = lBachelorTrack.getX(); // from this minimization
    cascadecandidate.v0pos[0] = v0.x();
    cascadecandidate.v0pos[1] = v0.y();
    cascadecandidate.v0pos[2] = v0.z();
    cascadecandidate.v0mompos[0] = v0.pxpos();
    cascadecandidate.v0mompos[1] = v0.pypos();
    cascadecandidate.v0mompos[2] = v0.pzpos();
    cascadecandidate.v0momneg[0] = v0.pxneg();
    cascadecandidate.v0momneg[1] = v0.pyneg();
    cascadecandidate.v0momneg[2] = v0.pzneg();
    cascadecandidate.v0dcadau = v0.dcaV0daughters();
    cascadecandidate.v0dcapostopv = v0.dcapostopv();
    cascadecandidate.v0dcanegtopv = v0.dcanegtopv();

    if (useCascadeMomentumAtPrimVtx) {
      lCascadeTrack.getPxPyPzGlo(cascadecandidate.cascademom);
    } else {
      cascadecandidate.cascademom[0] = cascadecandidate.bachP[0] + cascadecandidate.v0mompos[0] + cascadecandidate.v0momneg[0];
      cascadecandidate.cascademom[1] = cascadecandidate.bachP[1] + cascadecandidate.v0mompos[1] + cascadecandidate.v0momneg[1];
      cascadecandidate.cascademom[2] = cascadecandidate.bachP[2] + cascadecandidate.v0mompos[2] + cascadecandidate.v0momneg[2];
    }

    if (d_doTrackQA) {
      if (posTrack.itsNCls() < 10)
        statisticsRegistry.posITSclu[posTrack.itsNCls()]++;
      if (negTrack.itsNCls() < 10)
        statisticsRegistry.negITSclu[negTrack.itsNCls()]++;
      if (bachTrack.itsNCls() < 10)
        statisticsRegistry.bachITSclu[bachTrack.itsNCls()]++;
    }

    if (qaConfigurations.d_doQA) {
      bool mcUnchecked = !d_QA_checkMC;
      bool dEdxUnchecked = !d_QA_checkdEdx;

      // Calculate masses
      auto lPt = RecoDecay::sqrtSumOfSquares(v0.pxpos() + v0.pxneg() + cascadecandidate.bachP[0], v0.pypos() + v0.pyneg() + cascadecandidate.bachP[1]);

      // Fill basic mass histograms
      // Note: all presel bools are true if unchecked
      if ((cascade.isdEdxXiMinus() || dEdxUnchecked) && (cascade.isTrueXiMinus() || mcUnchecked) && cascadecandidate.charge < 0)
        registry.fill(HIST("MassHistograms/h2dXiMinusMass"), lPt, cascadecandidate.mXi);
      if ((cascade.isdEdxXiPlus() || dEdxUnchecked) && (cascade.isTrueXiPlus() || mcUnchecked) && cascadecandidate.charge > 0)
        registry.fill(HIST("MassHistograms/h2dXiPlusMass"), lPt, cascadecandidate.mXi);
      if ((cascade.isdEdxOmegaMinus() || dEdxUnchecked) && (cascade.isTrueOmegaMinus() || mcUnchecked) && cascadecandidate.charge < 0)
        registry.fill(HIST("MassHistograms/h2dOmegaMinusMass"), lPt, cascadecandidate.mOmega);
      if ((cascade.isdEdxOmegaPlus() || dEdxUnchecked) && (cascade.isTrueOmegaPlus() || mcUnchecked) && cascadecandidate.charge > 0)
        registry.fill(HIST("MassHistograms/h2dOmegaPlusMass"), lPt, cascadecandidate.mOmega);

      // Fill ITS cluster maps with specific mass cuts
      if (TMath::Abs(cascadecandidate.mXi - 1.322) < qaConfigurations.dQAXiMassWindow && ((cascade.isdEdxXiMinus() || dEdxUnchecked) && (cascade.isTrueXiMinus() || mcUnchecked)) && cascadecandidate.charge < 0) {
        registry.fill(HIST("h2dITSCluMap_XiMinusPositive"), static_cast<float>(posTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiMinusNegative"), static_cast<float>(negTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiMinusBachelor"), static_cast<float>(bachTrack.itsClusterMap()), cascadecandidate.cascradius);
      }
      if (TMath::Abs(cascadecandidate.mXi - 1.322) < qaConfigurations.dQAXiMassWindow && ((cascade.isdEdxXiPlus() || dEdxUnchecked) && (cascade.isTrueXiPlus() || mcUnchecked)) && cascadecandidate.charge > 0) {
        registry.fill(HIST("h2dITSCluMap_XiPlusPositive"), static_cast<float>(posTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiPlusNegative"), static_cast<float>(negTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_XiPlusBachelor"), static_cast<float>(bachTrack.itsClusterMap()), cascadecandidate.cascradius);
      }
      if (TMath::Abs(cascadecandidate.mOmega - 1.672) < qaConfigurations.dQAOmegaMassWindow && ((cascade.isdEdxOmegaMinus() || dEdxUnchecked) && (cascade.isTrueOmegaMinus() || mcUnchecked)) && cascadecandidate.charge < 0) {
        registry.fill(HIST("h2dITSCluMap_OmegaMinusPositive"), static_cast<float>(posTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaMinusNegative"), static_cast<float>(negTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaMinusBachelor"), static_cast<float>(bachTrack.itsClusterMap()), cascadecandidate.cascradius);
      }
      if (TMath::Abs(cascadecandidate.mOmega - 1.672) < qaConfigurations.dQAOmegaMassWindow && ((cascade.isdEdxOmegaPlus() || dEdxUnchecked) && (cascade.isTrueOmegaPlus() || mcUnchecked)) && cascadecandidate.charge > 0) {
        registry.fill(HIST("h2dITSCluMap_OmegaPlusPositive"), static_cast<float>(posTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaPlusNegative"), static_cast<float>(negTrack.itsClusterMap()), v0.v0radius());
        registry.fill(HIST("h2dITSCluMap_OmegaPlusBachelor"), static_cast<float>(bachTrack.itsClusterMap()), cascadecandidate.cascradius);
      }

      // do specific topological variable QA too
      registry.fill(HIST("h2dTopoVarCascPointingAngle"), lPt, TMath::ACos(cascadecandidate.cosPA));
      registry.fill(HIST("h2dTopoVarCascRAP"), lPt, TMath::ACos(cascadecandidate.cosPA) * cascadecandidate.cascradius);
      registry.fill(HIST("h2dTopoVarCascRadius"), lPt, cascadecandidate.cascradius);
    }

    // calculate machine learning scores, compare against thresholds
    cascadecandidate.mlXiMinusScore = -1.0f;
    cascadecandidate.mlXiPlusScore = -1.0f;
    cascadecandidate.mlOmegaMinusScore = -1.0f;
    cascadecandidate.mlOmegaPlusScore = -1.0f;

    if (mlConfigurations.calculateXiMinusScores ||
        mlConfigurations.calculateXiPlusScores ||
        mlConfigurations.calculateOmegaMinusScores ||
        mlConfigurations.calculateOmegaPlusScores) {
      // machine learning is on, go for calculation of thresholds
      // FIXME THIS NEEDS ADJUSTING
      std::vector<float> inputFeatures{0.0f, 0.0f,
                                       0.0f, 0.0f};

      // calculate scores
      if (mlConfigurations.calculateXiMinusScores) {
        float* xiMinusProbability = mlModelXiMinus.evalModel(inputFeatures);
        cascadecandidate.mlXiMinusScore = xiMinusProbability[1];
      }
      if (mlConfigurations.calculateXiPlusScores) {
        float* xiPlusProbability = mlModelXiPlus.evalModel(inputFeatures);
        cascadecandidate.mlXiPlusScore = xiPlusProbability[1];
      }
      if (mlConfigurations.calculateOmegaMinusScores) {
        float* omegaMinusProbability = mlModelOmegaMinus.evalModel(inputFeatures);
        cascadecandidate.mlOmegaMinusScore = omegaMinusProbability[1];
      }
      if (mlConfigurations.calculateOmegaPlusScores) {
        float* omegaPlusProbability = mlModelOmegaPlus.evalModel(inputFeatures);
        cascadecandidate.mlOmegaPlusScore = omegaPlusProbability[1];
      }

      // Skip anything that doesn't fulfull any of the desired conditions
      if (cascadecandidate.mlXiMinusScore < mlConfigurations.thresholdXiMinus.value &&
          cascadecandidate.mlXiPlusScore < mlConfigurations.thresholdXiPlus.value &&
          cascadecandidate.mlOmegaMinusScore < mlConfigurations.thresholdOmegaMinus.value &&
          cascadecandidate.mlOmegaPlusScore < mlConfigurations.thresholdOmegaPlus.value) {
        return false; // skipped as uninteresting in any hypothesis considered
      }
    }

    // Final outcome is YES if I got here!
    return true;
  }

  template <class TTrackTo, typename TV0Object, typename TCascObject>
  bool buildCascadeCandidateWithKF(TCascObject const& cascade, TV0Object const& v0)
  {
    registry.fill(HIST("hKFParticleStatistics"), 0.0f);
    //*>~<*>~<*>~<*>~<*>~<*>~<*>~<*>~<*>~<*
    // KF particle based rebuilding
    // dispenses prior V0 generation, uses constrained (re-)fit based on bachelor charge
    //*>~<*>~<*>~<*>~<*>~<*>~<*>~<*>~<*>~<*

    // Track casting for those not provided
    auto posTrack = v0.template posTrack_as<TTrackTo>();
    auto negTrack = v0.template negTrack_as<TTrackTo>();
    auto bachTrack = cascade.template bachelor_as<TTrackTo>();
    auto const& collision = cascade.collision();

    if (calculateBachBaryonVars) {
      // Calculates properties of the V0 comprised of bachelor and baryon in the cascade
      // baryon: distinguished via bachelor charge
      if (bachTrack.sign() < 0) {
        processBachBaryonVariables(collision, bachTrack, posTrack);
      } else {
        processBachBaryonVariables(collision, bachTrack, negTrack);
      }
    }

    // value 0.5: any considered cascade
    statisticsRegistry.cascstats[kCascAll]++;

    // Overall cascade charge
    cascadecandidate.charge = bachTrack.signed1Pt() > 0 ? +1 : -1;

    // bachelor DCA track to PV
    // Calculate DCA with respect to the collision associated to the V0, not individual tracks
    gpu::gpustd::array<float, 2> dcaInfo;

    auto bachTrackPar = getTrackPar(bachTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, bachTrackPar, 2.f, fitter.getMatCorrType(), &dcaInfo);
    cascadecandidate.bachDCAxy = dcaInfo[0];

    o2::track::TrackParCov posTrackParCovForDCA = getTrackParCov(posTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, posTrackParCovForDCA, 2.f, fitter.getMatCorrType(), &dcaInfo);
    cascadecandidate.v0dcapostopv = dcaInfo[0];
    o2::track::TrackParCov negTrackParCovForDCA = getTrackParCov(negTrack);
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, negTrackParCovForDCA, 2.f, fitter.getMatCorrType(), &dcaInfo);
    cascadecandidate.v0dcanegtopv = dcaInfo[0];

    if (TMath::Abs(cascadecandidate.bachDCAxy) < dcabachtopv)
      return false;

    lBachelorTrack = getTrackParCov(bachTrack);
    o2::track::TrackParCov negTrackParCov = getTrackParCov(negTrack);
    o2::track::TrackParCov posTrackParCov = getTrackParCov(posTrack);

    float massPosTrack, massNegTrack;
    if (cascadecandidate.charge < 0) {
      massPosTrack = o2::constants::physics::MassProton;
      massNegTrack = o2::constants::physics::MassPionCharged;
    } else {
      massPosTrack = o2::constants::physics::MassPionCharged;
      massNegTrack = o2::constants::physics::MassProton;
    }

    //__________________________________________
    //*>~<* step 1 : V0 with dca fitter, uses material corrections implicitly
    // This is optional - move close to minima and therefore take material
    if (kfDoDCAFitterPreMinimV0) {
      int nCand = 0;
      try {
        nCand = fitter.process(posTrackParCov, negTrackParCov);
      } catch (...) {
        LOG(error) << "Exception caught in DCA fitter process call!";
        return false;
      }
      if (nCand == 0) {
        return false;
      }
      // save classical DCA daughters
      cascadecandidate.v0dcadau = TMath::Sqrt(fitter.getChi2AtPCACandidate());

      // re-acquire from DCA fitter
      posTrackParCov = fitter.getTrack(0);
      negTrackParCov = fitter.getTrack(1);
    }

    //__________________________________________
    //*>~<* step 2 : V0 with KF
    // create KFParticle objects from trackParCovs
    KFParticle kfpPos = createKFParticleFromTrackParCov(posTrackParCov, posTrackParCov.getCharge(), massPosTrack);
    KFParticle kfpNeg = createKFParticleFromTrackParCov(negTrackParCov, negTrackParCov.getCharge(), massNegTrack);
    const KFParticle* V0Daughters[2] = {&kfpPos, &kfpNeg};

    // construct V0
    KFParticle KFV0;
    KFV0.SetConstructMethod(kfConstructMethod);
    try {
      KFV0.Construct(V0Daughters, 2);
    } catch (std::runtime_error& e) {
      LOG(debug) << "Failed to construct cascade V0 from daughter tracks: " << e.what();
      return false;
    }

    // mass window cut on lambda before mass constraint
    float massLam, sigLam;
    KFV0.GetMass(massLam, sigLam);
    if (TMath::Abs(massLam - 1.116) > lambdaMassWindow)
      return false;

    if (kfUseV0MassConstraint) {
      KFV0.SetNonlinearMassConstraint(o2::constants::physics::MassLambda);
    }

    // V0 constructed, now recovering TrackParCov for dca fitter minimization (with material correction)
    KFV0.TransportToDecayVertex();
    o2::track::TrackParCov v0TrackParCov = getTrackParCovFromKFP(KFV0, o2::track::PID::Lambda, 0);
    v0TrackParCov.setAbsCharge(0); // to be sure

    //__________________________________________
    //*>~<* step 3 : Cascade with dca fitter (with material corrections)
    if (kfDoDCAFitterPreMinimCasc) {
      int nCandCascade = 0;
      try {
        nCandCascade = fitter.process(v0TrackParCov, lBachelorTrack);
      } catch (...) {
        LOG(error) << "Exception caught in DCA fitter process call!";
        return false;
      }
      if (nCandCascade == 0)
        return false;

      // save classical DCA daughters
      // cascadecandidate.dcacascdau = TMath::Sqrt(fitter.getChi2AtPCACandidate());
      // if (cascadecandidate.dcacascdau > dcacascdau)
      //   return false;

      v0TrackParCov = fitter.getTrack(0);
      lBachelorTrack = fitter.getTrack(1);
    }

    //__________________________________________
    //*>~<* step 4 : Cascade with KF particle (potentially mass-constrained if asked)
    float massBachelorPion = o2::constants::physics::MassPionCharged;
    float massBachelorKaon = o2::constants::physics::MassKaonCharged;

    KFParticle kfpV0 = createKFParticleFromTrackParCov(v0TrackParCov, 0, o2::constants::physics::MassLambda);
    KFParticle kfpBachPion = createKFParticleFromTrackParCov(lBachelorTrack, cascadecandidate.charge, massBachelorPion);
    KFParticle kfpBachKaon = createKFParticleFromTrackParCov(lBachelorTrack, cascadecandidate.charge, massBachelorKaon);
    const KFParticle* XiDaugthers[2] = {&kfpBachPion, &kfpV0};
    const KFParticle* OmegaDaugthers[2] = {&kfpBachKaon, &kfpV0};

    // construct mother
    KFParticle KFXi, KFOmega;
    KFXi.SetConstructMethod(kfConstructMethod);
    KFOmega.SetConstructMethod(kfConstructMethod);
    try {
      KFXi.Construct(XiDaugthers, 2);
    } catch (std::runtime_error& e) {
      LOG(debug) << "Failed to construct xi from V0 and bachelor track: " << e.what();
      return false;
    }
    try {
      KFOmega.Construct(OmegaDaugthers, 2);
    } catch (std::runtime_error& e) {
      LOG(debug) << "Failed to construct omega from V0 and bachelor track: " << e.what();
      return false;
    }
    if (kfUseCascadeMassConstraint) {
      // set mass constraint if requested
      // WARNING: this is only adequate for decay chains, i.e. XiC -> Xi or OmegaC -> Omega
      KFXi.SetNonlinearMassConstraint(o2::constants::physics::MassXiMinus);
      KFOmega.SetNonlinearMassConstraint(o2::constants::physics::MassOmegaMinus);
    }
    KFXi.TransportToDecayVertex();
    KFOmega.TransportToDecayVertex();

    // get DCA of daughters at vertex
    cascadecandidate.dcacascdau = kfpBachPion.GetDistanceFromParticle(kfpV0);
    if (cascadecandidate.dcacascdau > dcacascdau)
      return false;

    //__________________________________________
    //*>~<* step 5 : propagate cascade to primary vertex with material corrections if asked
    if (!kfTuneForOmega) {
      lCascadeTrack = getTrackParCovFromKFP(KFXi, o2::track::PID::XiMinus, cascadecandidate.charge);
    } else {
      lCascadeTrack = getTrackParCovFromKFP(KFOmega, o2::track::PID::OmegaMinus, cascadecandidate.charge);
    }
    dcaInfo[0] = 999;
    dcaInfo[1] = 999;
    o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, lCascadeTrack, 2.f, matCorrCascade, &dcaInfo);
    cascadecandidate.cascDCAxy = dcaInfo[0];
    cascadecandidate.cascDCAz = dcaInfo[1];

    //__________________________________________
    //*>~<* step 6 : acquire all parameters for analysis

    // basic indices
    cascadecandidate.v0Id = v0.globalIndex();
    cascadecandidate.positiveId = posTrack.globalIndex();
    cascadecandidate.negativeId = negTrack.globalIndex();
    cascadecandidate.bachelorId = bachTrack.globalIndex();

    // KF chi2
    cascadecandidate.kfV0Chi2 = KFV0.GetChi2();
    cascadecandidate.kfCascadeChi2 = KFXi.GetChi2();
    if (kfTuneForOmega)
      cascadecandidate.kfCascadeChi2 = KFOmega.GetChi2();

    // Daughter momentum not KF-updated FIXME --> but DCA fitter updated if pre-minimisation is used
    lBachelorTrack.getPxPyPzGlo(cascadecandidate.bachP);
    posTrackParCov.getPxPyPzGlo(cascadecandidate.v0mompos);
    negTrackParCov.getPxPyPzGlo(cascadecandidate.v0momneg);

    // Daughter track position at vertex not KF-updated FIXME --> but DCA fitter updated if pre-minimisation is used
    posTrackParCov.getXYZGlo(cascadecandidate.v0pospos);
    negTrackParCov.getXYZGlo(cascadecandidate.v0posneg);

    // mother position information from KF
    cascadecandidate.v0pos[0] = KFV0.GetX();
    cascadecandidate.v0pos[1] = KFV0.GetY();
    cascadecandidate.v0pos[2] = KFV0.GetZ();

    // mother momentumm information from KF
    cascadecandidate.kfv0mom[0] = KFV0.GetPx();
    cascadecandidate.kfv0mom[1] = KFV0.GetPy();
    cascadecandidate.kfv0mom[2] = KFV0.GetPz();

    // Mother position + momentum is KF updated
    if (!kfTuneForOmega) {
      cascadecandidate.pos[0] = KFXi.GetX();
      cascadecandidate.pos[1] = KFXi.GetY();
      cascadecandidate.pos[2] = KFXi.GetZ();
      cascadecandidate.cascademom[0] = KFXi.GetPx();
      cascadecandidate.cascademom[1] = KFXi.GetPy();
      cascadecandidate.cascademom[2] = KFXi.GetPz();
    } else {
      cascadecandidate.pos[0] = KFOmega.GetX();
      cascadecandidate.pos[1] = KFOmega.GetY();
      cascadecandidate.pos[2] = KFOmega.GetZ();
      cascadecandidate.cascademom[0] = KFOmega.GetPx();
      cascadecandidate.cascademom[1] = KFOmega.GetPy();
      cascadecandidate.cascademom[2] = KFOmega.GetPz();
    }

    // KF-aware cosPA
    cascadecandidate.cosPA = RecoDecay::cpa(
      array{collision.posX(), collision.posY(), collision.posZ()},
      array{cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2]},
      array{cascadecandidate.cascademom[0], cascadecandidate.cascademom[1], cascadecandidate.cascademom[2]});
    if (cascadecandidate.cosPA < casccospa) {
      return false;
    }

    // KF-aware Cascade radius
    cascadecandidate.cascradius = RecoDecay::sqrtSumOfSquares(cascadecandidate.pos[0], cascadecandidate.pos[1]);
    if (cascadecandidate.cascradius < cascradius)
      return false;

    // Daughter eta check
    if (TMath::Abs(RecoDecay::eta(std::array{cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2]})) > maxDaughterEta) {
      return false; // reject - daughters have too large eta to be reliable for MC corrections
    }

    // Calculate masses a priori
    float MLambda, SigmaLambda, MXi, SigmaXi, MOmega, SigmaOmega;
    KFV0.GetMass(MLambda, SigmaLambda);
    KFXi.GetMass(MXi, SigmaXi);
    KFOmega.GetMass(MOmega, SigmaOmega);
    cascadecandidate.kfMLambda = MLambda;
    cascadecandidate.mXi = MXi;
    cascadecandidate.mOmega = MOmega;
    cascadecandidate.yXi = KFXi.GetRapidity();
    cascadecandidate.yOmega = KFOmega.GetRapidity();

    // KF Cascade covariance matrix
    o2::gpu::gpustd::array<float, 21> covCascKF;
    for (int i = 0; i < 21; i++) { // get covariance matrix elements (lower triangle)
      covCascKF[i] = KFXi.GetCovariance(i);
      cascadecandidate.kfCascadeCov[i] = covCascKF[i];
    }

    // KF V0 covariance matrix
    o2::gpu::gpustd::array<float, 21> covV0KF;
    for (int i = 0; i < 21; i++) { // get covariance matrix elements (lower triangle)
      covV0KF[i] = KFV0.GetCovariance(i);
      cascadecandidate.kfV0Cov[i] = covV0KF[i];
    }

    // V0 daughter covariance matrices
    std::array<float, 21> cvPosKF, cvNegKF;
    posTrackParCov.getCovXYZPxPyPzGlo(cvPosKF);
    negTrackParCov.getCovXYZPxPyPzGlo(cvNegKF);
    for (int i = 0; i < 21; i++) {
      cascadecandidate.kfV0DauPosCov[i] = cvPosKF[i];
      cascadecandidate.kfV0DauNegCov[i] = cvNegKF[i];
    }

    registry.fill(HIST("hKFParticleStatistics"), 1.0f);
    return true;
  }

  template <class TTrackTo, typename TV0Index, typename TCascade>
  void processCascadeCandidate(TV0Index const& v0index, TCascade const& cascade)
  {
    bool validCascadeCandidate = false;
    if (v0index.has_v0Data()) {
      // this V0 passed both standard V0 and cascade V0 selections
      auto v0row = v0index.template v0Data_as<V0full>();
      validCascadeCandidate = buildCascadeCandidate<TTrackTo>(cascade, v0row);
    } else if (v0index.has_v0fCData()) {
      // this V0 passes only V0-for-cascade selections, use that instead
      auto v0row = v0index.template v0fCData_as<V0fCfull>();
      validCascadeCandidate = buildCascadeCandidate<TTrackTo>(cascade, v0row);
    } else {
      return; // this was inadequately linked, should not happen
    }
    if (!validCascadeCandidate)
      return; // doesn't pass cascade selections

    // round the DCA variables to a certain precision if asked
    if (roundDCAVariables)
      roundCascadeCandidateVariables();

    cascidx(/*cascadecandidate.v0Id, */ cascade.globalIndex(),
            cascadecandidate.positiveId, cascadecandidate.negativeId,
            cascadecandidate.bachelorId, cascade.collisionId());
    cascdata(cascadecandidate.charge, cascadecandidate.mXi, cascadecandidate.mOmega,
             cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2],
             cascadecandidate.v0pos[0], cascadecandidate.v0pos[1], cascadecandidate.v0pos[2],
             cascadecandidate.v0mompos[0], cascadecandidate.v0mompos[1], cascadecandidate.v0mompos[2],
             cascadecandidate.v0momneg[0], cascadecandidate.v0momneg[1], cascadecandidate.v0momneg[2],
             cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2],
             cascadecandidate.cascademom[0], cascadecandidate.cascademom[1], cascadecandidate.cascademom[2],
             cascadecandidate.v0dcadau, cascadecandidate.dcacascdau,
             cascadecandidate.v0dcapostopv, cascadecandidate.v0dcanegtopv,
             cascadecandidate.bachDCAxy, cascadecandidate.cascDCAxy, cascadecandidate.cascDCAz); // <--- no corresponding stratrack information available
    if (createCascTrackXs) {
      cascTrackXs(cascadecandidate.positiveX, cascadecandidate.negativeX, cascadecandidate.bachelorX);
    }
    cascbb(cascadecandidate.bachBaryonCosPA, cascadecandidate.bachBaryonDCAxyToPV);
    if (cascadecandidate.charge < 0) {
      xiMLSelections(cascadecandidate.mlXiMinusScore);
      omegaMLSelections(cascadecandidate.mlOmegaMinusScore);
    } else {
      xiMLSelections(cascadecandidate.mlXiPlusScore);
      omegaMLSelections(cascadecandidate.mlOmegaPlusScore);
    }

    // populate cascade covariance matrices if required by any other task
    if (createCascCovMats) {
      // Calculate position covariance matrix
      auto covVtxV = fitter.calcPCACovMatrix(0);
      // std::array<float, 6> positionCovariance;
      float positionCovariance[6];
      positionCovariance[0] = covVtxV(0, 0);
      positionCovariance[1] = covVtxV(1, 0);
      positionCovariance[2] = covVtxV(1, 1);
      positionCovariance[3] = covVtxV(2, 0);
      positionCovariance[4] = covVtxV(2, 1);
      positionCovariance[5] = covVtxV(2, 2);
      // store momentum covariance matrix
      std::array<float, 21> covTv0 = {0.};
      std::array<float, 21> covTbachelor = {0.};
      float covCascade[21];
      // std::array<float, 6> momentumCovariance;
      lV0Track.getCovXYZPxPyPzGlo(covTv0);
      lBachelorTrack.getCovXYZPxPyPzGlo(covTbachelor);
      constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
      for (int i = 0; i < 21; i++) {
        covCascade[i] = 0.0f;
      }
      for (int i = 0; i < 6; i++) {
        covCascade[i] = positionCovariance[i];
        covCascade[MomInd[i]] = covTv0[MomInd[i]] + covTbachelor[MomInd[i]];
      }
      casccovs(covCascade);
    }
  }

  template <class TTrackTo, typename TCascTable>
  void buildStrangenessTables(TCascTable const& cascades)
  {
    statisticsRegistry.eventCounter++;
    for (auto& cascade : cascades) {
      // de-reference from V0 pool, either specific for cascades or general
      // use templatizing to avoid code duplication

      if constexpr (requires { cascade.template v0(); }) {
        auto v0index = cascade.template v0_as<aod::V0sLinked>();
        processCascadeCandidate<TTrackTo>(v0index, cascade);
      }
      if constexpr (requires { cascade.template findableV0(); }) {
        auto v0index = cascade.template findableV0_as<aod::FindableV0sLinked>();
        processCascadeCandidate<TTrackTo>(v0index, cascade);
      }
    }
    // En masse filling at end of process call
    fillHistos();
    resetHistos();
  }

  template <class TTrackTo, typename TCascTable>
  void buildKFStrangenessTables(TCascTable const& cascades)
  {
    statisticsRegistry.eventCounter++;
    for (auto& cascade : cascades) {
      bool validCascadeCandidateKF = false;
      if constexpr (requires { cascade.template v0(); }) {
        auto v0 = cascade.template v0_as<aod::V0sLinked>();
        validCascadeCandidateKF = buildCascadeCandidateWithKF<TTrackTo>(cascade, v0);
      }
      if constexpr (requires { cascade.template findableV0(); }) {
        auto v0 = cascade.template findableV0_as<aod::FindableV0sLinked>();
        validCascadeCandidateKF = buildCascadeCandidateWithKF<TTrackTo>(cascade, v0);
      }
      if (!validCascadeCandidateKF)
        continue; // doesn't pass cascade selections

      // round the DCA variables to a certain precision if asked
      if (roundDCAVariables)
        roundCascadeCandidateVariables();

      registry.fill(HIST("hKFParticleStatistics"), 2.0f);

      kfcascidx(/*cascadecandidate.v0Id, */ cascade.globalIndex(),
                cascadecandidate.positiveId, cascadecandidate.negativeId,
                cascadecandidate.bachelorId, cascade.collisionId());
      kfcascdata(cascadecandidate.charge, cascadecandidate.mXi, cascadecandidate.mOmega,
                 cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2],
                 cascadecandidate.v0pos[0], cascadecandidate.v0pos[1], cascadecandidate.v0pos[2],
                 cascadecandidate.v0pospos[0], cascadecandidate.v0pospos[1], cascadecandidate.v0pospos[2],
                 cascadecandidate.v0posneg[0], cascadecandidate.v0posneg[1], cascadecandidate.v0posneg[2],
                 cascadecandidate.v0mompos[0], cascadecandidate.v0mompos[1], cascadecandidate.v0mompos[2],
                 cascadecandidate.v0momneg[0], cascadecandidate.v0momneg[1], cascadecandidate.v0momneg[2],
                 cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2],
                 cascadecandidate.kfv0mom[0], cascadecandidate.kfv0mom[1], cascadecandidate.kfv0mom[2],
                 cascadecandidate.cascademom[0], cascadecandidate.cascademom[1], cascadecandidate.cascademom[2],
                 cascadecandidate.v0dcadau, cascadecandidate.dcacascdau,
                 cascadecandidate.v0dcapostopv, cascadecandidate.v0dcanegtopv,
                 cascadecandidate.bachDCAxy, cascadecandidate.cascDCAxy, cascadecandidate.cascDCAz,
                 cascadecandidate.kfMLambda, cascadecandidate.kfV0Chi2, cascadecandidate.kfCascadeChi2);

      if (createCascCovMats) {
        float trackCovariance[21];
        float trackCovarianceV0[21];
        float trackCovariancePos[21];
        float trackCovarianceNeg[21];

        for (int i = 0; i < 21; i++) {
          trackCovariance[i] = cascadecandidate.kfCascadeCov[i];
          trackCovarianceV0[i] = cascadecandidate.kfV0Cov[i];
          trackCovariancePos[i] = cascadecandidate.kfV0DauPosCov[i];
          trackCovarianceNeg[i] = cascadecandidate.kfV0DauNegCov[i];
        }
        kfcasccovs(trackCovariance, trackCovarianceV0, trackCovariancePos, trackCovarianceNeg);
      }
    }
    // En masse filling at end of process call
    fillHistos();
    resetHistos();
  }

  template <class TTrackTo, typename TCascTable, typename TStraTrack>
  void buildStrangenessTablesWithStrangenessTracking(TCascTable const& cascades, TStraTrack const& trackedCascades)
  {
    statisticsRegistry.eventCounter++;

    for (auto& cascade : cascades) {
      // check if cascade is tracked - sliceBy is our friend!
      const uint64_t cascIdx = cascade.globalIndex();
      auto trackedCascadesSliced = trackedCascades.sliceBy(perCascade, cascIdx);

      // if only tracked cascades are desired, skip this candidate before doing anything (speed)
      if (trackedCascadesSliced.size() == 0 && d_GenerateOnlyTrackedCascades) {
        continue; // wasn't tracked
      }

      // de-reference from V0 pool, either specific for cascades or general
      // use templatizing to avoid code duplication
      bool validCascadeCandidate = false;
      auto v0index = cascade.template v0_as<o2::aod::V0sLinked>();
      if (v0index.has_v0Data()) {
        // this V0 passed both standard V0 and cascade V0 selections
        auto v0row = v0index.template v0Data_as<V0full>();
        validCascadeCandidate = buildCascadeCandidate<TTrackTo>(cascade, v0row);
      } else if (v0index.has_v0fCData()) {
        // this V0 passes only V0-for-cascade selections, use that instead
        auto v0row = v0index.template v0fCData_as<V0fCfull>();
        validCascadeCandidate = buildCascadeCandidate<TTrackTo>(cascade, v0row);
      } else {
        continue; // this was inadequately linked, should not happen
      }
      if (!validCascadeCandidate)
        continue; // doesn't pass cascade selections

      // round the DCA variables to a certain precision if asked
      if (roundDCAVariables)
        roundCascadeCandidateVariables();

      // fill regular tables (no strangeness tracking)
      cascidx(/*cascadecandidate.v0Id, */ cascade.globalIndex(),
              cascadecandidate.positiveId, cascadecandidate.negativeId,
              cascadecandidate.bachelorId, cascade.collisionId());
      cascdata(cascadecandidate.charge, cascadecandidate.mXi, cascadecandidate.mOmega,
               cascadecandidate.pos[0], cascadecandidate.pos[1], cascadecandidate.pos[2],
               cascadecandidate.v0pos[0], cascadecandidate.v0pos[1], cascadecandidate.v0pos[2],
               cascadecandidate.v0mompos[0], cascadecandidate.v0mompos[1], cascadecandidate.v0mompos[2],
               cascadecandidate.v0momneg[0], cascadecandidate.v0momneg[1], cascadecandidate.v0momneg[2],
               cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2],
               cascadecandidate.bachP[0] + cascadecandidate.v0mompos[0] + cascadecandidate.v0momneg[0], // <--- redundant but ok
               cascadecandidate.bachP[1] + cascadecandidate.v0mompos[1] + cascadecandidate.v0momneg[1], // <--- redundant but ok
               cascadecandidate.bachP[2] + cascadecandidate.v0mompos[2] + cascadecandidate.v0momneg[2], // <--- redundant but ok
               cascadecandidate.v0dcadau, cascadecandidate.dcacascdau,
               cascadecandidate.v0dcapostopv, cascadecandidate.v0dcanegtopv,
               cascadecandidate.bachDCAxy, cascadecandidate.cascDCAxy, cascadecandidate.cascDCAz); // <--- no corresponding stratrack information available
      if (createCascTrackXs) {
        cascTrackXs(cascadecandidate.positiveX, cascadecandidate.negativeX, cascadecandidate.bachelorX);
      }
      cascbb(cascadecandidate.bachBaryonCosPA, cascadecandidate.bachBaryonDCAxyToPV);
      if (cascadecandidate.charge < 0) {
        xiMLSelections(cascadecandidate.mlXiMinusScore);
        omegaMLSelections(cascadecandidate.mlOmegaMinusScore);
      } else {
        xiMLSelections(cascadecandidate.mlXiPlusScore);
        omegaMLSelections(cascadecandidate.mlOmegaPlusScore);
      }

      // populate cascade covariance matrices if required by any other task
      if (createCascCovMats) {
        // Calculate position covariance matrix
        auto covVtxV = fitter.calcPCACovMatrix(0);
        // std::array<float, 6> positionCovariance;
        float positionCovariance[6];
        positionCovariance[0] = covVtxV(0, 0);
        positionCovariance[1] = covVtxV(1, 0);
        positionCovariance[2] = covVtxV(1, 1);
        positionCovariance[3] = covVtxV(2, 0);
        positionCovariance[4] = covVtxV(2, 1);
        positionCovariance[5] = covVtxV(2, 2);
        // store momentum covariance matrix
        std::array<float, 21> covTv0 = {0.};
        std::array<float, 21> covTbachelor = {0.};
        float covCascade[21];
        // std::array<float, 6> momentumCovariance;
        lV0Track.getCovXYZPxPyPzGlo(covTv0);
        lBachelorTrack.getCovXYZPxPyPzGlo(covTbachelor);
        constexpr int MomInd[6] = {9, 13, 14, 18, 19, 20}; // cov matrix elements for momentum component
        for (int i = 0; i < 21; i++) {
          covCascade[i] = 0.0f;
        }
        for (int i = 0; i < 6; i++) {
          covCascade[i] = positionCovariance[i];
          covCascade[MomInd[i]] = covTv0[MomInd[i]] + covTbachelor[MomInd[i]];
        }
        casccovs(covCascade);
      }

      float lPt = 0.0f;
      bool mcUnchecked = !d_QA_checkMC;
      bool dEdxUnchecked = !d_QA_checkdEdx;

      if (d_doStraTrackQA) {
        // Fill standard DCA histograms for all candidates (irrespectively of strangeness tracking)
        lPt = RecoDecay::sqrtSumOfSquares(cascadecandidate.v0mompos[0] + cascadecandidate.v0momneg[0] + cascadecandidate.bachP[0], cascadecandidate.v0mompos[1] + cascadecandidate.v0momneg[1] + cascadecandidate.bachP[1]);

        if ((cascade.isdEdxXiMinus() || dEdxUnchecked) && (cascade.isTrueXiMinus() || mcUnchecked) && fabs(cascadecandidate.yXi) < 0.5 && cascadecandidate.charge < 0) {
          registry.fill(HIST("hDCACascadeToPVXiMinus"), lPt, cascadecandidate.cascDCAxy);
          registry.fill(HIST("hDCAzCascadeToPVXiMinus"), lPt, cascadecandidate.cascDCAz);
          registry.fill(HIST("hRadius_XiMinus_All"), cascadecandidate.cascradius);
        }
        if ((cascade.isdEdxXiPlus() || dEdxUnchecked) && (cascade.isTrueXiPlus() || mcUnchecked) && fabs(cascadecandidate.yXi) < 0.5 && cascadecandidate.charge > 0) {
          registry.fill(HIST("hDCACascadeToPVXiPlus"), lPt, cascadecandidate.cascDCAxy);
          registry.fill(HIST("hDCAzCascadeToPVXiPlus"), lPt, cascadecandidate.cascDCAz);
          registry.fill(HIST("hRadius_XiPlus_All"), cascadecandidate.cascradius);
        }
        if ((cascade.isdEdxOmegaMinus() || dEdxUnchecked) && (cascade.isTrueOmegaMinus() || mcUnchecked) && fabs(cascadecandidate.yOmega) < 0.5 && cascadecandidate.charge < 0) {
          registry.fill(HIST("hDCACascadeToPVOmegaMinus"), lPt, cascadecandidate.cascDCAxy);
          registry.fill(HIST("hDCAzCascadeToPVOmegaMinus"), lPt, cascadecandidate.cascDCAz);
          registry.fill(HIST("hRadius_OmegaMinus_All"), cascadecandidate.cascradius);
        }
        if ((cascade.isdEdxOmegaPlus() || dEdxUnchecked) && (cascade.isTrueOmegaPlus() || mcUnchecked) && fabs(cascadecandidate.yOmega) < 0.5 && cascadecandidate.charge > 0) {
          registry.fill(HIST("hDCACascadeToPVOmegaPlus"), lPt, cascadecandidate.cascDCAxy);
          registry.fill(HIST("hDCAzCascadeToPVOmegaPlus"), lPt, cascadecandidate.cascDCAz);
          registry.fill(HIST("hRadius_OmegaPlus_All"), cascadecandidate.cascradius);
        }
      }

      if (trackedCascadesSliced.size() > 0) {
        auto trackedCascade = trackedCascadesSliced.begin(); // first and only element

        // cascade track exists in AO2D, prefer information from that source!
        statisticsRegistry.cascstats[kCascTracked]++; // bookkeep how many we tracked overall

        // Initialize trackParCov
        if (!trackedCascade.has_track())
          continue; // safety (should be fine but depends on future stratrack dev)
        // Track casting to <TTracksTo>
        auto cascadeTrack = trackedCascade.template track_as<TTrackTo>();
        auto cascadeTrackPar = getTrackParCov(cascadeTrack);
        auto const& collision = cascade.collision();
        gpu::gpustd::array<float, 2> dcaInfo;
        lCascadeTrack.setPID(o2::track::PID::XiMinus); // FIXME: not OK for omegas
        o2::base::Propagator::Instance()->propagateToDCABxByBz({collision.posX(), collision.posY(), collision.posZ()}, cascadeTrackPar, 2.f, matCorrCascade, &dcaInfo);

        if (d_doStraTrackQA) {
          // do QA, compare with non-tracked
          // Fill standard DCA histograms for all tracked candidates with ORIGINAL properties
          if ((cascade.isdEdxXiMinus() || dEdxUnchecked) && (cascade.isTrueXiMinus() || mcUnchecked) && fabs(cascadecandidate.yXi) < 0.5 && cascadecandidate.charge < 0) {
            registry.fill(HIST("hDCATrackableCascadeToPVXiMinus"), lPt, cascadecandidate.cascDCAxy);
            registry.fill(HIST("hDCATrackedCascadeToPVXiMinus"), lPt, dcaInfo[0]);
            registry.fill(HIST("hDCAzTrackableCascadeToPVXiMinus"), lPt, cascadecandidate.cascDCAz);
            registry.fill(HIST("hDCAzTrackedCascadeToPVXiMinus"), lPt, dcaInfo[1]);
            registry.fill(HIST("h2dTrackableXiMinusMass"), lPt, cascadecandidate.mXi);
            registry.fill(HIST("h2dTrackedXiMinusMass"), lPt, trackedCascade.xiMass());
            registry.fill(HIST("hRadius_XiMinus_Tracked"), cascadecandidate.cascradius);
            registry.fill(HIST("hMatchingChi2_XiMinus"), trackedCascade.matchingChi2());
            registry.fill(HIST("hTopologyChi2_XiMinus"), trackedCascade.topologyChi2());
            registry.fill(HIST("hCluSize_XiMinus"), trackedCascade.itsClsSize());
          }
          if ((cascade.isdEdxXiPlus() || dEdxUnchecked) && (cascade.isTrueXiPlus() || mcUnchecked) && fabs(cascadecandidate.yXi) < 0.5 && cascadecandidate.charge > 0) {
            registry.fill(HIST("hDCATrackableCascadeToPVXiPlus"), lPt, cascadecandidate.cascDCAxy);
            registry.fill(HIST("hDCATrackedCascadeToPVXiPlus"), lPt, dcaInfo[0]);
            registry.fill(HIST("hDCAzTrackableCascadeToPVXiPlus"), lPt, cascadecandidate.cascDCAz);
            registry.fill(HIST("hDCAzTrackedCascadeToPVXiPlus"), lPt, dcaInfo[1]);
            registry.fill(HIST("h2dTrackableXiPlusMass"), lPt, cascadecandidate.mXi);
            registry.fill(HIST("h2dTrackedXiPlusMass"), lPt, trackedCascade.xiMass());
            registry.fill(HIST("hRadius_XiPlus_Tracked"), cascadecandidate.cascradius);
            registry.fill(HIST("hMatchingChi2_XiPlus"), trackedCascade.matchingChi2());
            registry.fill(HIST("hTopologyChi2_XiPlus"), trackedCascade.topologyChi2());
            registry.fill(HIST("hCluSize_XiPlus"), trackedCascade.itsClsSize());
          }
          if ((cascade.isdEdxOmegaMinus() || dEdxUnchecked) && (cascade.isTrueOmegaMinus() || mcUnchecked) && fabs(cascadecandidate.yOmega) < 0.5 && cascadecandidate.charge < 0) {
            registry.fill(HIST("hDCATrackableCascadeToPVOmegaMinus"), lPt, cascadecandidate.cascDCAxy);
            registry.fill(HIST("hDCATrackedCascadeToPVOmegaMinus"), lPt, dcaInfo[0]);
            registry.fill(HIST("hDCAzTrackableCascadeToPVOmegaMinus"), lPt, cascadecandidate.cascDCAz);
            registry.fill(HIST("hDCAzTrackedCascadeToPVOmegaMinus"), lPt, dcaInfo[1]);
            registry.fill(HIST("h2dTrackableOmegaMinusMass"), lPt, cascadecandidate.mOmega);
            registry.fill(HIST("h2dTrackedOmegaMinusMass"), lPt, trackedCascade.omegaMass());
            registry.fill(HIST("hRadius_OmegaMinus_Tracked"), cascadecandidate.cascradius);
            registry.fill(HIST("hMatchingChi2_OmegaMinus"), trackedCascade.matchingChi2());
            registry.fill(HIST("hTopologyChi2_OmegaMinus"), trackedCascade.topologyChi2());
            registry.fill(HIST("hCluSize_OmegaMinus"), trackedCascade.itsClsSize());
          }
          if ((cascade.isdEdxOmegaPlus() || dEdxUnchecked) && (cascade.isTrueOmegaPlus() || mcUnchecked) && fabs(cascadecandidate.yOmega) < 0.5 && cascadecandidate.charge > 0) {
            registry.fill(HIST("hDCATrackableCascadeToPVOmegaPlus"), lPt, cascadecandidate.cascDCAxy);
            registry.fill(HIST("hDCATrackedCascadeToPVOmegaPlus"), lPt, dcaInfo[0]);
            registry.fill(HIST("hDCAzTrackableCascadeToPVOmegaPlus"), lPt, cascadecandidate.cascDCAz);
            registry.fill(HIST("hDCAzTrackedCascadeToPVOmegaPlus"), lPt, dcaInfo[1]);
            registry.fill(HIST("h2dTrackableOmegaPlusMass"), lPt, cascadecandidate.mOmega);
            registry.fill(HIST("h2dTrackedOmegaPlusMass"), lPt, trackedCascade.omegaMass());
            registry.fill(HIST("hRadius_OmegaPlus_Tracked"), cascadecandidate.cascradius);
            registry.fill(HIST("hMatchingChi2_OmegaPlus"), trackedCascade.matchingChi2());
            registry.fill(HIST("hTopologyChi2_OmegaPlus"), trackedCascade.topologyChi2());
            registry.fill(HIST("hCluSize_OmegaPlus"), trackedCascade.itsClsSize());
          }
        }

        // Override cascDCAxy with the strangeness-tracked information
        cascadecandidate.cascDCAxy = dcaInfo[0];
        cascadecandidate.cascDCAz = dcaInfo[1];

        std::array<float, 3> cascadeMomentumVector;
        cascadeTrackPar.getPxPyPzGlo(cascadeMomentumVector);

        trackedcascidx(/*cascadecandidate.v0Id, */ cascade.globalIndex(),
                       cascadecandidate.positiveId, cascadecandidate.negativeId,
                       cascadecandidate.bachelorId, trackedCascade.trackId(), cascade.collisionId());
        trackedcascdata(cascadecandidate.charge, trackedCascade.xiMass(), trackedCascade.omegaMass(), // <--- stratrack masses
                        trackedCascade.decayX(), trackedCascade.decayY(), trackedCascade.decayZ(),    // <--- stratrack position
                        cascadecandidate.v0pos[0], cascadecandidate.v0pos[1], cascadecandidate.v0pos[2],
                        cascadecandidate.v0mompos[0], cascadecandidate.v0mompos[1], cascadecandidate.v0mompos[2],
                        cascadecandidate.v0momneg[0], cascadecandidate.v0momneg[1], cascadecandidate.v0momneg[2],
                        cascadecandidate.bachP[0], cascadecandidate.bachP[1], cascadecandidate.bachP[2],
                        cascadeMomentumVector[0], cascadeMomentumVector[1], cascadeMomentumVector[2], // <--- stratrack momentum
                        cascadecandidate.v0dcadau, cascadecandidate.dcacascdau,
                        cascadecandidate.v0dcapostopv, cascadecandidate.v0dcanegtopv,
                        cascadecandidate.bachDCAxy, cascadecandidate.cascDCAxy, cascadecandidate.cascDCAz,          // <--- stratrack (cascDCAxy/z)
                        trackedCascade.matchingChi2(), trackedCascade.topologyChi2(), trackedCascade.itsClsSize()); // <--- stratrack fit info

        if (createCascCovMats) {
          // create tracked cascade covariance in exactly the same way as non-tracked
          // ensures getter consistency and full compatibility in template functions
          // (easy switching between tracked and non-tracked)
          std::array<float, 21> traCovMat = {0.};
          cascadeTrackPar.getCovXYZPxPyPzGlo(traCovMat);
          float traCovMatArray[21];
          for (int ii = 0; ii < 21; ii++) {
            traCovMatArray[ii] = traCovMat[ii];
          }
          tracasccovs(traCovMatArray);
        }
      }
    }
    // En masse filling at end of process call
    fillHistos();
    resetHistos();
  }

  void processRun2(aod::Collisions const& collisions, aod::V0sLinked const&, V0full const&, V0fCfull const&, soa::Filtered<TaggedCascades> const& cascades, FullTracksExt const&, aod::BCsWithTimestamps const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollision, collIdx);
      buildStrangenessTables<FullTracksExt>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processRun2, "Produce Run 2 cascade tables", false);

  void processRun3(aod::Collisions const& collisions, aod::V0sLinked const&, V0full const&, V0fCfull const&, soa::Filtered<TaggedCascades> const& cascades, FullTracksExtIU const&, aod::BCsWithTimestamps const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollision, collIdx);
      buildStrangenessTables<FullTracksExtIU>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processRun3, "Produce Run 3 cascade tables", true);

  void processFindableRun3(aod::Collisions const& collisions, aod::FindableV0sLinked const&, V0full const&, soa::Filtered<TaggedFindableCascades> const& cascades, FullTracksExtIU const&, aod::BCsWithTimestamps const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollisionFindable, collIdx);
      buildStrangenessTables<FullTracksExtIU>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processFindableRun3, "Produce Run 3 findable cascade tables", false);

  void processRun3withKFParticle(aod::Collisions const& collisions, soa::Filtered<TaggedCascades> const& cascades, FullTracksExtIU const&, aod::BCsWithTimestamps const&, aod::V0sLinked const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollision, collIdx);
      buildKFStrangenessTables<FullTracksExtIU>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processRun3withKFParticle, "Produce Run 3 KF cascade tables", false);

  void processFindableRun3withKFParticle(aod::Collisions const& collisions, aod::FindableV0sLinked const&, V0full const&, soa::Filtered<TaggedFindableCascades> const& cascades, FullTracksExtIU const&, aod::BCsWithTimestamps const&)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollisionFindable, collIdx);
      buildKFStrangenessTables<FullTracksExtIU>(CascadeTable_thisCollision);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processFindableRun3withKFParticle, "Produce Run 3 findable cascade tables with KF processing path", false);

  void processRun3withStrangenessTracking(aod::Collisions const& collisions, aod::V0sLinked const&, V0full const&, V0fCfull const&, soa::Filtered<TaggedCascades> const& cascades, FullTracksExtIU const&, aod::BCsWithTimestamps const&, aod::TrackedCascades const& trackedCascades)
  {
    for (const auto& collision : collisions) {
      // Fire up CCDB
      auto bc = collision.bc_as<aod::BCsWithTimestamps>();
      initCCDB(bc);
      // Do analysis with collision-grouped V0s, retain full collision information
      const uint64_t collIdx = collision.globalIndex();
      auto CascadeTable_thisCollision = cascades.sliceBy(perCollision, collIdx);
      buildStrangenessTablesWithStrangenessTracking<FullTracksExtIU>(CascadeTable_thisCollision, trackedCascades);
    }
  }
  PROCESS_SWITCH(cascadeBuilder, processRun3withStrangenessTracking, "Produce Run 3 cascade tables with strangeness tracking", false);
};

//*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
struct cascadePreselector {
  Produces<aod::CascTags> casctags; // MC tags

  // for bookkeeping
  HistogramRegistry histos{"Histos", {}, OutputObjHandlingPolicy::AnalysisObject};

  Configurable<bool> dIfMCgenerateXiMinus{"dIfMCgenerateXiMinus", true, "if MC, generate MC true XiMinus (yes/no)"};
  Configurable<bool> dIfMCgenerateXiPlus{"dIfMCgenerateXiPlus", true, "if MC, generate MC true XiPlus (yes/no)"};
  Configurable<bool> dIfMCgenerateOmegaMinus{"dIfMCgenerateOmegaMinus", true, "if MC, generate MC true OmegaMinus (yes/no)"};
  Configurable<bool> dIfMCgenerateOmegaPlus{"dIfMCgenerateOmegaPlus", true, "if MC, generate MC true OmegaPlus (yes/no)"};
  Configurable<int> dIfMCselectV0MotherPDG{"dIfMCselectV0MotherPDG", 0, "if MC, selects based on mother particle (zero for no selection)"};
  Configurable<bool> dIfMCselectPhysicalPrimary{"dIfMCselectPhysicalPrimary", true, "if MC, select MC physical primary (yes/no)"};

  Configurable<bool> ddEdxPreSelectXiMinus{"ddEdxPreSelectXiMinus", true, "pre-select dE/dx compatibility with XiMinus (yes/no)"};
  Configurable<bool> ddEdxPreSelectXiPlus{"ddEdxPreSelectXiPlus", true, "pre-select dE/dx compatibility with XiPlus (yes/no)"};
  Configurable<bool> ddEdxPreSelectOmegaMinus{"ddEdxPreSelectOmegaMinus", true, "pre-select dE/dx compatibility with OmegaMinus (yes/no)"};
  Configurable<bool> ddEdxPreSelectOmegaPlus{"ddEdxPreSelectOmegaPlus", true, "pre-select dE/dx compatibility with OmegaPlus (yes/no)"};

  // dEdx pre-selection compatibility
  Configurable<float> ddEdxPreSelectionWindow{"ddEdxPreSelectionWindow", 7, "Nsigma window for dE/dx preselection"};

  // tpc quality pre-selection
  Configurable<int> dTPCNCrossedRows{"dTPCNCrossedRows", 50, "Minimum TPC crossed rows"};

  // context-aware selections
  Configurable<bool> dPreselectOnlyBaryons{"dPreselectOnlyBaryons", false, "apply TPC dE/dx and quality only to baryon daughters"};

  // extra QA
  Configurable<bool> doQA{"doQA", false, "do extra selector QA"};

  // for bit-packed maps
  std::vector<uint16_t> selectionMask;
  enum v0bit { bitInteresting = 0,
               bitTrackQuality,
               bitTrueXiMinus,
               bitTrueXiPlus,
               bitTrueOmegaMinus,
               bitPhysicalPrimary,
               bitTrueOmegaPlus,
               bitdEdxXiMinus,
               bitdEdxXiPlus,
               bitdEdxOmegaMinus,
               bitdEdxOmegaPlus,
               bitUsedInTrackedCascade };
  enum trackbit { bitITS = 0,
                  bitTPC,
                  bitTRD,
                  bitTOF };

  void init(InitContext const&)
  {
    // check settings and stop if not viable
    if (doprocessBuildAll == false && doprocessBuildMCAssociated == false && doprocessBuildValiddEdx == false && doprocessBuildValiddEdxMCAssociated == false && doprocessBuildFindable == false) {
      LOGF(fatal, "No processBuild function enabled. Please choose one.");
    }

    auto h = histos.add<TH1>("hPreselectorStatistics", "hPreselectorStatistics", kTH1D, {{5, -0.5f, 4.5f}});
    h->GetXaxis()->SetBinLabel(1, "All");
    h->GetXaxis()->SetBinLabel(2, "Tracks OK");
    h->GetXaxis()->SetBinLabel(3, "MC label OK");
    h->GetXaxis()->SetBinLabel(4, "dEdx OK");
    h->GetXaxis()->SetBinLabel(5, "Used in tracked OK");

    if (doQA) {
      const AxisSpec traPropAx{16, -0.5f, 15.5f, "Track flags"};
      histos.add("hTrackStat", "hTrackStat", kTH3D, {traPropAx, traPropAx, traPropAx});

      const AxisSpec nCluAx{10, -0.5f, 9.5f, "N(ITS clu)"};
      histos.add("hPosNClu", "hPosNClu", kTH1D, {nCluAx});
      histos.add("hNegNClu", "hNegNClu", kTH1D, {nCluAx});
      histos.add("hBachNClu", "hBachNClu", kTH1D, {nCluAx});
      histos.add("hPosNCluNoTPC", "hPosNCluNoTPC", kTH1D, {nCluAx});
      histos.add("hNegNCluNoTPC", "hNegNCluNoTPC", kTH1D, {nCluAx});
      histos.add("hBachNCluNoTPC", "hBachNCluNoTPC", kTH1D, {nCluAx});
    }
  }

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to pack track properties into an uint16_t
  template <class TTrackTo>
  uint16_t packTrackProperties(TTrackTo const& track)
  {
    uint16_t prop = 0;
    if (track.hasITS()) {
      bitset(prop, bitITS);
    }
    if (track.hasTPC()) {
      bitset(prop, bitTPC);
    }
    if (track.hasTRD()) {
      bitset(prop, bitTRD);
    }
    if (track.hasTOF()) {
      bitset(prop, bitTOF);
    }
    return prop;
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*

  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check track quality
  template <class TTrackTo, typename TV0Type, typename TCascadeObject>
  void checkTrackQuality(TCascadeObject const& lCascadeCandidate, TV0Type const& v0, uint16_t& maskElement, bool passdEdx = false)
  {
    // Acquire all three daughter tracks, please
    auto lBachTrack = lCascadeCandidate.template bachelor_as<TTrackTo>();
    auto lNegTrack = v0.template negTrack_as<TTrackTo>();
    auto lPosTrack = v0.template posTrack_as<TTrackTo>();

    if (doQA) {
      histos.fill(HIST("hTrackStat"), packTrackProperties(lPosTrack), packTrackProperties(lNegTrack), packTrackProperties(lBachTrack));

      histos.fill(HIST("hPosNClu"), lPosTrack.itsNCls());
      histos.fill(HIST("hNegNClu"), lNegTrack.itsNCls());
      histos.fill(HIST("hBachNClu"), lBachTrack.itsNCls());
      if (!lPosTrack.hasTPC()) {
        histos.fill(HIST("hPosNCluNoTPC"), lPosTrack.itsNCls());
      }
      if (!lNegTrack.hasTPC()) {
        histos.fill(HIST("hNegNCluNoTPC"), lNegTrack.itsNCls());
      }
      if (!lBachTrack.hasTPC()) {
        histos.fill(HIST("hBachNCluNoTPC"), lBachTrack.itsNCls());
      }
    }

    if ((bitcheck(maskElement, bitdEdxXiMinus) || bitcheck(maskElement, bitdEdxOmegaMinus) || passdEdx) && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons) && (lBachTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      bitset(maskElement, bitTrackQuality);
    if ((bitcheck(maskElement, bitdEdxXiPlus) || bitcheck(maskElement, bitdEdxOmegaPlus) || passdEdx) && (lNegTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows && (lPosTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons) && (lBachTrack.tpcNClsCrossedRows() >= dTPCNCrossedRows || dPreselectOnlyBaryons)))
      bitset(maskElement, bitTrackQuality);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check PDG association
  template <class TTrackTo, typename TCascadeObject>
  void checkPDG(TCascadeObject const& lCascadeCandidate, uint16_t& maskElement)
  {
    int lPDG = -1;
    bool physicalPrimary = false;

    // Acquire all three daughter tracks, please
    auto lBachTrack = lCascadeCandidate.template bachelor_as<TTrackTo>();
    auto v0 = lCascadeCandidate.template v0_as<o2::aod::V0s>();
    auto lNegTrack = v0.template negTrack_as<TTrackTo>();
    auto lPosTrack = v0.template posTrack_as<TTrackTo>();

    // Association check
    // There might be smarter ways of doing this in the future
    if (lNegTrack.has_mcParticle() && lPosTrack.has_mcParticle() && lBachTrack.has_mcParticle()) {
      auto lMCBachTrack = lBachTrack.template mcParticle_as<aod::McParticles>();
      auto lMCNegTrack = lNegTrack.template mcParticle_as<aod::McParticles>();
      auto lMCPosTrack = lPosTrack.template mcParticle_as<aod::McParticles>();

      // Step 1: check if the mother is the same, go up a level
      if (lMCNegTrack.has_mothers() && lMCPosTrack.has_mothers()) {
        for (auto& lNegMother : lMCNegTrack.template mothers_as<aod::McParticles>()) {
          for (auto& lPosMother : lMCPosTrack.template mothers_as<aod::McParticles>()) {
            if (lNegMother == lPosMother) {
              // if we got to this level, it means the mother particle exists and is the same
              // now we have to go one level up and compare to the bachelor mother too
              for (auto& lV0Mother : lNegMother.template mothers_as<aod::McParticles>()) {
                for (auto& lBachMother : lMCBachTrack.template mothers_as<aod::McParticles>()) {
                  if (lV0Mother == lBachMother) {
                    lPDG = lV0Mother.pdgCode();
                    physicalPrimary = lV0Mother.isPhysicalPrimary();

                    // additionally check PDG of the mother particle if requested
                    if (dIfMCselectV0MotherPDG != 0) {
                      lPDG = 0; // this is not the species you're looking for
                      if (lBachMother.has_mothers()) {
                        for (auto& lBachGrandMother : lBachMother.template mothers_as<aod::McParticles>()) {
                          if (lBachGrandMother.pdgCode() == dIfMCselectV0MotherPDG && (!dIfMCselectPhysicalPrimary || lBachGrandMother.isPhysicalPrimary()))
                            lPDG = lV0Mother.pdgCode();
                        }
                      }
                    }
                    // end extra PDG of mother check
                  }
                }
              } // end conditional V0-bach pair
            }   // end neg = pos mother conditional
          }
        } // end loop neg/pos mothers
      }   // end conditional of mothers existing
    }     // end association check
    // Construct tag table (note: this will be joinable with CascDatas)
    if (lPDG == 3312)
      bitset(maskElement, bitTrueXiMinus);
    if (lPDG == -3312)
      bitset(maskElement, bitTrueXiPlus);
    if (lPDG == 3334)
      bitset(maskElement, bitTrueOmegaMinus);
    if (lPDG == -3334)
      bitset(maskElement, bitTrueOmegaPlus);
    if (physicalPrimary)
      bitset(maskElement, bitPhysicalPrimary);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// function to check early dE/dx selection
  template <class TTrackTo, typename TCascadeObject>
  void checkdEdx(TCascadeObject const& lCascadeCandidate, uint16_t& maskElement)
  {
    // Acquire all three daughter tracks, please
    auto lBachTrack = lCascadeCandidate.template bachelor_as<TTrackTo>();
    auto v0 = lCascadeCandidate.template v0_as<o2::aod::V0s>();
    auto lNegTrack = v0.template negTrack_as<TTrackTo>();
    auto lPosTrack = v0.template posTrack_as<TTrackTo>();

    // dEdx check with LF PID
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxXiMinus);
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxXiPlus);
    if (TMath::Abs(lNegTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaKa()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxOmegaMinus);
    if (TMath::Abs(lNegTrack.tpcNSigmaPr()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lPosTrack.tpcNSigmaPi()) < ddEdxPreSelectionWindow &&
        TMath::Abs(lBachTrack.tpcNSigmaKa()) < ddEdxPreSelectionWindow)
      bitset(maskElement, bitdEdxOmegaPlus);
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Initialization of mask vectors if uninitialized
  void initializeMasks(int size)
  {
    if (selectionMask.size() < 1) {
      // reserve // FIXME check speed / optimise
      selectionMask.resize(size, 0);
    }
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// Clear mask vectors
  void resetMasks()
  {
    selectionMask.clear();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// checks and publishes tags if last
  void checkAndFinalize()
  {
    // parse + publish tag table now
    for (std::size_t ii = 0; ii < selectionMask.size(); ii++) {
      histos.fill(HIST("hPreselectorStatistics"), 0.0f); // All cascades
      bool validCascade = bitcheck(selectionMask[ii], bitTrackQuality);
      if (validCascade) {
        histos.fill(HIST("hPreselectorStatistics"), 1.0f); // pass MC assoc (if requested)
      }
      if (doprocessBuildMCAssociated || doprocessBuildValiddEdxMCAssociated)
        validCascade = validCascade && ((bitcheck(selectionMask[ii], bitTrueXiMinus) && dIfMCgenerateXiMinus) ||
                                        (bitcheck(selectionMask[ii], bitTrueXiPlus) && dIfMCgenerateXiPlus) ||
                                        (bitcheck(selectionMask[ii], bitTrueOmegaMinus) && dIfMCgenerateOmegaMinus) ||
                                        (bitcheck(selectionMask[ii], bitTrueOmegaPlus) && dIfMCgenerateOmegaPlus));
      if (validCascade) {
        histos.fill(HIST("hPreselectorStatistics"), 2.0f); // pass MC assoc (if requested)
      }
      if (doprocessBuildValiddEdx || doprocessBuildValiddEdxMCAssociated)
        validCascade = validCascade && ((bitcheck(selectionMask[ii], bitdEdxXiMinus) && ddEdxPreSelectXiMinus) ||
                                        (bitcheck(selectionMask[ii], bitdEdxXiPlus) && ddEdxPreSelectXiPlus) ||
                                        (bitcheck(selectionMask[ii], bitdEdxOmegaMinus) && ddEdxPreSelectOmegaMinus) ||
                                        (bitcheck(selectionMask[ii], bitdEdxOmegaPlus) && ddEdxPreSelectOmegaPlus));
      if (validCascade) {
        histos.fill(HIST("hPreselectorStatistics"), 3.0f); // pass dEdx (if requested)
      }
      if (doprocessSkipCascadesNotUsedInTrackedCascades)
        validCascade = validCascade && bitcheck(selectionMask[ii], bitUsedInTrackedCascade);
      if (validCascade) {
        histos.fill(HIST("hPreselectorStatistics"), 4.0f); // All cascades
      }
      casctags(validCascade,
               bitcheck(selectionMask[ii], bitTrueXiMinus), bitcheck(selectionMask[ii], bitTrueXiPlus),
               bitcheck(selectionMask[ii], bitTrueOmegaMinus), bitcheck(selectionMask[ii], bitTrueOmegaPlus),
               bitcheck(selectionMask[ii], bitPhysicalPrimary),
               bitcheck(selectionMask[ii], bitdEdxXiMinus), bitcheck(selectionMask[ii], bitdEdxXiPlus),
               bitcheck(selectionMask[ii], bitdEdxOmegaMinus), bitcheck(selectionMask[ii], bitdEdxOmegaPlus));
    }
    resetMasks();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all cascades are built. It will simply tag everything as true.
  void processBuildAll(aod::Cascades const& cascades, aod::V0s const&, aod::TracksExtra const&)
  {
    initializeMasks(cascades.size());
    for (auto& casc : cascades) {
      auto v0 = casc.v0();
      checkTrackQuality<aod::TracksExtra>(casc, v0, selectionMask[casc.globalIndex()], true);
    }
    if (!doprocessSkipCascadesNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildMCAssociated(aod::Collisions const& /*collisions*/, aod::Cascades const& cascades, aod::V0s const&, LabeledTracksExtra const&, aod::McParticles const&)
  {
    initializeMasks(cascades.size());
    for (auto& casc : cascades) {
      checkPDG<LabeledTracksExtra>(casc, selectionMask[casc.globalIndex()]);
      auto v0 = casc.v0();
      checkTrackQuality<LabeledTracksExtra>(casc, v0, selectionMask[casc.globalIndex()], true);
    } // end cascades loop
    if (!doprocessSkipCascadesNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdx(aod::Collisions const& /*collisions*/, aod::Cascades const& cascades, aod::V0s const&, TracksExtraWithPID const&)
  {
    initializeMasks(cascades.size());
    for (auto& casc : cascades) {
      checkdEdx<TracksExtraWithPID>(casc, selectionMask[casc.globalIndex()]);
      auto v0 = casc.v0();
      checkTrackQuality<TracksExtraWithPID>(casc, v0, selectionMask[casc.globalIndex()]);
    }
    if (!doprocessSkipCascadesNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  void processBuildValiddEdxMCAssociated(aod::Collisions const& /*collisions*/, aod::Cascades const& cascades, aod::V0s const&, TracksExtraWithPIDandLabels const&, aod::McParticles const&)
  {
    initializeMasks(cascades.size());
    for (auto& casc : cascades) {
      checkPDG<TracksExtraWithPIDandLabels>(casc, selectionMask[casc.globalIndex()]);
      checkdEdx<TracksExtraWithPIDandLabels>(casc, selectionMask[casc.globalIndex()]);
      auto v0 = casc.v0();
      checkTrackQuality<TracksExtraWithPIDandLabels>(casc, v0, selectionMask[casc.globalIndex()]);
    }
    if (!doprocessSkipCascadesNotUsedInTrackedCascades)
      checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function ensures that all findable cascades are built.
  /// Not to be used with processSkip.
  void processBuildFindable(aod::FindableCascades const& cascades, aod::FindableV0s const&, aod::TracksExtra const&)
  {
    initializeMasks(cascades.size());
    for (auto& casc : cascades) {
      auto v0 = casc.findableV0();
      checkTrackQuality<aod::TracksExtra>(casc, v0, selectionMask[casc.globalIndex()], true);
    }
    checkAndFinalize();
  }
  //*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*+-+*
  /// This process function checks for the use of Cascades in strangeness tracked cascades
  /// They are then marked appropriately; the user could then operate
  /// the cascadebuilder to construct only those Cascades.
  void processSkipCascadesNotUsedInTrackedCascades(aod::TrackedCascades const& tracasctable, aod::Cascades const& /*casctable*/)
  {
    for (auto const& tracasc : tracasctable) {
      bitset(selectionMask[tracasc.cascadeId()], bitUsedInTrackedCascade); // tag V0s needed by tracked cascades
    }
    checkAndFinalize();
  }
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
  /// basic building options (one of them must be chosen)
  PROCESS_SWITCH(cascadePreselector, processBuildAll, "Switch to build all cascades", true);
  PROCESS_SWITCH(cascadePreselector, processBuildMCAssociated, "Switch to build MC-associated cascades", false);
  PROCESS_SWITCH(cascadePreselector, processBuildValiddEdx, "Switch to build cascades with dE/dx preselection", false);
  PROCESS_SWITCH(cascadePreselector, processBuildValiddEdxMCAssociated, "Switch to build MC-associated cascades with dE/dx preselection", false);
  PROCESS_SWITCH(cascadePreselector, processBuildFindable, "Switch to build all findable cascades", false);
  /// skipper option (choose in addition to a processBuild if you like)
  PROCESS_SWITCH(cascadePreselector, processSkipCascadesNotUsedInTrackedCascades, "Switch to skip cascades not used in cascade tracking", false);
  //*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*>-~-<*
};

/// Extends the cascdata table with expression columns
struct cascadeInitializer {
  Spawns<aod::CascCores> cascdataext;
  Spawns<aod::KFCascCores> kfcascdataext;
  Spawns<aod::TraCascCores> tracascdataext;
  void init(InitContext const&) {}
};

struct cascadeLinkBuilder {
  Produces<aod::CascDataLink> cascdataLink;

  void init(InitContext const&) {}

  // build Cascade -> CascData link table
  void processFound(aod::Cascades const& casctable, aod::CascDatas const& cascdatatable)
  {
    std::vector<int> lIndices;
    lIndices.reserve(casctable.size());
    for (int ii = 0; ii < casctable.size(); ii++)
      lIndices[ii] = -1;
    for (auto& cascdata : cascdatatable) {
      lIndices[cascdata.cascadeId()] = cascdata.globalIndex();
    }
    for (int ii = 0; ii < casctable.size(); ii++) {
      cascdataLink(lIndices[ii]);
    }
  }

  // build Cascade -> CascData link table
  void processFindable(aod::FindableCascades const& casctable, aod::CascDatas const& cascdatatable)
  {
    std::vector<int> lIndices;
    lIndices.reserve(casctable.size());
    for (int ii = 0; ii < casctable.size(); ii++)
      lIndices[ii] = -1;
    for (auto& cascdata : cascdatatable) {
      lIndices[cascdata.cascadeId()] = cascdata.globalIndex();
    }
    for (int ii = 0; ii < casctable.size(); ii++) {
      cascdataLink(lIndices[ii]);
    }
  }

  PROCESS_SWITCH(cascadeLinkBuilder, processFound, "process found Cascades (default)", true);
  PROCESS_SWITCH(cascadeLinkBuilder, processFindable, "process findable Cascades", false);
};

struct kfcascadeLinkBuilder {
  Produces<aod::KFCascDataLink> cascdataLink;

  void init(InitContext const&) {}

  // build Cascade -> CascData link table
  void process(aod::Cascades const& casctable, aod::KFCascDatas const& cascdatatable)
  {
    std::vector<int> lIndices;
    lIndices.reserve(casctable.size());
    for (int ii = 0; ii < casctable.size(); ii++)
      lIndices[ii] = -1;
    for (auto& cascdata : cascdatatable) {
      lIndices[cascdata.cascadeId()] = cascdata.globalIndex();
    }
    for (int ii = 0; ii < casctable.size(); ii++) {
      cascdataLink(lIndices[ii]);
    }
  }
};

struct tracascadeLinkBuilder {
  Produces<aod::TraCascDataLink> cascdataLink;

  void init(InitContext const&) {}

  // build Cascade -> CascData link table
  void process(aod::Cascades const& casctable, aod::TraCascDatas const& cascdatatable)
  {
    std::vector<int> lIndices;
    lIndices.reserve(casctable.size());
    for (int ii = 0; ii < casctable.size(); ii++)
      lIndices[ii] = -1;
    for (auto& cascdata : cascdatatable) {
      lIndices[cascdata.cascadeId()] = cascdata.globalIndex();
    }
    for (int ii = 0; ii < casctable.size(); ii++) {
      cascdataLink(lIndices[ii]);
    }
  }
};

WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<cascadeBuilder>(cfgc),
    adaptAnalysisTask<cascadePreselector>(cfgc),
    adaptAnalysisTask<cascadeInitializer>(cfgc),
    adaptAnalysisTask<cascadeLinkBuilder>(cfgc),
    adaptAnalysisTask<kfcascadeLinkBuilder>(cfgc),
    adaptAnalysisTask<tracascadeLinkBuilder>(cfgc)};
}
